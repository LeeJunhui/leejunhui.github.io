<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS,Objective-C,">





  <link rel="alternate" href="/atom.xml" title="leejunhui's blog" type="application/atom+xml">






<meta name="description" content="2020年1月13日 类拓展、关联对象前面我们探索了 iOS 中类和分类的加载，关于类这一块的内容，我们还有一些坑没有填，比如类拓展和关联对象，今天让我们一起填下这块的坑。 一、类拓展1.1 什么是类拓展?关于类拓展的具体定义，大家可以直接参考 Apple 对于类拓展的说明。">
<meta name="keywords" content="iOS,Objective-C">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 底层探索 - 类拓展和关联对象">
<meta property="og:url" content="http://leejunhui.com/2020/01/21/iOS-底层探索-类拓展和关联对象/index.html">
<meta property="og:site_name" content="leejunhui&#39;s blog">
<meta property="og:description" content="2020年1月13日 类拓展、关联对象前面我们探索了 iOS 中类和分类的加载，关于类这一块的内容，我们还有一些坑没有填，比如类拓展和关联对象，今天让我们一起填下这块的坑。 一、类拓展1.1 什么是类拓展?关于类拓展的具体定义，大家可以直接参考 Apple 对于类拓展的说明。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150028.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150038.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150035.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150031.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150042.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150044.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150047.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150051.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150055.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200121141312.jpg">
<meta property="og:updated_time" content="2020-01-21T06:37:31.081Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS 底层探索 - 类拓展和关联对象">
<meta name="twitter:description" content="2020年1月13日 类拓展、关联对象前面我们探索了 iOS 中类和分类的加载，关于类这一块的内容，我们还有一些坑没有填，比如类拓展和关联对象，今天让我们一起填下这块的坑。 一、类拓展1.1 什么是类拓展?关于类拓展的具体定义，大家可以直接参考 Apple 对于类拓展的说明。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150028.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://leejunhui.com/2020/01/21/iOS-底层探索-类拓展和关联对象/">





  <title>iOS 底层探索 - 类拓展和关联对象 | leejunhui's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">leejunhui's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://leejunhui.com/2020/01/21/iOS-底层探索-类拓展和关联对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leejunhui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leejunhui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS 底层探索 - 类拓展和关联对象</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-21T14:27:27+08:00">
                2020-01-21
              </time>
            

            

            
          </span>
          
          <span class="post-updated">
            &nbsp; | &nbsp; 更新于
            <time itemprop="dateUpdated" datetime="2020-01-21T14:37:31+08:00" content="2020-01-21">
              2020-01-21
            </time>
          </span>
          

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-底层原理/" itemprop="url" rel="index">
                    <span itemprop="name">iOS 底层原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="2020年1月13日-类拓展、关联对象"><a href="#2020年1月13日-类拓展、关联对象" class="headerlink" title="2020年1月13日 类拓展、关联对象"></a>2020年1月13日 类拓展、关联对象</h1><p>前面我们探索了 <code>iOS</code> 中类和分类的加载，关于类这一块的内容，我们还有一些坑没有填，比如类拓展和关联对象，今天让我们一起填下这块的坑。</p>
<h1 id="一、类拓展"><a href="#一、类拓展" class="headerlink" title="一、类拓展"></a>一、类拓展</h1><h2 id="1-1-什么是类拓展"><a href="#1-1-什么是类拓展" class="headerlink" title="1.1 什么是类拓展?"></a>1.1 什么是类拓展?</h2><p>关于类拓展的具体定义，大家可以直接参考 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="noopener">Apple 对于类拓展的说明</a>。</p>
<a id="more"></a>
<blockquote>
<p>A class extension bears some similarity to a category, but it can only be added to a class for which you have the source code at compile time (the class is compiled at the same time as the class extension).</p>
<p>类拓展和分类很相似，但是前提是你拥有原始类的源码，并且是在<strong>编译时</strong>被附加到类上的。（类和类扩展同时编译）</p>
</blockquote>
<p>类拓展的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface ClassName ()</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Because no name is given in the parentheses, class extensions are often referred to as anonymous categories.<br>因为括号中没有填写任何内容，所以类扩展也被称为<strong>匿名的分类</strong>。</p>
</blockquote>
<p>我们在 <code>Xcode</code> 中创建 <code>Objective</code> 类型的文件的时候，可以选择空文件、分类、协议以及类扩展。</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150028.jpg" alt></p>
<p>如果我们选择 <code>Extension</code> 选项，<code>Xcode</code> 会帮我们生成一个 <code>NSObject + 扩展名</code> 的头文件出来，也就是说类扩展的命名方式为 <code>类名_扩展名.h</code></p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150038.jpg" alt></p>
<p>而这样的操作其实我们很少做，我们一般都是在 <code>.m</code> 文件中声明一下当前类的拓展，基本上我们都会在类扩展去声明一些<strong>私有</strong>的属性、方法。比如在 <code>.h</code> 文件中声明一个只读的属性，然后在 <code>.m</code> 文件的类拓展中去重写这个属性为可读可写。</p>
<p>我们不妨使用 <code>LLDB</code> 打印看一下类拓展究竟是不是在编译时就被附加到了类上面了呢？</p>
<h2 id="1-2-类拓展是编译时确定的吗？"><a href="#1-2-类拓展是编译时确定的吗？" class="headerlink" title="1.2 类拓展是编译时确定的吗？"></a>1.2 类拓展是编译时确定的吗？</h2><p>我们在 <code>objc-756</code> 源码中的 <code>objc-debug</code> 项目下新建一个类 <code>Person</code>，然后给这个类添加一个属性 <code>name</code>，然后在 <code>.m</code> 文件中的类拓展中添加一个属性 <code>mName</code> 和方法 <code>extM_method</code>，接着再创建一个 <code>Person</code> 的类拓展 <code>Person+Extension.h</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// Person.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br><span class="line"></span><br><span class="line">// Person.m</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &quot;Person+Extension.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Person ()</span><br><span class="line">@property (nonatomic, copy) NSString *mName;</span><br><span class="line"></span><br><span class="line">- (void)extM_method;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)extM_method&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)extH_method&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Person+Extension.h</span><br><span class="line">#import &lt;AppKit/AppKit.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface Person ()</span><br><span class="line">@property (nonatomic, copy) NSString *ext_name;</span><br><span class="line">@property (nonatomic, copy) NSString *ext_subject;</span><br><span class="line"></span><br><span class="line">- (void)extH_method;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>

<p>接着我们在 <code>main.m</code> 中来测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Person *p = [Person alloc];</span><br><span class="line">        NSLog(@&quot;%@ - %p&quot;, p, p);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 <code>Person</code> 实例化对象 <code>p</code> 这一行打上断点，然后运行项目。接着在控制台进行 <code>LLDB</code> 打印:</p>
<blockquote>
<p>因为对象的属性以及方法都存储在类对象上面，而由于类结构里面的 <code>ro</code> 是编译时就确定了其内容，所以我们只需要打印出类对象的 <code>ro</code> 结构中<br>是否有类拓展中的 <code>mName</code> 属性和 <code>extM_method</code> 方法<br>是否有类扩展中的 <code>ext_name</code> 和 <code>ext_subject</code> 属性以及 <code>extH_method</code> 方法</p>
</blockquote>
<h2 id="1-3-LLDB-验证"><a href="#1-3-LLDB-验证" class="headerlink" title="1.3 LLDB 验证"></a>1.3 LLDB 验证</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150035.jpg" alt></p>
<ul>
<li>通过 <code>x/4gx</code> 命令打印出 <code>LGPerson</code> 类对象的内存地址，以 16 进制方式打印，打印 4 段</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150031.jpg" alt></p>
<ul>
<li>因为类对象的内存地址起始为 <code>isa</code>，紧接着是 <code>superclass</code>，然后是 <code>cache_t</code>。我们前面已经分析过，在默认的 <code>arm64</code> 处理器架构下，<code>isa</code> 占 8 个字节，<code>superclass</code> 占 8 个字节，而 <code>cache_t</code> 的三个属性加起来是 8 + 4 + 4 = 16 个字节，所以要想拿到   <code>bits</code> 需要进行 8 + 8 + 16 = 32 字节的内存平移，但是这里是 16 进制，所以需要移动 0x20 个内存地址，也就是 <code>0x100002420 + 0x20 = 0x100002440</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150042.jpg" alt></p>
<ul>
<li>因为类对象的 <code>data()</code> 属性会返回 <code>bits.data()</code>，所以这里直接打印刚才取到的 <code>bits</code> 的 <code>data()</code> 属性，而 <code>bits</code> 的 <code>data()</code> 属性其实返回的是 <code>rw</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">class_rw_t</span>* data() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150044.jpg" alt></p>
<ul>
<li>接着打印 <code>rw</code> 的属性 <code>ro</code>，然后我们先尝试读取 <code>baseMethodList</code> 属性，该属性存储的是编译时确定的类的所有的方法。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150047.jpg" alt></p>
<ul>
<li>因为 <code>baseMethodList</code> 属性是一个 <code>List</code> 类型的容器，我们直接使用 <code>get(index)</code> 来获取其 <code>index</code> 处的值，结果我们所要寻找的 <code>extH_method</code> 和 <code>extM_method</code> 出现了，不过还没结束，我们还没验证类拓展中声明的两个属性，让我们打印一下 <code>ro</code> 的 <code>baseProperties</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150051.jpg" alt></p>
<ul>
<li>我们很清楚的看到，<code>mName</code>，<code>ext_name</code> 和 <code>ext_subject</code> 都被找到了，那么是不是就是说类拓展就是编译时确定的了呢？我们还漏掉了这三个属性的 <code>getter</code> 和 <code>setter</code> 了，让我们回过头再去 <code>baseMethodList</code> 中查找一下</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150055.jpg" alt></p>
<ul>
<li>Bingo! 我们类拓展定义的属性的 <code>getter</code> 和 <code>setter</code> 方法也生成了，至此，我们就完全确定了类拓展在编译时就会被加载到类的 <code>ro</code> 中。</li>
</ul>
<blockquote>
<p>这里有个注意点，就是如果我们没有在类的头文件或者源文件中引入单独的类拓展头文件，那么这个单独的类拓展的头文件里面的属性和方法将不会被加载到类上面来。</p>
</blockquote>
<h2 id="1-4-类拓展和分类的区别"><a href="#1-4-类拓展和分类的区别" class="headerlink" title="1.4 类拓展和分类的区别"></a>1.4 类拓展和分类的区别</h2><table>
<thead>
<tr>
<th>研究对象</th>
<th>加载时机</th>
<th>操作对象</th>
<th>能否通过@property声明属性生成 getter 和 setter</th>
</tr>
</thead>
<tbody><tr>
<td>分类(实现了load方法)</td>
<td>运行时</td>
<td>rw</td>
<td>不能，需要借助关联对象来实现</td>
</tr>
<tr>
<td>分类(没有实现load方法)</td>
<td>编译时</td>
<td>ro</td>
<td>不能，需要借助关联对象来实现</td>
</tr>
<tr>
<td>类拓展</td>
<td>编译时</td>
<td>ro</td>
<td>可以</td>
</tr>
</tbody></table>
<h1 id="二、关联对象"><a href="#二、关联对象" class="headerlink" title="二、关联对象"></a>二、关联对象</h1><p>上一节我们探索了类拓展以及类拓展与分类的区别，我们知道，类拓展中可以声明属性，编译器会帮助我们生成属性对应的 <code>getter</code> 和 <code>setter</code> 方法，但是分类通过 <code>@property</code> 的方式来声明属性却不能生成 <code>getter</code> 和 <code>setter</code> 方法。而其实 <code>iOS</code> 中有一种方式可以为分为增加具有 <code>getter</code> 和 <code>setter</code> 的属性，那就是 - 关联对象 <code>Associated Objects</code> 。</p>
<h2 id="2-1-关联对象定义"><a href="#2-1-关联对象定义" class="headerlink" title="2.1 关联对象定义"></a>2.1 关联对象定义</h2><p>关联对象的官方定义可以在 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocAssociativeReferences.html#//apple_ref/doc/uid/TP30001163-CH24" target="_blank" rel="noopener">苹果官方文档</a> 上找到。</p>
<blockquote>
<p>Associative references, available starting in OS X v10.6, simulate the addition of object instance variables to an existing class. Using associative references, you can add storage to an object without modifying the class declaration. This may be useful if you do not have access to the source code for the class, or if for binary-compatibility reasons you cannot alter the layout of the object.</p>
</blockquote>
<blockquote>
<p>关联引用，是从 <code>OS X 10.6</code> 开始启用的，模拟了将对象实例变量添加到已经存在的类中。通过使用关联引用，你可以在不修改类声明的前提下为对象添加内容。如果你无权访问该类的源代码，或者由于二进制兼容性原因而无法更改该对象的布局，则这可能很有用。</p>
</blockquote>
<blockquote>
<p>Associations are based on a key. For any object you can add as many associations as you want, each using a different key. An association can also ensure that the associated object remains valid for at least the lifetime of the source object.</p>
</blockquote>
<blockquote>
<p>关联引用机制基于 <code>key</code>。对于任何对象，你都可以根据需要添加任意数量的关联引用，每个关联都使用不同的 <code>key</code>。关联引用还可以确保关联的对象至少在源对象的声明周期内保持有效。</p>
</blockquote>
<p>而关于关联对象的最佳实践可以参考 <a href="https://nshipster.com/associated-objects/" target="_blank" rel="noopener">NSHipster - Associated Objects</a> 一文。</p>
<p>从苹果官方文档可以看到，关联引用其实不是只能在分类中使用，只不过对于我们日常开发来说，分类中使用关联引用还是更常用的场景。相信大多数开发者都知道怎么使用关联引用，的确，关联引用使用起来很简单，不外乎两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 设置关联对象</span><br><span class="line">objc_setAssociatedObject()</span><br><span class="line"></span><br><span class="line">// 获取关联对象</span><br><span class="line">objc_getAssociatedObject()</span><br></pre></td></tr></table></figure>

<p>我们如果要给一个分类中的属性设置关联对象，需要重写属性的 <code>setter</code> 方法，然后使用 <code>objc_setAssociatedObject</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setXXX:(关联值数据类型)关联值</span><br><span class="line">    objc_setAssociatedObject(self, 关联的key, 关联值, 关联对象内存管理策略);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后还需要重写 <code>getter</code> 方法，然后使用 <code>objc_getAssociatedObject</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (关联值数据类型)关联值&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, 关联的key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其中的关联对象内存管理策略如下表所示：</p>
<table>
<thead>
<tr>
<th>关联策略</th>
<th>等同的 @property</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>@property (assign) 或 @property (unsafe_unretained) <span class="Apple-tab-span" style="white-space:pre"></span> 指定一个关联对象的弱引用。</td>
<td>指定一个关联对象的弱引用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>@property (nonatomic, strong)</td>
<td>指定一个关联对象的强引用，不能被原子化使用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>@property (nonatomic, copy)</td>
<td>指定一个关联对象的copy引用，不能被原子化使用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>@property (atomic, strong)</td>
<td>指定一个关联对象的强引用，能被原子化使用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>@property (atomic, copy)</td>
<td>指定一个关联对象的copy引用，能被原子化使用。</td>
</tr>
</tbody></table>
<h2 id="2-2-关联对象底层原理"><a href="#2-2-关联对象底层原理" class="headerlink" title="2.2 关联对象底层原理"></a>2.2 关联对象底层原理</h2><blockquote>
<p>关于关联对象的底层原理，这里有一篇灯塔 <code>draveness</code> 的博文 <a href="https://draveness.me/ao" target="_blank" rel="noopener">关联对象 AssociatedObject 完全解析</a> 十分值得一读。</p>
</blockquote>
<p>当然，如果也可以跟随笔者一起探索下关联对象的底层原理。我们不妨从最直观的 <code>objc_setAssociatedObject</code> 方法开始切入：</p>
<h2 id="2-3-objc-setAssociatedObject"><a href="#2-3-objc-setAssociatedObject" class="headerlink" title="2.3 objc_setAssociatedObject"></a>2.3 objc_setAssociatedObject</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// objc-runtime.mm</span><br><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">    _object_set_associative_reference(object, (void *)key, value, policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objc_setAssociatedObject</code> 方法的实现又包裹了一层，其实现为 <code>_object_set_associative_reference</code></p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200121141312.jpg" alt></p>
<p>而 <code>_object_set_associative_reference</code> 方法的实现非常长，这里就分段来进行探索吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This code used to work when nil was passed for object and key. Some code</span></span><br><span class="line"><span class="comment">// probably relies on that to not crash. Check and handle it explicitly.</span></span><br><span class="line"><span class="comment">// rdar://problem/44094390</span></span><br><span class="line"><span class="keyword">if</span> (!object &amp;&amp; !value) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据注释我们可以知道，当传入的 <code>object</code> 和 <code>key</code> 同时为 <code>nil</code> 的时候，直接返回。这样的处理是为了避免传入空值时而导致崩溃。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-references.mm</span></span><br><span class="line"><span class="keyword">if</span> (object-&gt;getIsa()-&gt;forbidsAssociatedObjects())</span><br><span class="line">        _objc_fatal(<span class="string">"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects"</span>, object, object_getClassName(object));</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-runtime-new.h        </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">forbidsAssociatedObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (data()-&gt;flags &amp; RW_FORBIDS_ASSOCIATED_OBJECTS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>判断要进行关联的对象是否禁用掉了关联引用，这里是通过对象的 <code>isa</code> 的 <code>rw</code> 的 <code>flags</code> 属性与上一个宏 <code>RW_FORBIDS_ASSOCIATED_OBJECTS</code>来判断的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line"><span class="function">ObjcAssociation <span class="title">old_association</span><span class="params">(<span class="number">0</span>, nil)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>初始化一个 <code>ObjcAssociation</code> 对象，用于持有原有的关联对象</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id new_value = value ? acquireValue(value, policy) : nil;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>判断传入的关联对象值是否存在，如果存在就调用 <code>acquireValue</code> 方法来获取值，我们可以进入 <code>acquireValue</code> 方法看一下:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> id <span class="title">acquireValue</span><span class="params">(id value, <span class="keyword">uintptr_t</span> policy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (policy &amp; <span class="number">0xFF</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_RETAIN:</span><br><span class="line">        <span class="keyword">return</span> objc_retain(value);</span><br><span class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_COPY:</span><br><span class="line">        <span class="keyword">return</span> ((id(*)(id, SEL))objc_msgSend)(value, SEL_copy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到 <code>acquireValue</code> 会根据关联策略来进行 <code>retain</code> 或 <code>copy</code> 消息的发送</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AssociationsManager manager;</span><br><span class="line"><span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line"><span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>初始化一个 <code>AssociationsManager</code> 对象，然后获取一个 <code>AssociationsHashMap</code> 哈希表，然后通过 <code>DISGUISE</code> 方法作为去哈希表查找的 <code>key</code>。这里的 <code>DISGUISE</code> 其实进行了按位取反的操作。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> disguised_ptr_t <span class="title">DISGUISE</span><span class="params">(id value)</span> </span>&#123; <span class="keyword">return</span> ~<span class="keyword">uintptr_t</span>(value); &#125;</span><br></pre></td></tr></table></figure>

<p>如果传入的关联对象值存在，说明是进行赋值操作；如果传入的关联对象值不存在，说明是进行置空操作。这里我们先看一下赋值操作的流程:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.通过上一步按位取反之后的结果，在 <code>AssociationsHashMap</code> 哈希表中查询，这里是通过迭代器的方式进行查询，查询的结果是 <code>ObjcAssociation</code> 对象，这个结构也是一个哈希表，其内部存储的是 <code>_object_set_associative_reference</code> 方法传入的 <code>key</code> 为键，<code>ObjcAssociation</code> 对象为值的键值对<br>2.如果没有查询到，说明之前在当前类上<strong>没有设置过</strong>关联对象。则需要初始化一个 <code>ObjectAssociationMap</code> 出来，然后通过 <code>setHasAssociatedObjects</code> 设置当前对象的 <code>isa</code> 的 <code>has_assoc</code> 属性为 <code>true</code><br>3.如果查询到了，说明之前在当前类上<strong>设置过</strong>关联对象，接着需要看 <code>key</code> 是否存在，如果 <code>key</code> 存在，那么就需要更新原有的关联对象；如果 <code>key</code> 不存在，则需要新增一个关联对象</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line"><span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">    ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">    ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">    <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">        old_association = j-&gt;second;</span><br><span class="line">        refs-&gt;erase(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为来到这里的条件是 <code>new_value</code> 为 <code>nil</code>，也就代表着要删除关联对象，内部的逻辑和上面的流程大同小异，不过最后多了一步在 <code>ObjectAssociationMap</code> 擦除 <code>key</code> 对应的节点</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line"><span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后会判断 <code>old_association</code> 是否有值，如果有的话就释放掉，当然前提是旧的关联对象的策略是 <code>OBJC_ASSOCIATION_SETTER_RETAIN</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">ReleaseValue</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(ObjcAssociation &amp;association)</span> </span>&#123;</span><br><span class="line">        releaseValue(association.value(), association.policy());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseValue</span><span class="params">(id value, <span class="keyword">uintptr_t</span> policy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) &#123;</span><br><span class="line">        <span class="keyword">return</span> objc_release(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-4-objc-getAssociatedObject"><a href="#2-4-objc-getAssociatedObject" class="headerlink" title="2.4 objc_getAssociatedObject"></a>2.4 objc_getAssociatedObject</h2><p><code>objc_setAssociatedObject</code> 方法分析完了，我们接着看另外一个重要的方法 <code>objc_getAssociatedObject</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _object_get_associative_reference(object, (<span class="keyword">void</span> *)key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，跟 <code>objc_setAssociatedObject</code> 一样，<code>objc_getAssociatedObject</code> 这里又包裹了一层，其实现为 <code>_object_get_associative_reference</code>，而这个方法相比于上一节的 <code>_object_set_associative_reference</code> 要简单一些，我们就直接贴出完整的代码</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">id _object_get_associative_reference(id object, <span class="keyword">void</span> *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    <span class="keyword">uintptr_t</span> policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.value();</span><br><span class="line">                policy = entry.policy();</span><br><span class="line">                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;</span><br><span class="line">                    objc_retain(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        objc_autorelease(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.先初始化一个空的 <code>value</code>，以及一个策略为 <code>OBJC_ASSOCIATION_ASSIGN</code> 的 <code>policy</code><br>2.初始化一个 <code>AssociationsManager</code> 关联对象管理类，接着拿到 <code>AssociationsHashMap</code> 对象，这个对象在 <code>AssociationsManager</code> 底层是静态的<br>3.然后以 <code>DISGUISE(object)</code> 按位取反之后的结果为键去查询 <code>AssociationsHashMap</code><br>4.如果在 <code>AssociationsHashMap</code> 中扎到了，接着以 <code>key</code> 为键去 <code>ObjectAssociationMap</code> 中查询 <code>ObjcAssociation</code><br>如果在 <code>ObjectAssociationMap</code> 中查询到了 <code>ObjcAssociation</code>，则把值和策略赋值给方法入口声明的两个临时变量，然后判断获取到的关联对象的策略是否为 <code>OBJC_ASSOCIATION_GETTER_RETAIN</code>，如果是的话，需要对关联值进行 <code>retain</code> 操作<br>5.最后判断如果关联值是否存在且策略为 <code>OBJC_ASSOCIATION_GETTER_AUTORELEASE</code>，是的话就需要调用 <code>objc_autorelease</code> 来释放关联值<br>6.最后返回关联值</p>
</blockquote>
<h2 id="2-5-objc-removeAssociatedObjects"><a href="#2-5-objc-removeAssociatedObjects" class="headerlink" title="2.5 objc_removeAssociatedObjects"></a>2.5 objc_removeAssociatedObjects</h2><p><code>objc_removeAssociatedObjects</code> 方法我们平时可能用的不多，从字面含义来看，这个方法应该是用来删除关联对象。我们来到它的定义处：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        _object_remove_assocations(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里会判断 <code>object</code> 存在且有关联对象才会进入真正的实现 <code>_object_remove_assocations</code>，该实现也不是很复杂，我们还是直接贴出代码</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_remove_assocations(id object) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the secondary table.</span></span><br><span class="line">            <span class="keyword">delete</span> refs;</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里会将对象包含的所有关联对象加入到一个 <code>vector</code> 中，然后对所有的 <code>ObjcAssociation</code> 对象调用 <code>ReleaseValue()</code> 方法，释放不再被需要的值。</p>
</blockquote>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><ul>
<li>类拓展是一种匿名的分类，加载时机为编译时</li>
<li>类拓展可以添加属性和方法以及实例变量，分类只能添加方法，属性，但是需要借助关联对象来生成 <code>getter</code> 和 <code>setter</code>，而且分类不能声明实例变量</li>
<li>关联对象在底层其实是 <code>ObjcAssociation</code> 对象的结构</li>
<li>全局有一个 <code>AssociationsManager</code> 管理类存储了一个静态的哈希表 <code>AssociationsHashMap</code>，这个哈希表存储的是以对象指针为键，以该对象所有的关联对象为值，而对象所有的关联对象又是以 <code>ObjectAssociationMap</code> 来存储的</li>
<li><code>ObjectAssociationMap</code> 存储结构为 <code>key</code> 为键，<code>ObjcAssociation</code> 为值</li>
<li>快速判断一个对象是否存在关联对象，可以直接取对象 <code>isa</code> 的 <code>has_assoc</code></li>
</ul>
<h1 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h1><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="noopener">Apple - 类拓展</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocAssociativeReferences.html#//apple_ref/doc/uid/TP30001163-CH24" target="_blank" rel="noopener">Apple - 关联对象</a> </p>
<p><a href="https://nshipster.com/associated-objects/" target="_blank" rel="noopener">NSHipster - Associated Objects</a> </p>
<p><a href="https://draveness.me/ao" target="_blank" rel="noopener">Draveness - 关联对象 AssociatedObject 完全解析</a></p>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode3.jpg" alt="leejunhui wechat" style="width: 200px; max-width: 100%;">
    <div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div>
</div>

      </div>
    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    leejunhui
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://leejunhui.com/2020/01/21/iOS-底层探索-类拓展和关联对象/" title="iOS 底层探索 - 类拓展和关联对象">http://leejunhui.com/2020/01/21/iOS-底层探索-类拓展和关联对象/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/Objective-C/" rel="tag"># Objective-C</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/19/iOS-底层探索-分类的加载/" rel="next" title="iOS 底层探索 - 分类的加载">
                <i class="fa fa-chevron-left"></i> iOS 底层探索 - 分类的加载
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/15/iOS-底层探索-KVC/" rel="prev" title="iOS 底层探索 - KVC">
                iOS 底层探索 - KVC <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="leejunhui">
            
              <p class="site-author-name" itemprop="name">leejunhui</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#2020年1月13日-类拓展、关联对象"><span class="nav-number">1.</span> <span class="nav-text">2020年1月13日 类拓展、关联对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一、类拓展"><span class="nav-number">2.</span> <span class="nav-text">一、类拓展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-什么是类拓展"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 什么是类拓展?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-类拓展是编译时确定的吗？"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 类拓展是编译时确定的吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-LLDB-验证"><span class="nav-number">2.3.</span> <span class="nav-text">1.3 LLDB 验证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-类拓展和分类的区别"><span class="nav-number">2.4.</span> <span class="nav-text">1.4 类拓展和分类的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、关联对象"><span class="nav-number">3.</span> <span class="nav-text">二、关联对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-关联对象定义"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 关联对象定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-关联对象底层原理"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 关联对象底层原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-objc-setAssociatedObject"><span class="nav-number">3.3.</span> <span class="nav-text">2.3 objc_setAssociatedObject</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-objc-getAssociatedObject"><span class="nav-number">3.4.</span> <span class="nav-text">2.4 objc_getAssociatedObject</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-objc-removeAssociatedObjects"><span class="nav-number">3.5.</span> <span class="nav-text">2.5 objc_removeAssociatedObjects</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、总结"><span class="nav-number">4.</span> <span class="nav-text">三、总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、参考资料"><span class="nav-number">5.</span> <span class="nav-text">四、参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leejunhui</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
