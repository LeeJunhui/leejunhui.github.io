<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS,Objective-C,KVC,">





  <link rel="alternate" href="/atom.xml" title="leejunhui's blog" type="application/atom+xml">






<meta name="description" content="一、KVC 初探Key Value Coding 也即 KVC 是 iOS 开发中一个很重要的概念，中文翻译过来是 键值编码 ，关于这个概念的具体定义可以在 Apple 的官方文档处找到。  Key-value coding is a mechanism enabled by the NSKeyValueCoding informal protocol that objects adopt to">
<meta name="keywords" content="iOS,Objective-C,KVC">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 底层探索 - KVC">
<meta property="og:url" content="http://leejunhui.com/2020/02/15/iOS-底层探索-KVC/index.html">
<meta property="og:site_name" content="leejunhui&#39;s blog">
<meta property="og:description" content="一、KVC 初探Key Value Coding 也即 KVC 是 iOS 开发中一个很重要的概念，中文翻译过来是 键值编码 ，关于这个概念的具体定义可以在 Apple 的官方文档处找到。  Key-value coding is a mechanism enabled by the NSKeyValueCoding informal protocol that objects adopt to">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014508.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014453.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014503.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014457.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014511.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014515.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014519.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014523.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014527.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014536.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014545.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014549.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015436.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015453.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015441.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015445.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015449.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015438.jpg">
<meta property="og:updated_time" content="2020-02-14T18:37:00.963Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS 底层探索 - KVC">
<meta name="twitter:description" content="一、KVC 初探Key Value Coding 也即 KVC 是 iOS 开发中一个很重要的概念，中文翻译过来是 键值编码 ，关于这个概念的具体定义可以在 Apple 的官方文档处找到。  Key-value coding is a mechanism enabled by the NSKeyValueCoding informal protocol that objects adopt to">
<meta name="twitter:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014508.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://leejunhui.com/2020/02/15/iOS-底层探索-KVC/">





  <title>iOS 底层探索 - KVC | leejunhui's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">leejunhui's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://leejunhui.com/2020/02/15/iOS-底层探索-KVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leejunhui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leejunhui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS 底层探索 - KVC</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-15T02:34:44+08:00">
                2020-02-15
              </time>
            

            

            
          </span>
          
          <span class="post-updated">
            &nbsp; | &nbsp; 更新于
            <time itemprop="dateUpdated" datetime="2020-02-15T02:37:00+08:00" content="2020-02-15">
              2020-02-15
            </time>
          </span>
          

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-底层原理/" itemprop="url" rel="index">
                    <span itemprop="name">iOS 底层原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一、KVC-初探"><a href="#一、KVC-初探" class="headerlink" title="一、KVC 初探"></a>一、KVC 初探</h1><p><code>Key Value Coding</code> 也即 <code>KVC</code> 是 <code>iOS</code> 开发中一个很重要的概念，中文翻译过来是 <code>键值编码</code> ，关于这个概念的具体定义可以在 <code>Apple</code> 的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="noopener">官方文档</a>处找到。</p>
<blockquote>
<p>Key-value coding is a mechanism enabled by the NSKeyValueCoding informal protocol that objects adopt to provide indirect access to their properties.<br>【译】<code>KVC</code> 是通过 <code>NSKeyValueCoding</code> 这个非正式协议启用的一种机制，而遵循了这个协议的对象就提供了对其属性的间接访问。</p>
</blockquote>
<a id="more"></a>
<p>我们通常使用访问器方法来访问对象的属性，即使用 <code>getter</code> 来获取属性值，使用 <code>setter</code> 来设置属性值。而在 <code>Objective-C</code> 中，我们还可以直接通过实例变量的方式来获取属性值和设置属性值。如下面的代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// JHPerson.h</span><br><span class="line">@interface JHPerson : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">    NSString *myName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// ViewController.m</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    JHPerson *person = [[JHPerson alloc] init];</span><br><span class="line">    person.name      = @&quot;leejunhui&quot;;</span><br><span class="line">    person.age       = 20;</span><br><span class="line">    person-&gt;myName   = @&quot;leejunhui&quot;;</span><br><span class="line">    NSLog(@&quot;%@ - %ld - %@&quot;,person.name, person.age,person-&gt;myName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式我们再熟悉不过了，关于属性会由编译器自动生成 <code>getter</code> 和 <code>setter</code> 以及对应的实例变量前面我们已经探索过了，我们可以在 <code>ro</code> 中来找到它们的踪影，感兴趣的读者可以翻阅前面的文章。</p>
<blockquote>
<p>这里再明确下实例变量、成员变量、属性之间的区别：<br>在 @interface 括号里面声明的变量统称为 <strong>成员变量</strong><br>而成员变量实际上由两部分组成：<strong>实例变量</strong> + <strong>基本数据类型变量</strong><br>而<strong>属性</strong> = <strong>成员变量</strong> + <strong>getter方法</strong> + <strong>setter方法</strong></p>
</blockquote>
<p>那其实这里分两种情况，自己实现和编译器帮我们实现。</p>
<h2 id="1-1-自己实现-getter-和-setter"><a href="#1-1-自己实现-getter-和-setter" class="headerlink" title="1.1 自己实现 getter 和 setter"></a>1.1 自己实现 <code>getter</code> 和 <code>setter</code></h2><p>这里我们以 <code>JHPerson</code> 类的 <code>name</code> 属性为例，我们分别重写 <code>name</code> 的 <code>getter</code> 和 <code>setter</code> 方法，这里还有个注意点，我们需要在 <code>@interface</code> 中声明一下实例变量 <code>_name</code>，具体代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// JHPerson.h</span><br><span class="line">@interface JHPerson : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">    NSString *myName;</span><br><span class="line">    NSString *_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// JHPerson.m</span><br><span class="line">@implementation JHPerson</span><br><span class="line"></span><br><span class="line">- (NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    return _name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>接着，我们在 <code>main.m</code> 中使用点语法对 <code>name</code> 进行赋值，然后打印 <code>name</code> 的值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;JHPerson.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JHPerson *person = [[JHPerson alloc] init];</span><br><span class="line">        person.name      = @&quot;leejunhui&quot;;</span><br><span class="line">        NSLog(@&quot;person 姓名为：%@&quot;, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-[JHPerson setName:] - leejunhui</span><br><span class="line">-[JHPerson name] - leejunhui</span><br><span class="line">person 姓名为：leejunhui</span><br></pre></td></tr></table></figure>

<p>显然，这里的结果就表明了 <code>person.name      = @&quot;leejunhui&quot;;</code> 其实是调用了 <code>JHPerson</code> 类的 <code>setName</code> 方法，而 <code>NSLog(@&quot;person 姓名为：%@&quot;, person.name);</code> 则是调用了 <code>name</code> 方法。</p>
<p>这块的逻辑我相信读者应该都比较熟悉了，接下来我们再分析编译器自动生成 <code>getter</code> 和 <code>setter</code> 的场景。</p>
<h2 id="1-2-编译器自动实现-getter-和-setter"><a href="#1-2-编译器自动实现-getter-和-setter" class="headerlink" title="1.2 编译器自动实现 getter 和 setter"></a>1.2 编译器自动实现 <code>getter</code> 和 <code>setter</code></h2><p>我们探索前先思考一个问题，按照我们现在的认知，如果我们不去重写属性的 <code>getter</code> 和 <code>setter</code> 方法以及声明对应的实例变量，那么编译器就会帮我们做这件事，那么是不是说有多少个属性，就会生成多少个对应的 <code>getter</code> 和 <code>setter</code> 呢？显然，编译器不会这么傻，这样做不论是从性能上还是设计上都十分笨拙，我们在 <code>libObjc</code> 源码中可以找到这么一个源文件：<code>objc-accessors.mm</code>，这个文件中有许多从字面意思上看起来像是设置属性的方法，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014508.jpg" alt="img"></p>
<p>我们聚焦这个方法: <code>objc_setProperty_nonatomic_copy</code>，为什么呢？因为 <code>name</code> 属性声明为 <code>@property (nonatomic, copy) NSString *name;</code>，二者都包含 <code>nonatomic</code> 和 <code>copy</code> 关键字，我们不妨在 <code>objc_setProperty_nonatomic_copy</code> 方法处打上断点，注意，此时我们需要注释掉我们刚才自己添加的 <code>getter</code> 和 <code>setter</code> 方法。</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014453.jpg" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014503.jpg" alt="img"></p>
<p>Bingo~，<code>objc_setProperty_nonatomic_copy</code> 方法果然被调用了，并且我们赋的值也是对的，我们来到这个方法内部实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setProperty_nonatomic_copy</span><span class="params">(id self, SEL _cmd, id newValue, <span class="keyword">ptrdiff_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reallySetProperty(self, _cmd, newValue, offset, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里又包裹了一层，真正的实现为 <code>reallySetProperty</code>：</p>
<p>这个方法不是很复杂，我们简单过一下这个方法的参数。</p>
<blockquote>
<p>1.首先是这个方法的 <code>offset</code> 参数，前面我们已经探索过关于<em>内存偏移</em>的内容，这里不再赘述。我们知道，对象的 <code>isa</code> 指针占 <code>8</code> 个字节，还寄的我们的 <code>JHPerson</code> 类的声明中有一个实例变量 <code>myName</code> 吗，这是一个字符串类型的实例变量，也占用 <code>8</code> 个字节，所以这里的 <code>offset</code> 为 <code>16</code>，意思就是偏移 <code>16</code> 个字节来设置属性 <code>name</code>。<br><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014457.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>2.然后是 <code>atomic</code> 参数，这个参数取决于属性声明时是 <code>atomic</code> 还是 <code>nonatomic</code>，这个关键字表示是操作的原子性，而网上很多资料都说 <code>atomic</code> 是来保证对象的多线程安全，其实不然，它只是能保证你访问的时候给你返回一个完好无损的 <code>Value</code> 而已，<a href="https://link.jianshu.com/?t=https://realm.io/news/tmi-objective-c-property-attributes/" target="_blank" rel="noopener">Realm官方对此相关的解释</a>，举个例子：</p>
<blockquote>
<p>如果线程 A 调了 getter，与此同时线程 B 、线程 C 都调了 setter——那最后线程 A get 到的值，有3种可能：可能是 B、C set 之前原始的值，也可能是 B set 的值，也可能是 C set 的值。同时，最终这个属性的值，可能是 B set 的值，也有可能是 C set 的值。所以 <code>atomic</code> 并不能保证对象的线程安全。也就是说 <code>atomic</code> 所说的线程安全只是保证了<code>getter</code> 和 <code>setter</code> 存取方法的线程安全，并不能保证整个对象是线程安全的。</p>
</blockquote>
<p><code>nonatomic</code> 关键字就没有这个保证了，<code>nonatomic</code> 返回你的对象可能就不是完整的<code>value</code> 。因此，在多线程的环境下原子操作是非常必要的，否则有可能会引起错误的结果。但仅仅使用 <code>atomic</code> 并不会使得对象线程安全，我们还要为对象线程添加 <code>lock</code> 来确保线程的安全。</p>
<p><strong><code>nonatomic</code> 对象 <code>setter</code> 和 <code>getter</code> 方法的实现</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; - (void)setCurrentImage:(UIImage *)currentImage</span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;    if (_currentImage != currentImage) &#123;</span><br><span class="line">&gt;        [_currentImage release];</span><br><span class="line">&gt;        _currentImage = [currentImage retain];</span><br><span class="line">&gt;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;- (UIImage *)currentImage</span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;    return _currentImage;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong><code>atomic</code> 对象 <code>setter</code> 和 <code>getter</code> 方法的实现</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; - (void)setCurrentImage:(UIImage *)currentImage</span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;    @synchronized(self) &#123;</span><br><span class="line">&gt;        if (_currentImage != currentImage) &#123;</span><br><span class="line">&gt;            [_currentImage release];</span><br><span class="line">&gt;            _currentImage = [currentImage retain];</span><br><span class="line">&gt;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;- (UIImage *)currentImage</span><br><span class="line">&gt;&#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        return _currentImage;</span><br><span class="line">    &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>3.最后是 <code>copy</code> 和 <code>mutableCopy</code> 参数，说到 <code>copy</code> 关键字不妨来复习下 <code>iOS</code> 中的属性标识符以及相应的变量标识符。</p>
</blockquote>
<hr>
<p>在 <code>ARC</code> 中与内存管理有关的变量标识符，有下面几种：</p>
<ul>
<li><code>__strong</code></li>
<li><code>__weak</code></li>
<li><code>__unsafe_unretained</code></li>
<li><code>__autoreleasing</code></li>
</ul>
<table>
<thead>
<tr>
<th>变量标识符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>__strong</code></td>
<td>默认使用的标识符。只有还有一个强指针指向某个对象，这个对象就会一直存活</td>
</tr>
<tr>
<td><code>__weak</code></td>
<td>声明这个引用<strong>不会保持</strong>被引用对象的存活，如果对象没有强引用了，弱引用会被<strong>置为 <code>nil</code></strong></td>
</tr>
<tr>
<td><code>__unsafe_unretained</code></td>
<td>声明这个引用<strong>不会保持</strong>被引用对象的存活，如果对象没有强引用了，它不<strong>会被置为 nil</strong>。如果它引用的对象被回收掉了，该指针就变成了<strong>野指针</strong></td>
</tr>
<tr>
<td><code>__autoreleasing</code></td>
<td>用于标示使用引用传值的参数（id *），在函数返回时会被自动释放掉</td>
</tr>
</tbody></table>
<p>变量标识符的用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number* __strong num = [[Number alloc] init];</span><br></pre></td></tr></table></figure>

<p>注意 <code>__strong</code> 的位置应该放到 <code>*</code> 和变量名中间，放到其他的位置严格意义上说是不正确的，只不过编译器不会报错。</p>
<hr>
<p><strong>属性标识符</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic/nonatomic/assign/retain/strong/weak/unsafe_unretained/copy) Number* num</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性标识符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>atomic</code></td>
<td>表明该属性的读写操作是原子性的，但不保证对象的多线程安全</td>
</tr>
<tr>
<td><code>nonatomic</code></td>
<td>表明该属性的读写操作是非原子性的，性能强于<code>atomic</code>，因为没有锁的开销</td>
</tr>
<tr>
<td><code>assign</code></td>
<td>表明 <code>setter</code> 仅仅是一个<strong>简单的赋值操作</strong>，通常用于<strong>基本的数值类型</strong>，例如 <code>CGFloat</code> 和 <code>NSInteger</code></td>
</tr>
<tr>
<td><code>strong</code></td>
<td>表明属性定义一个<strong>拥有者关系</strong>。当给属性设定一个新值的时候，首先这个值进行 <code>retain</code> ，旧值进行 <code>release</code>，然后进行赋值操作</td>
</tr>
<tr>
<td><code>weak</code></td>
<td>表明属性定义了一个<strong>非拥有者关系</strong>。当给属性设定一个新值的时候，这个值不会进行 <code>retain</code>，旧值也不会进行 <code>release</code>， 而是进行类似 <code>assign</code> 的操作。不过当属性指向的对象被销毁时，该属性会被<strong>置为nil</strong>。</td>
</tr>
<tr>
<td><code>unsafe_unretained</code></td>
<td>语义和 <code>assign</code> 类似，不过是<strong>用于对象类型</strong>的，表示一个非拥有(<code>unretained</code>)的，同时也不会在对象被销毁时置为 <code>nil</code> 的(<code>unsafe</code>)关系。</td>
</tr>
<tr>
<td><code>copy</code></td>
<td>类似于 <code>strong</code>，不过在赋值时进行 <code>copy</code> 操作而不是 <code>retain</code> 操作。通常在需要保留某个不可变对象（ <code>NSString</code> 最常见），并且<strong>防止它被意外改变</strong>时使用。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>错误使用属性标识符的后果</strong><br>如果我们给一个原始类型设置 <code>strong\weak\copy</code> ，编译器会直接报错：</p>
<blockquote>
<p>Property with ‘retain (or strong)’ attribute must be of object type</p>
</blockquote>
<p>设置为 <code>unsafe_unretained</code> 倒是可以通过编译，只是用起来跟 <code>assign</code> 也没有什么区别。<br>反过来，我们给一个 <code>NSObject</code> 属性设置为 assign，编译器会报警：</p>
<blockquote>
<p>Assigning retained object to unsafe property; object will be released after assignment</p>
</blockquote>
<p>正如警告所说的，对象在赋值之后被立即释放，对应的属性也就成了野指针，运行时跑到属性有关操作会直接崩溃掉。和设置成 <code>unsafe_unretained</code> 是一样的效果（设置成 <code>weak</code> 不会崩溃）。</p>
<p><strong><code>unsafe_unretained</code> 的用处</strong><br><code>unsafe_unretained</code> 差不多是实际使用最少的一个标识符了，在使用中它的用处主要有下面几点：<br>1.兼容性考虑。<code>iOS4</code> 以及之前还没有引入 <code>weak</code>，这种情况想表达弱引用的语义只能使用 <code>unsafe_unretained</code>。这种情况现在已经很少见了。<br>2.性能考虑。使用 <code>weak</code> 对性能有一些影响，因此对性能要求高的地方可以考虑使用 <code>unsafe_unretained</code> 替换 <code>weak</code>。一个例子是 <a href="https://github.com/ibireme/YYModel/blob/master/YYModel/NSObject%2BYYModel.m" target="_blank" rel="noopener">YYModel 的实现</a>，为了追求更高的性能，其中大量使用 <code>unsafe_unretained</code> 作为变量标识符。</p>
</blockquote>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reallySetProperty</span><span class="params">(id self, SEL _cmd, id newValue, <span class="keyword">ptrdiff_t</span> offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> copy, <span class="keyword">bool</span> mutableCopy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot = (id*) ((<span class="keyword">char</span>*)self + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>我们把目光转移到 <code>reallySetProperty</code> 中来，这里先判断的 <code>offset</code> 是否为 <code>0</code>。</p>
<ul>
<li>如果为 <code>0</code>，直接调用方法 <code>object_setClass</code> 设置当前对象的 <code>class</code>，显然就是设置对象的 <code>isa</code> 指针。</li>
</ul>
</li>
<li><p>声明一个临时变量 <code>oldValue</code>。</p>
</li>
<li><p>将 <code>self</code> 先强转为字符串指针，然后进行内存平移得到要设置的属性的内存偏移值，然后将其强转为 <code>id*</code> 类型。</p>
</li>
<li><p>判断要设置的属性的标识符是否需要进行 <code>copy</code> 操作</p>
<ul>
<li>如果需要，则对传进来的 <code>newValue</code> 也就是要设置的属性值发送 <code>copyWithZone</code> 消息，<strong>这一步的目的是拿到 <code>newValue</code> 的副本，然后覆写 <code>newValue</code>，使得传入的 <code>newValue</code> 之后再发生了改变都不会影响到属性值</strong>。</li>
</ul>
</li>
<li><p>判断要设置的属性的标识符是否需要进行 <code>mutableCopy</code> 操作</p>
<ul>
<li>如果需要，则对传进来的 <code>newValue</code> 也就是要设置的属性值发送 <code>mutableCopyWithZone</code> 消息</li>
</ul>
</li>
<li><p>如果要设置的属性既不执行 <code>copy</code> 也不执行 <code>mutableCopy</code>，那么就先判断要设置的值是否相等</p>
<ul>
<li>如果相等，说明新值和旧值相等，直接返回</li>
<li>如果不等，则对新值发送 <code>objc_retain</code> 消息进行 <code>retain</code> 操作，然后将返回值覆写到 <code>newValue</code> 上</li>
</ul>
</li>
<li><p>接着判断属性赋值操作是否是原子操作</p>
<ul>
<li>如果不是原子操作，则将属性赋值给临时变量 <code>oldValue</code>，然后将新值赋上去</li>
<li>如果是原子操作，则对赋值操作进行加锁操作保证数据完整性，防止赋值过程中数据发生变化，这也就印证了 <code>atomic</code> 是保证属性的读写操作线程安全</li>
<li><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014511.jpg" alt="img"></li>
</ul>
</li>
<li><p>最后对 <code>oldValue</code> 也就是旧值进行内存的释放</p>
</li>
</ul>
<blockquote>
<p>PS: <strong>并不是所有属性的自动 <code>setter</code> 都会来到 <code>objc_setProperty</code></strong><br><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014515.jpg" alt="img"><br>那么，具体是哪些情况下的属性才会来到这里呢？我们不妨做一下简单的测试</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// JHTest.h</span><br><span class="line">@interface JHTest</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *arrayNonatomicAndStrong;</span><br><span class="line">@property (nonatomic, copy)   NSMutableArray *arrayNonatomicAndCopy;</span><br><span class="line">@property (nonatomic, strong) NSString *stringNonatomicAndStrong;</span><br><span class="line">@property (nonatomic, copy)   NSString *stringNonatomicAndCopy;</span><br><span class="line">@property (nonatomic, assign) int ageNonatomicAndAssign;</span><br><span class="line">@property (nonatomic, weak) NSString *stringNonatomicAndWeak;</span><br><span class="line">@property (nonatomic, retain) NSString *stringNonatomicAndRetain;</span><br><span class="line"></span><br><span class="line">@property (atomic, strong) NSMutableArray *arrayAtomicAndStrong;</span><br><span class="line">@property (atomic, copy)   NSMutableArray *arrayAtomicAndCopy;</span><br><span class="line">@property (atomic, strong) NSString *stringAtomicAndStrong;</span><br><span class="line">@property (atomic, copy)   NSString *stringAtomicAndCopy;</span><br><span class="line">@property (atomic, assign) int ageAtomicAndAssign;</span><br><span class="line">@property (atomic, weak) NSString *stringAtomicAndWeak;</span><br><span class="line">@property (atomic, retain) NSString *stringAtomicAndRetain;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// main.m</span><br><span class="line">JHTest *test = [[JHTest alloc] init];</span><br><span class="line">NSMutableArray *testMutableArray = @[].mutableCopy;</span><br><span class="line">        </span><br><span class="line">test.arrayNonatomicAndStrong = testMutableArray;</span><br><span class="line">test.arrayNonatomicAndCopy = testMutableArray;</span><br><span class="line">test.stringNonatomicAndStrong = @&quot;呵呵哒&quot;;</span><br><span class="line">test.stringNonatomicAndCopy = @&quot;呵呵哒&quot;;</span><br><span class="line">test.ageNonatomicAndAssign = 18;</span><br><span class="line">test.stringNonatomicAndWeak = @&quot;呵呵哒&quot;;  </span><br><span class="line">test.stringNonatomicAndRetain = @&quot;呵呵哒&quot;; </span><br><span class="line"></span><br><span class="line">test.arrayAtomicAndStrong = testMutableArray;</span><br><span class="line">test.arrayAtomicAndCopy = testMutableArray;</span><br><span class="line">test.stringAtomicAndStrong = @&quot;呵呵哒&quot;;</span><br><span class="line">test.stringAtomicAndCopy = @&quot;呵呵哒&quot;;</span><br><span class="line">test.ageAtomicAndAssign = 18; </span><br><span class="line">test.stringAtomicAndWeak = @&quot;呵呵哒&quot;;  </span><br><span class="line">test.stringAtomicAndRetain = @&quot;呵呵哒&quot;;</span><br></pre></td></tr></table></figure>

<p>我们通过断点调试，每执行到一个属性的时候，看断点是否会来到 <code>reallySetProperty</code>，测试结果如下:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>是否进入<code>reallySetProperty</code></th>
</tr>
</thead>
<tbody><tr>
<td>arrayNonatomicAndStrong</td>
<td>否</td>
</tr>
<tr>
<td>arrayNonatomicAndCopy</td>
<td>是</td>
</tr>
<tr>
<td>stringNonatomicAndStrong</td>
<td>否</td>
</tr>
<tr>
<td>stringNonatomicAndCopy</td>
<td>是</td>
</tr>
<tr>
<td>ageNonatomicAndAssign</td>
<td>否</td>
</tr>
<tr>
<td>stringNonatomicAndWeak</td>
<td>否</td>
</tr>
<tr>
<td>stringNonatomicAndRetain</td>
<td>否</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>属性</th>
<th>是否进入<code>reallySetProperty</code></th>
</tr>
</thead>
<tbody><tr>
<td>arrayAtomicAndStrong</td>
<td>是</td>
</tr>
<tr>
<td>arrayAtomicAndCopy</td>
<td>是</td>
</tr>
<tr>
<td>stringAtomicAndStrong</td>
<td>是</td>
</tr>
<tr>
<td>stringAtomicAndCopy</td>
<td>是</td>
</tr>
<tr>
<td>ageAtomicAndAssign</td>
<td>否</td>
</tr>
<tr>
<td>stringAtomicAndWeak</td>
<td>否</td>
</tr>
<tr>
<td>stringAtomicAndRetain</td>
<td>是</td>
</tr>
</tbody></table>
<p>从这两组测试结果不难看出，因为 <code>reallySetProperty</code> 内部实际上进行了原子性的写操作以及 <code>copy</code> 或 <code>mutableCopy</code> 的操作和 <code>retain</code> 操作，而对于属性标识符为 <code>nonatomic</code> 并且非 <code>copy</code> 的属性来说，其实并不需要进行原子操作以及 <code>copy</code> 或 <code>mutableCopy</code> 操作。<br>我们前面所展示的属性标识符对应作用的内容在这里也印证了只有当属性需要进行 <code>copy</code> 或 <code>mutableCopy</code> 操作或原子操作时或 <code>retain</code> 操作才会被编译器优化来到 <code>objc_setProperty_xxx =&gt; reallySetProperty</code> 的流程。换句话说，在 <code>Clang</code> 编译的时候，编译器肯定会对属性进行判断，对有需要的属性才触发这一流程。</p>
<p>我们用一个表格来总结：</p>
<table>
<thead>
<tr>
<th>底层方法</th>
<th>对应属性标识符</th>
</tr>
</thead>
<tbody><tr>
<td>objc_setProperty_nonatomic_copy</td>
<td>nonatomic + copy</td>
</tr>
<tr>
<td>objc_setProperty_atomic_copy</td>
<td>atomic + copy</td>
</tr>
<tr>
<td>objc_setProperty_atomic</td>
<td>atomic + retain/strong</td>
</tr>
</tbody></table>
<hr>
<p>我们分析完 <code>reallySetProperty</code> 后不禁有一个疑问，那就是系统是在哪一步调用了 <code>objc_setProperty_xxx</code> 之类的方法呢？答案就是 <code>LLVM</code>。我们可以在 <code>LLVM</code> 的源码中进行搜索关键字 <code>objc_setProperty</code>：</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014519.jpg" alt="img"></p>
<p>我们可以看到在 <code>clang</code> 编译器前端的 <code>RewriteModernObjC</code> 命名空间下的 <code>RewritePropertyImplDecl</code> 方法中：</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014523.jpg" alt="img"></p>
<p>然后我们在 <code>CodeGen</code> 目录下的匿名命名空间下的 <code>ObjcCommonTypesHelper</code> 的 <code>getOptimizedSetPropertyFn</code> 处可以看到以下代码：</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014527.jpg" alt="img"></p>
<p>我们接着以 <code>getOptimizedSetPropertyFn</code> 为关键字来搜索：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">llvm::<span class="function">FunctionCallee <span class="title">GetOptimizedPropertySetFunction</span><span class="params">(<span class="keyword">bool</span> atomic,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">bool</span> copy)</span> override </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ObjCTypes.getOptimizedSetPropertyFn(atomic, copy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们搜索 <code>GetOptimizedPropertySetFunction</code>：</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014536.jpg" alt="img"></p>
<p>关于 <code>LLVM</code> 这块我们先探索到这里，接下来让我们回顾一下 <code>KVC</code> 常用的几种使用场景。</p>
<h1 id="二、深入-KVC"><a href="#二、深入-KVC" class="headerlink" title="二、深入 KVC"></a>二、深入 KVC</h1><h2 id="2-1-访问对象属性"><a href="#2-1-访问对象属性" class="headerlink" title="2.1 访问对象属性"></a>2.1 访问对象属性</h2><ol>
<li>通过 <code>valueForKey:</code> 和 <code>setValue:ForKey:</code> 来<strong>间接的</strong>获取和设置属性值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JHPerson *person = [[JHPerson alloc] init];</span><br><span class="line">[person setValue:@&quot;leejunhui&quot; forKey:@&quot;name&quot;];</span><br><span class="line">NSLog(@&quot;person 的姓名为: %@&quot;, [person valueForKey:@&quot;name&quot;]);</span><br><span class="line"></span><br><span class="line">// 打印如下</span><br><span class="line">person 的姓名为: leejunhui</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p><code>valueForKey</code>: - Returns the value of a property named by the key parameter. If the property named by the key cannot be found according to the rules described in <strong>Accessor Search Patterns</strong>, then the object sends itself a valueForUndefinedKey: message. The default implementation of valueForUndefinedKey: raises an NSUndefinedKeyException, but subclasses may override this behavior and handle the situation more gracefully.<br>【译】<code>valueForKey</code>: 返回由 <code>key</code> 参数命名的属性的值。如果根据<strong>访问者搜索模式</strong>中描述的规则找不到由 <code>key</code> 命名的属性，则该对象将向自身发送 <code>valueForUndefinedKey:</code> 消息。<code>valueForUndefinedKey:</code>的默认实现会抛出 <code>NSUndefinedKeyException</code> 异常，但是子类可以重写此行为并更优雅地处理这种情况。</p>
</li>
<li><p><code>setValue:forKey:</code>: Sets the value of the specified key relative to the object receiving the message to the given value. The default implementation of setValue:forKey: automatically unwraps NSNumber and NSValue objects that represent scalars and structs and assigns them to the property. See Representing Non-Object Values for details on the wrapping and unwrapping semantics.<br>If the specified key corresponds to a property that the object receiving the setter call does not have, the object sends itself a setValue:forUndefinedKey: message. The default implementation of setValue:forUndefinedKey: raises an NSUndefinedKeyException. However, subclasses may override this method to handle the request in a custom manner.<br>【译】<code>setValue:forKey:</code>: 将该消息接收者的指定 <code>key</code> 的值设置为给定值。默认实现会自动把表示标量和结构体的 <code>NSNumber</code> 和 <code>NSValue</code> 对象解包然后赋值给属性。如果指定 <code>key</code> 所对应的属性没有对应的 <code>setter</code> 实现，则该对象将向自身发送 <code>setValue:forUndefinedKey:</code> 消息，而该消息的默认实现会抛出一个 <code>NSUndefinedKeyException</code> 的异常。但是子类可以重写此方法以自定义方式处理请求。</p>
</li>
</ul>
</blockquote>
<p>2.<code>valueForKeyPath:</code> 和 <code>setValue:ForKeyPath:</code><br><strong>Storyboard 或 xib 中使用 KVC</strong></p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014545.jpg" alt="img"></p>
<p>如上图所示，<code>Storyboard</code> 中的一个视图的属性菜单可以设置该视图的 <code>Key Path</code> ，这就引出了基于<strong>路由</strong>的另外一种 <code>KVC</code> 方式，那就是 <code>valueForKeyPath:</code> 和 <code>setValue:ForKeyPath:</code></p>
<blockquote>
<p>A key path is a string of dot-separated keys used to specify a sequence of object properties to traverse. The property of the first key in the sequence is relative to the receiver, and each subsequent key is evaluated relative to the value of the previous property. Key paths are useful for drilling down into a hierarchy of objects with a single method call.<br>【译】<code>keypath</code> 是一个以点分隔开来的字符串，表示了要遍历的对象属性序列。序列中第一个 <code>key</code> 相对于接受者，而后续的每个 <code>key</code> 都与前一级 <code>key</code> 相关联。<code>keypath</code> 对于单个方法调用来深入对象内部结构来说很有用。</p>
</blockquote>
<p>通过 <code>layer.cornerRadius</code> 这个 <code>Key Path</code>，实现了对左侧 <code>View</code> 的 <code>layer</code> 属性的 <code>cornerRadius</code> 属性的访问。</p>
<blockquote>
<ul>
<li><code>valueForKeyPath:</code> - Returns the value for the specified key path relative to the receiver. Any object in the key path sequence that is not key-value coding compliant for a particular key—that is, for which the default implementation of valueForKey: cannot find an accessor method—receives a valueForUndefinedKey: message.</li>
</ul>
<p>【译】<code>valueForKeyPath:</code> : 返回相对于接受者的指定 <code>key path</code> 上的值。<code>key path</code> 路径序列中不符合特定键的键值编码的任何对象（即 <code>valueForKey:</code> 的默认实现无法找到访问器方法的对象）都会接收到 <code>valueForUndefinedKey:</code> 消息。</p>
<ul>
<li><code>setValue:forKeyPath:</code> - Sets the given value at the specified key path relative to the receiver. Any object in the key path sequence that is not key-value coding compliant for a particular key receives a setValue:forUndefinedKey: message.</li>
</ul>
<p>【译】<code>setValue:forKeyPath:</code>: 将该消息接收者的指定 <code>key path</code> 的值设置为给定值。<code>key path</code> 路径序列中不符合特定键的键值编码的任何对象都将收到<code>setValue:forUndefinedKey:</code> 消息</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// JHPerson.h</span><br><span class="line">@property (nonatomic, strong) JHAccount *account;</span><br><span class="line"></span><br><span class="line">// JHAccount.h</span><br><span class="line">@property (nonatomic, copy) NSString *balance;</span><br><span class="line"></span><br><span class="line">// main.m</span><br><span class="line">person.account = [[JHAccount alloc] init];</span><br><span class="line">[person setValue:@&quot;666&quot; forKeyPath:@&quot;account.balance&quot;];</span><br><span class="line">NSLog(@&quot;person 的账户余额为: %@&quot;, [person valueForKeyPath:@&quot;account.balance&quot;]);</span><br><span class="line"></span><br><span class="line">// 打印输出</span><br><span class="line">person 的账户余额为: 666</span><br></pre></td></tr></table></figure>

<p>3.<code>dictionaryWithValuesForKeys:</code> 和 <code>setValuesForKeysWithDictionary:</code></p>
<blockquote>
<ul>
<li><code>dictionaryWithValuesForKeys:</code> - Returns the values for an array of keys relative to the receiver. The method calls valueForKey: for each key in the array. The returned NSDictionary contains values for all the keys in the array.</li>
</ul>
<p>【译】返回相对于接收者的 <code>key</code> 数组的值。该方法会为数组中的每个 <code>key</code> 调用<code>valueForKey:</code>。 返回的 <code>NSDictionary</code> 包含数组中所有键的值。</p>
<ul>
<li><code>setValuesForKeysWithDictionary:</code> - Sets the properties of the receiver with the values in the specified dictionary, using the dictionary keys to identify the properties. The default implementation invokes setValue:forKey: for each key-value pair, substituting nil for NSNull objects as required.</li>
</ul>
<p>【译】使用字典键标识属性，然后使用字典中的对应值来设置该消息接收者的属性值。默认实现会对每一个键值对调用 <code>setValue:forKey:</code>。设置时需要将 <code>nil</code> 替换成 <code>NSNull</code>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[person setValuesForKeysWithDictionary:@&#123;@&quot;name&quot;: @&quot;junhui&quot;, @&quot;age&quot;: @(18)&#125;];</span><br><span class="line">NSLog(@&quot;%@&quot;, [person dictionaryWithValuesForKeys:@[@&quot;name&quot;, @&quot;age&quot;]]);       </span><br><span class="line">        </span><br><span class="line"> // 打印输出</span><br><span class="line">&#123;</span><br><span class="line">    age = 18;</span><br><span class="line">    name = junhui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Collection objects, such as NSArray, NSSet, and NSDictionary, can’t contain nil as a value. Instead, you represent nil values using the NSNull object. NSNull provides a single instance that represents the nil value for object properties. The default implementations of dictionaryWithValuesForKeys: and the related setValuesForKeysWithDictionary: translate between NSNull (in the dictionary parameter) and nil (in the stored property) automatically.<br>集合对象（例如 <code>NSArray</code>，<code>NSSet</code> 和 <code>NSDictionary</code>）不能包含 <code>nil</code> 作为值。 而是使用 <code>NSNull</code> 对象表示 <code>nil</code> 值。<code>NSNull</code> 提供了单个实例表示对象属性的nil值。<code>dictionaryWithValuesForKeys:</code> 和 <code>setValuesForKeysWithDictionary:</code> 的默认实现会自动在 <code>NSNull</code>（在 <code>dictionary</code> 参数中）和 <code>nil</code>（在存储的属性中）之间转换。<br><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014549.jpg" alt="img"></p>
</blockquote>
<h2 id="2-2-访问集合属性"><a href="#2-2-访问集合属性" class="headerlink" title="2.2 访问集合属性"></a>2.2 访问集合属性</h2><p>我们先看下面这样的一份代码，首先给 <code>JHPerson</code> 类增加一个属性 <code>array</code>，类型为不可变数组，然后修改这个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// JHPerson.h</span><br><span class="line">@property (nonatomic, strong) NSArray *array;</span><br><span class="line"></span><br><span class="line">// main.m</span><br><span class="line">person.array = @[@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;];</span><br><span class="line">NSArray *tempArray = @[@&quot;0&quot;, @&quot;1&quot;, @&quot;2&quot;];</span><br><span class="line">[person setValue:tempArray forKey:@&quot;array&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;, [person valueForKeyPath:@&quot;array&quot;]);        </span><br><span class="line"></span><br><span class="line">// 打印输出</span><br><span class="line">(</span><br><span class="line">    0,</span><br><span class="line">    1,</span><br><span class="line">    2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>虽然这种方式能达到效果，但其实还有一种更好的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// main.m</span><br><span class="line">NSMutableArray *mutableArray = [person mutableArrayValueForKey:@&quot;array&quot;];</span><br><span class="line">mutableArray[0] = @&quot;-1&quot;;</span><br><span class="line">NSLog(@&quot;%@&quot;, [person valueForKeyPath:@&quot;array&quot;]);</span><br><span class="line"></span><br><span class="line">// 打印输出</span><br><span class="line"> (</span><br><span class="line">    &quot;-1&quot;,</span><br><span class="line">    1,</span><br><span class="line">    2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里我们用到了一个叫做 <code>mutableArrayValueForKey:</code> 的实例方法，这个方法会通过传入的 <code>key</code> 返回对应属性的一个可变数组的代理对象。</p>
<p>其实对集合对象来说，我们使用上一节的各种读取和设置方法都可以，但是对于操作集合对象内部的元素来说，更高效的方式是使用 <code>KVC</code> 提供的<strong>可变代理方法</strong>。<code>KVC</code> 为我们提供了三种不同的可变代理方法：</p>
<ul>
<li><code>mutableArrayValueForKey:</code> 和 <code>mutableArrayValueForKeyPath:</code><ul>
<li>These return a proxy object that behaves like an NSMutableArray object.</li>
<li>【译】返回的代理对象表现为一个 <code>NSMutableArray</code> 对象</li>
</ul>
</li>
<li><code>mutableSetValueForKey:</code> 和 <code>mutableSetValueForKeyPath:</code><ul>
<li>These return a proxy object that behaves like an NSMutableSet object.</li>
<li>【译】返回的代理对象表现为一个 <code>NSMutableSet</code> 对象</li>
</ul>
</li>
<li><code>mutableOrderedSetValueForKey:</code> and <code>mutableOrderedSetValueForKeyPath:</code><ul>
<li>These return a proxy object that behaves like an NSMutableOrderedSet object.</li>
<li>【译】返回的代理对象表现为一个 <code>NSMutableOrderedSet</code> 对象</li>
</ul>
</li>
</ul>
<h2 id="2-3-集合运算符"><a href="#2-3-集合运算符" class="headerlink" title="2.3 集合运算符"></a>2.3 集合运算符</h2><p>在使用 <code>valueForKeyPath:</code> 的时候，可以使用集合运算符来实现一些高效的运算操作。</p>
<blockquote>
<p>A collection operator is one of a small list of keywords preceded by an at sign (@) that specifies an operation that the getter should perform to manipulate the data in some way before returning it.<br>【译】一个集合运算符是一小部分关键字其后带有一个at符号（@），该符号指定 <code>getter</code> 在返回数据之前以某种方式处理数据应执行的操作。</p>
</blockquote>
<p>集合运算符的结构如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015436.jpg" alt="img"></p>
<p>简单解释一下:</p>
<ul>
<li>left key path: 指向的要进行运算的集合，如果是直接给集合发送的 <code>valueForKeyPath:</code> 消息，<code>left key path</code> 可以省略</li>
<li>right key path: 表示的是对集合中具体哪个属性进行运算操作，除了 <code>@count</code> 运算符外，所有的集合运算符的 <code>right key path</code> 都不能省略</li>
</ul>
<p>而集合运算符可以分为三大类：</p>
<ul>
<li>聚合操作符<ul>
<li><code>@avg</code>: 返回操作对象指定属性的<strong>平均值</strong></li>
<li><code>@count</code>: 返回操作对象指定<strong>属性的个数</strong></li>
<li><code>@max</code>: 返回操作对象指定属性的<strong>最大值</strong></li>
<li><code>@min</code>: 返回操作对象指定属性的<strong>最小值</strong></li>
<li><code>@sum</code>: 返回操作对象指定<strong>属性值之和</strong></li>
</ul>
</li>
<li>数组操作符<ul>
<li><code>@distinctUnionOfObjects</code>: 返回操作对象<strong>指定属性的集合–去重</strong> </li>
<li><code>@unionOfObjects</code>: 返回操作对象<strong>指定属性的集合</strong></li>
</ul>
</li>
<li>嵌套操作符<ul>
<li><code>@distinctUnionOfArrays</code>: 返回操作对象(嵌套集合)<strong>指定属性的集合–去重</strong>，返回的是 <code>NSArray</code></li>
<li><code>@unionOfArrays</code>: 返回操作对象(集合)<strong>指定属性的集合</strong></li>
<li><code>@distinctUnionOfSets</code>: 返回操作对象(嵌套集合)<strong>指定属性的集合–去重</strong>，返回的是 <code>NSSet</code></li>
</ul>
</li>
</ul>
<h2 id="2-4-访问非对象属性"><a href="#2-4-访问非对象属性" class="headerlink" title="2.4 访问非对象属性"></a>2.4 访问非对象属性</h2><p>非对象属性分为两类，一类是基本数据类型也就是所谓的<strong>标量</strong>(scalar)，一类是结构体(struct)。</p>
<h3 id="2-4-1-访问标量属性"><a href="#2-4-1-访问标量属性" class="headerlink" title="2.4.1 访问标量属性"></a>2.4.1 访问标量属性</h3><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015453.jpg" alt="img"></p>
<p>如图所示，常用的基本数据类型需要在设置属性的时候包装成 <code>NSNumber</code> 类型，然后在读取值的时候使用各自对应的读取方法，如 <code>double</code> 类型的标量读取的时候使用 <code>doubleValue</code></p>
<h3 id="2-4-2-访问结构体"><a href="#2-4-2-访问结构体" class="headerlink" title="2.4.2 访问结构体"></a>2.4.2 访问结构体</h3><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015441.jpg" alt="img"></p>
<p>结构体的话就需要转换成 <code>NSValue</code> 类型，如上图所示。<br>除了 <code>NSPoint</code>, <code>NSRange</code>, <code>NSRect</code>, 和 <code>NSSize</code>，对于自定义的结构体，也需要进行 <code>NSValue</code> 的转换操作，举个🌰:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    float x, y, z;</span><br><span class="line">&#125; ThreeFloats;</span><br><span class="line"> </span><br><span class="line">@interface MyClass</span><br><span class="line">@property (nonatomic) ThreeFloats threeFloats;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 获取结构体属性</span><br><span class="line">NSValue* result = [myClass valueForKey:@&quot;threeFloats&quot;];</span><br><span class="line"></span><br><span class="line">// 设置结构体属性</span><br><span class="line">ThreeFloats floats = &#123;1., 2., 3.&#125;;</span><br><span class="line">NSValue* value = [NSValue valueWithBytes:&amp;floats objCType:@encode(ThreeFloats)];</span><br><span class="line">[myClass setValue:value forKey:@&quot;threeFloats&quot;];</span><br><span class="line"></span><br><span class="line">// 提取结构体属性</span><br><span class="line">ThreeFloats th;</span><br><span class="line">[reslut getValue:&amp;th];</span><br></pre></td></tr></table></figure>

<h2 id="2-5-属性验证"><a href="#2-5-属性验证" class="headerlink" title="2.5 属性验证"></a>2.5 属性验证</h2><p><code>KVC</code> 支持属性验证，而这一特性是通过<code>validateValue:forKey:error:</code> (或<code>validateValue:forKeyPath:error:</code>) 方法来实现的。这个验证方法的默认实现是去收到这个验证消息的对象(或<code>keyPath</code>中最后的对象)中根据 <code>key</code> 查找是否有对应的 <code>validate&lt;Key&gt;:error:</code> 方法实现，如果没有，验证默认成功，返回 <code>YES</code>。<br>而由于 <code>validate&lt;Key&gt;:error:</code> 方法通过引用接收值和错误参数，所以会有以下三种结果：</p>
<ul>
<li>验证成功，返回 <code>YES</code>，对属性值不做任何改动。</li>
<li>验证失败，返回 <code>NO</code>，但对属性值不做改动，如果调用者提供了 <code>NSError</code> 的话，就把错误引用设置为指示错误原因的NSError对象。</li>
<li>验证失败，返回 <code>YES</code>，创建一个新的，有效的属性值作为替代。在返回之前，该方法将值引用修改为指向新值对象。 进行修改时，即使值对象是可变的，该方法也总是创建一个新对象，而不是修改旧对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person* person = [[Person alloc] init];</span><br><span class="line">NSError* error;</span><br><span class="line">NSString* name = @&quot;John&quot;;</span><br><span class="line">if (![person validateValue:&amp;name forKey:@&quot;name&quot; error:&amp;error]) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么是否系统会自动进行属性验证呢？<br>通常，<code>KVC</code> 或其默认实现均未定义任何机制来自动的执行属性验证，也就是说需要在适合你的应用的时候自己提供属性验证方法。<br>某些其他 <code>Cocoa</code> 技术在某些情况下会自动执行验证。 例如，保存 <code>managed object context</code> 时，<code>Core Data</code>会自动执行验证。另外，在 <code>macOS</code> 中，<code>Cocoa Binding</code>允许你指定验证应自动进行。</p>
<h2 id="2-6-KVC-取值和设值原理"><a href="#2-6-KVC-取值和设值原理" class="headerlink" title="2.6 KVC 取值和设值原理"></a>2.6 <code>KVC</code> 取值和设值原理</h2><h3 id="2-6-1-基本-getter"><a href="#2-6-1-基本-getter" class="headerlink" title="2.6.1 基本 getter"></a>2.6.1 基本 <code>getter</code></h3><p><code>valueForKey:</code> 方法会在调用者传入 <code>key</code> 之后会在对象中按下列的步骤进行模式搜索：</p>
<ul>
<li>1.以 <code>get&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code> 以及 <code>_&lt;key&gt;</code> 的顺序查找对象中是否有对应的方法。<ul>
<li>如果找到了，将方法返回值带上跳转到第 5 步</li>
<li>如果没有找到，跳转到第 2 步</li>
</ul>
</li>
<li>2.查找是否有 <code>countOf&lt;Key&gt;</code> 和 <code>objectIn&lt;Key&gt;AtIndex:</code> 方法(对应于 <code>NSArray</code> 类定义的原始方法)以及 <code>&lt;key&gt;AtIndexes:</code> 方法(对应于 <code>NSArray</code> 方法 <code>objectsAtIndexes:</code>)<ul>
<li>如果找到其中的第一个(<code>countOf&lt;Key&gt;</code>)，再找到其他两个中的至少一个，则创建一个响应所有 <code>NSArray</code> 方法的代理集合对象，并返回该对象。(翻译过来就是要么是 <code>countOf&lt;Key&gt;</code> + <code>objectIn&lt;Key&gt;AtIndex:</code>，要么是 <code>countOf&lt;Key&gt;</code> + <code>&lt;key&gt;AtIndexes:</code>，要么是 <code>countOf&lt;Key&gt;</code> + <code>objectIn&lt;Key&gt;AtIndex:</code> + <code>&lt;key&gt;AtIndexes:</code>)</li>
<li>如果没有找到，跳转到第 3 步</li>
</ul>
</li>
<li>3.查找名为 <code>countOf&lt;Key&gt;</code>，<code>enumeratorOf&lt;Key&gt;</code> 和 <code>memberOf&lt;Key&gt;</code> 这三个方法(对应于NSSet类定义的原始方法）<ul>
<li>如果找到这三个方法，则创建一个响应所有 <code>NSSet</code> 方法的代理集合对象，并返回该对象</li>
<li>如果没有找到，跳转到第 4 步</li>
</ul>
</li>
<li>4.判断类方法 <code>accessInstanceVariablesDirectly</code> 结果<ul>
<li>如果返回 <code>YES</code>，则以 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code> 的顺序查找成员变量，如果找到了，将成员变量带上跳转到第 5 步，如果没有找到则跳转到第 6 步</li>
<li>如果返回 <code>NO</code>，跳转到第 6 步</li>
</ul>
</li>
<li>5.判断取出的属性值<ul>
<li>如果属性值是对象，直接返回</li>
<li>如果属性值不是对象，但是可以转化为 <code>NSNumber</code> 类型，则将属性值转化为 <code>NSNumber</code> 类型返回</li>
<li>如果属性值不是对象，也不能转化为 <code>NSNumber</code> 类型，则将属性值转化为 <code>NSValue</code> 类型返回</li>
</ul>
</li>
<li>6.调用 <code>valueForUndefinedKey:</code>。 默认情况下，这会引发一个异常，但是 <code>NSObject</code> 的子类可以提供特定于 <code>key</code> 的行为。</li>
</ul>
<p>这里可以用简单的流程图来表示</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015445.jpg" alt="img"></p>
<h3 id="2-6-2-基本-setter"><a href="#2-6-2-基本-setter" class="headerlink" title="2.6.2 基本 setter"></a>2.6.2 基本 <code>setter</code></h3><p><code>setValue:forKey:</code> 方法默认实现会在调用者传入 <code>key</code> 和 <code>value</code>(如果是非对象类型，则指的是解包之后的值) 之后会在对象中按下列的步骤进行模式搜索：</p>
<ul>
<li>1.以 <code>set&lt;Key&gt;:</code>, <code>_set&lt;Key&gt;</code> 的顺序在对象中查找是否有这样的方法，如果找到了，则把属性值传给方法来完成属性值的设置。</li>
<li>2.判断类方法 <code>accessInstanceVariablesDirectly</code> 结果<ul>
<li>如果返回 <code>YES</code>，则以 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code> 的顺序查找成员变量，如果找到了，则把属性值传给方法来完成属性值的设置。</li>
<li>如果返回 <code>NO</code>，跳转到第 3 步</li>
</ul>
</li>
<li>3.调用 <code>setValue：forUndefinedKey:</code>。 默认情况下，这会引发一个异常，但是<code>NSObject</code> 的子类可以提供特定于 <code>key</code> 的行为。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015449.jpg" alt="img"></p>
<h1 id="三、自定义-KVC"><a href="#三、自定义-KVC" class="headerlink" title="三、自定义 KVC"></a>三、自定义 <code>KVC</code></h1><p>了解了 <code>KVC</code> 底层原理之后，我们是否可以自己来实现一下 <code>KVC</code> 呢？这里我们要先明确一下 <code>iOS</code> 中对于属性的分类：</p>
<ul>
<li><strong>Attributes</strong>: 简单属性，比如基本数据类型，字符串和布尔值，而诸如 <code>NSNumber</code> 和其它一些不可变类型比如 <code>NSColor</code> 也可以被认为是简单属性</li>
<li><strong>To-one relationships</strong>: 这些是具有自己属性的可变对象属性。即对象的属性可以更改，而无需更改对象本身。例如，一个 <code>Account</code> 对象可能具有一个 <code>owner</code> 属性，该属性是 <code>Person</code> 对象的实例，而 <code>Person</code> 对象本身具有 <code>address</code> 属性。<code>owner</code> 的地址可以更改，但却而无需更改 <code>Account</code> 持有的 <code>owner</code> 属性。也就是说 <code>Account</code> 的 <code>owner</code> 属性未被更改，只是 <code>address</code> 被更改了。</li>
<li><strong>To-many relationships</strong>: 这些是集合对象属性。尽管也可以使用自定义集合类，但是通常使用 <code>NSArray</code> 或 <code>NSSet</code> 的实例来持有此集合。</li>
</ul>
<p>我们通过代码来演示上述三种类型的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Person.h</span><br><span class="line">@interface Person</span><br><span class="line">@property (nonatomic, copy) NSString *name; // Attributes </span><br><span class="line">@property (nonatomic, strong) Account *account; // To-one relationships</span><br><span class="line">@property (nonatomic, strong) NSArray *subjects; // To-many relationships</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Account.h</span><br><span class="line">@interface Account</span><br><span class="line">@property (nonatomic, assign) NSInteger balance; </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>我们实现聚焦于最常用的 <code>valueForKey:</code> 方法的声明，我们发现该方法是位于 <code>NSKeyValueCoding</code> 这个分类里面的，这种设计模式可以实现解耦的功能。</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015438.jpg" alt="img"></p>
<p>打个比方，我们在实际开发中会在 <code>AppDelegate</code> 源文件里面去做各种诸如第三方组件的注册和初始化，时间久了，随着项目功能不断迭代，堆积在 <code>AppDelegate</code> 中的代码就会越来越多，导致难以维护。这个时候如果采取把这些初始化和注册逻辑放在不同的 <code>AppDelegate</code> 的分类中就可以大大减轻 <code>AppDelegate</code> 自身维护的成本，同时，也让整个业务流更加清晰。</p>
<h2 id="3-1-自定义设值"><a href="#3-1-自定义设值" class="headerlink" title="3.1 自定义设值"></a>3.1 自定义设值</h2><p>那么，我们如果要自定义 <code>KVC</code> 实现的话，也应该按照这种设计模式来操作。我们直接新建一个 <code>NSObject</code> 的分类，然后我们先着眼于 <code>setValue:ForKey:</code> 方法，为了避免与系统自带的 <code>KVC</code> 方法冲突，我们加一个前缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// NSObject+JHKVC.h</span><br><span class="line">@interface NSObject (JHKVC)</span><br><span class="line">- (void)jh_setValue:(nullable id)value forKey:(NSString *)key;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>然后要实现这个方法，根据我们前面探索的 <code>setValue:ForKey:</code> 流程，我们判断一下传入的 <code>key</code> 是否为空:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 1.判断 key</span><br><span class="line">if (key == nil  || key.length == 0) return;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>key</code> 为 <code>nil</code> 或者 <code>key</code> 长度为 0 ，直接退出。</li>
</ul>
<p>接着我们要判断是否存在 <code>setKey</code>，<code>_setKey</code>，这里有个小插曲，因为苹果官方文档上只说了这两种方法，但其实，<code>iOS</code> 底层还处理了 <code>setIsKey</code>，这是因为 <code>key</code> 可以被重写成 <code>isKey</code> 的形式，所以这里我们就再加上对 <code>setIsKey</code> 的判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 2.判断 setKey,_setKey,setIsKey 是否存在，如果存在，直接调用相应的方法来设置属性值</span><br><span class="line">NSString *Key = key.capitalizedString;</span><br><span class="line">NSString *setKey = [NSString stringWithFormat:@&quot;set%@:&quot;,Key];</span><br><span class="line">NSString *_setKey = [NSString stringWithFormat:@&quot;_set%@:&quot;,Key];</span><br><span class="line">NSString *setIsKey = [NSString stringWithFormat:@&quot;setIs%@:&quot;,Key];</span><br><span class="line"></span><br><span class="line">if ([self jh_performSelectorWithMethodName:setKey value:value]) &#123;</span><br><span class="line">    NSLog(@&quot;*********%@**********&quot;,setKey);</span><br><span class="line">    return;</span><br><span class="line">&#125;else if ([self jh_performSelectorWithMethodName:_setKey value:value]) &#123;</span><br><span class="line">    NSLog(@&quot;*********%@**********&quot;,_setKey);</span><br><span class="line">    return;</span><br><span class="line">&#125;else if ([self jh_performSelectorWithMethodName:setIsKey value:value]) &#123;</span><br><span class="line">    NSLog(@&quot;*********%@**********&quot;,setIsKey);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里为了方便，先将 <code>key</code> 进行一下首字母大写化，然后拼接三个不同的 <code>set</code> 方法名，然后判断响应的方法能否实现，如果实现了就直接调用响应的方法来设置属性值</li>
</ul>
<blockquote>
<p>这里先通过 <code>respondsToSelector</code> 来判断当前对象是否能响应传入的方法，如果能响应，则执行方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; - (BOOL)jh_performSelectorWithMethodName:(NSString *)methodName value:(id)value&#123;</span><br><span class="line">&gt;  </span><br><span class="line">&gt;     if ([self respondsToSelector:NSSelectorFromString(methodName)]) &#123;</span><br><span class="line">&gt;         </span><br><span class="line">&gt; #pragma clang diagnostic push</span><br><span class="line">&gt; #pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">&gt;         [self performSelector:NSSelectorFromString(methodName) withObject:value];</span><br><span class="line">&gt; #pragma clang diagnostic pop</span><br><span class="line">&gt;         return YES;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     return NO;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里如果按照系统的 <code>KVC</code> 设值流程，应该还有对 <code>NSArray</code>，<code>NSSet</code> 之类的处理，为了简化，就暂时忽略掉这些流程。我们直接往下面走，下一个流程应该就是判断类方法 <code>accessInstanceVariablesDirectly</code> 了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 3.判断是否能直接读取成员变量</span><br><span class="line">if (![self.class accessInstanceVariablesDirectly] ) &#123;</span><br><span class="line">    @throw [NSException exceptionWithName:@&quot;JHUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;,self] userInfo:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果可以读取成员变量，那么就需要我们按照 <code>_key</code>，<code>_isKey</code>, <code>key</code>, <code>isKey</code> 的顺序去查找了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 4.按照 _key,is_key,key,isKey 顺序查询实例变量</span><br><span class="line">NSMutableArray *mArray = [self getIvarListName];</span><br><span class="line">NSString *_key = [NSString stringWithFormat:@&quot;_%@&quot;,key];</span><br><span class="line">NSString *_isKey = [NSString stringWithFormat:@&quot;_is%@&quot;,Key];</span><br><span class="line">NSString *isKey = [NSString stringWithFormat:@&quot;is%@&quot;,Key];</span><br><span class="line">if ([mArray containsObject:_key]) &#123;</span><br><span class="line">    // 4.2 获取相应的 ivar</span><br><span class="line">   Ivar ivar = class_getInstanceVariable([self class], _key.UTF8String);</span><br><span class="line">    // 4.3 对相应的 ivar 设置值</span><br><span class="line">   object_setIvar(self , ivar, value);</span><br><span class="line">   return;</span><br><span class="line">&#125;else if ([mArray containsObject:_isKey]) &#123;</span><br><span class="line">   Ivar ivar = class_getInstanceVariable([self class], _isKey.UTF8String);</span><br><span class="line">   object_setIvar(self , ivar, value);</span><br><span class="line">   return;</span><br><span class="line">&#125;else if ([mArray containsObject:key]) &#123;</span><br><span class="line">   Ivar ivar = class_getInstanceVariable([self class], key.UTF8String);</span><br><span class="line">   object_setIvar(self , ivar, value);</span><br><span class="line">   return;</span><br><span class="line">&#125;else if ([mArray containsObject:isKey]) &#123;</span><br><span class="line">   Ivar ivar = class_getInstanceVariable([self class], isKey.UTF8String);</span><br><span class="line">   object_setIvar(self , ivar, value);</span><br><span class="line">   return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里要先读取到当前对象上所有的实例变量，然后匹配四种情况</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; - (NSMutableArray *)getIvarListName&#123;</span><br><span class="line">&gt;     // 初始化数组容器</span><br><span class="line">&gt;     NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">&gt;     unsigned int count = 0;</span><br><span class="line">&gt;     // 获取到当前类的成员变量</span><br><span class="line">&gt;     Ivar *ivars = class_copyIvarList([self class], &amp;count);</span><br><span class="line">&gt;     // 遍历所有的成员变量</span><br><span class="line">&gt;     for (int i = 0; i&lt;count; i++) &#123;</span><br><span class="line">&gt;         Ivar ivar = ivars[i];</span><br><span class="line">&gt;         const char *ivarNameChar = ivar_getName(ivar);</span><br><span class="line">&gt;         // 将静态字符串指针转换为 NSString 类型  </span><br><span class="line">&gt;         NSString *ivarName = [NSString stringWithUTF8String:ivarNameChar];</span><br><span class="line">&gt;         NSLog(@&quot;ivarName == %@&quot;,ivarName);</span><br><span class="line">&gt;         [mArray addObject:ivarName];</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     // 释放掉成员变量指针数组</span><br><span class="line">&gt;     free(ivars);</span><br><span class="line">&gt;     return mArray;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里用到了 <code>Runtime</code> 的两个 <code>api</code>，<code>class_copyIvarList</code> 和 <code>ivar_getName</code></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; Ivar  _Nonnull * class_copyIvarList(Class cls, unsigned int *outCount);</span><br><span class="line">&gt; ``` </span><br><span class="line">&gt; 返回类结构中成员变量的指针数组，但是不包括父类中声明的成员变量。该数组包含 `*outCount`指针，后跟一个 `NULL` 终止符。使用完毕后您必须使用 `free()` 释放成员变量的指针数组。如果该类未声明任何实例变量，或者 `cls` 为Nil，则返回 `NULL`，并且 `*outCount` 为 0。</span><br><span class="line">&gt; </span><br><span class="line">&gt; ```Objective-C</span><br><span class="line">&gt; const char * ivar_getName(Ivar v);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>返回成员变量的名称</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 5.如果前面的流程都失败了，则抛出异常</span><br><span class="line">@throw [NSException exceptionWithName:@&quot;JHUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ %@]: setValue:forUndefinedKey:%@.****&quot;,self,NSStringFromSelector(_cmd),key] userInfo:nil];</span><br></pre></td></tr></table></figure>

<ul>
<li>最后抛出 <code>setValue:forUndefinedKey</code> 的异常</li>
</ul>
<p>至此，我们的 <code>setValue:forKey:</code> 流程就结束了，当然，整个内容和系统真正的 <code>KVC</code> 比起来还差得很远，包括线程安全、可变数组之类的都没涉及，不过这不是重点，我们只需要举一反三即可。</p>
<h2 id="3-2-自定义取值"><a href="#3-2-自定义取值" class="headerlink" title="3.2 自定义取值"></a>3.2 自定义取值</h2><p>接着我们需要自定义的是 <code>valueForKey:</code>，我们声明如下的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)jh_valueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure>

<p>然后同样的，根据我们前面探索的 <code>valueForKey:</code> 底层流程，还是要先判断 <code>key</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1.判断 key</span><br><span class="line">if (key == nil  || key.length == 0) &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>key</code> 为 <code>nil</code> 或者 <code>key</code> 长度为 0 ，直接退出。</li>
</ul>
<p>然后就是判断是否有相应的 <code>getter</code> 方法，查找顺序是按照 <code>getKey</code>, <code>key</code>, <code>isKey</code>, <code>_key</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    // 2.判断 getKey,key,isKey,_key 是否存在，如果存在，直接调用相应的方法来返回属性值</span><br><span class="line">    NSString *Key = key.capitalizedString;</span><br><span class="line">    NSString *getKey = [NSString stringWithFormat:@&quot;get%@:&quot;,Key];</span><br><span class="line">    NSString *isKey = [NSString stringWithFormat:@&quot;is%@:&quot;,Key];</span><br><span class="line">    NSString *_key = [NSString stringWithFormat:@&quot;_%@:&quot;,Key];</span><br><span class="line">    </span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">    if ([self respondsToSelector:NSSelectorFromString(getKey)]) &#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(getKey)];</span><br><span class="line">    &#125; else if ([self respondsToSelector:NSSelectorFromString(key)])&#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(key)];</span><br><span class="line">    &#125; else if ([self respondsToSelector:NSSelectorFromString(isKey)])&#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(isKey)];</span><br><span class="line">    &#125; else if ([self respondsToSelector:NSSelectorFromString(_key)])&#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(_key)];</span><br><span class="line">    &#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure>

<p>如果这四种 <code>getter</code> 方法都没有找到，那么同样的就需要读取类方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 3.判断是否能直接读取成员变量</span><br><span class="line">if (![self.class accessInstanceVariablesDirectly] ) &#123;</span><br><span class="line">    @throw [NSException exceptionWithName:@&quot;JHUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;,self] userInfo:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果可以读取成员变量，那么就需要我们按照 <code>_key</code>，<code>_isKey</code>, <code>key</code>, <code>isKey</code> 的顺序去查找了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 4.按照 _key,_iskey,key,isKey 顺序查询实例变量</span><br><span class="line">NSMutableArray *mArray = [self getIvarListName];</span><br><span class="line">_key = [NSString stringWithFormat:@&quot;_%@&quot;,key];</span><br><span class="line">NSString *_isKey = [NSString stringWithFormat:@&quot;_is%@&quot;,Key];</span><br><span class="line">isKey = [NSString stringWithFormat:@&quot;is%@&quot;,Key];</span><br><span class="line">if ([mArray containsObject:_key]) &#123;</span><br><span class="line">    Ivar ivar = class_getInstanceVariable([self class], _key.UTF8String);</span><br><span class="line">    return object_getIvar(self, ivar);;</span><br><span class="line">&#125;else if ([mArray containsObject:_isKey]) &#123;</span><br><span class="line">    Ivar ivar = class_getInstanceVariable([self class], _isKey.UTF8String);</span><br><span class="line">    return object_getIvar(self, ivar);;</span><br><span class="line">&#125;else if ([mArray containsObject:key]) &#123;</span><br><span class="line">    Ivar ivar = class_getInstanceVariable([self class], key.UTF8String);</span><br><span class="line">    return object_getIvar(self, ivar);;</span><br><span class="line">&#125;else if ([mArray containsObject:isKey]) &#123;</span><br><span class="line">    Ivar ivar = class_getInstanceVariable([self class], isKey.UTF8String);</span><br><span class="line">    return object_getIvar(self, ivar);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 5.抛出异常</span><br><span class="line">@throw [NSException exceptionWithName:@&quot;JHUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ %@]: valueForUndefinedKey:%@.****&quot;,self,NSStringFromSelector(_cmd),key] userInfo:nil];</span><br></pre></td></tr></table></figure>

<ul>
<li>最后抛出 <code>valueForUndefinedKey:</code> 的异常</li>
</ul>
<p>取值过程的自定义也结束了，其实这里也有不严谨的地方，比如取得属性值返回的时候需要根据属性值类型来判断是否要转换成 <code>NSNumber</code> 或 <code>NSValue</code>，以及对 <code>NSArray</code> 和 <code>NSSet</code> 类型的判断。</p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p><code>KVC</code> 探索完了，其实我们探索的大部分内容都是基于苹果的官方文档，我们在探索 <code>iOS</code> 底层的时候，文档思维十分重要，有时候说不定在文档的某个角落里就隐藏着追寻的答案。<code>KVC</code> 用起来不难，理解起来也不难，但是这不意味着我们可以轻视它。在 <code>iOS 13</code> 之前，我们可以通过 <code>KVC</code> 去获取和设置系统的私有属性，但从 <code>iOS 13</code> 之后，这种方式被禁用掉了。建议对 <code>KVC</code> 理解还不透彻的读者去多几遍官方文档，相信我，你会有新的收获。最后，我们简单总结一下本文的内容。</p>
<ul>
<li><code>KVC</code> 是一种 <code>NSKeyValueCoding</code> 隐式协议所提供的机制。</li>
<li><code>KVC</code> 通过 <code>valueForKey:</code> 和 <code>valueForKeyPath:</code> 来取值，不考虑集合类型的话具体的取值过程如下:<ul>
<li>以 <code>get&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code>, <code>_&lt;key&gt;</code> 的顺序查找方法</li>
<li>如果找不到方法，则通过类方法 <code>accessInstanceVariablesDirectly</code> 判断是否能读取成员变量来返回属性值</li>
<li>以 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code> 的顺序查找成员变量</li>
</ul>
</li>
<li><code>KVC</code> 通过 <code>setValueForKey:</code> 和 <code>setValueForKeyPath:</code> 来取值，不考虑集合类型的话具体的设置值过程如下:<ul>
<li>以 <code>set&lt;Key&gt;</code>, <code>_set&lt;Key&gt;</code>的顺序查找方法</li>
<li>如果找不到方法，则通过类方法 <code>accessInstanceVariablesDirectly</code> 判断是否能通过成员变量来返回设置值</li>
<li>以 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code> 的顺序查找成员变量</li>
</ul>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="noopener">Apple 开发者文档 - KVC</a></p>
<p><a href="https://www.jianshu.com/p/66b77270e363" target="_blank" rel="noopener">iOS atomic 和 nonatomic 的区别</a></p>
<p><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/MM.html" target="_blank" rel="noopener">Objective-C 内存管理</a></p>
<p><a href="https://juejin.im/post/5c2189dee51d454517589c8b#heading-13" target="_blank" rel="noopener">iOS底层原理总结篇 – 深入理解 KVC\KVO 实现机制</a></p>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode3.jpg" alt="leejunhui wechat" style="width: 200px; max-width: 100%;">
    <div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div>
</div>

      </div>
    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    leejunhui
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://leejunhui.com/2020/02/15/iOS-底层探索-KVC/" title="iOS 底层探索 - KVC">http://leejunhui.com/2020/02/15/iOS-底层探索-KVC/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/Objective-C/" rel="tag"># Objective-C</a>
          
            <a href="/tags/KVC/" rel="tag"># KVC</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/21/iOS-底层探索-类拓展和关联对象/" rel="next" title="iOS 底层探索 - 类拓展和关联对象">
                <i class="fa fa-chevron-left"></i> iOS 底层探索 - 类拓展和关联对象
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/19/iOS-底层探索-KVO/" rel="prev" title="iOS 底层探索 - KVO">
                iOS 底层探索 - KVO <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="leejunhui">
            
              <p class="site-author-name" itemprop="name">leejunhui</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、KVC-初探"><span class="nav-number">1.</span> <span class="nav-text">一、KVC 初探</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-自己实现-getter-和-setter"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 自己实现 getter 和 setter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-编译器自动实现-getter-和-setter"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 编译器自动实现 getter 和 setter</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、深入-KVC"><span class="nav-number">2.</span> <span class="nav-text">二、深入 KVC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-访问对象属性"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 访问对象属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-访问集合属性"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 访问集合属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-集合运算符"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 集合运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-访问非对象属性"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 访问非对象属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-访问标量属性"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.4.1 访问标量属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-访问结构体"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.4.2 访问结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-属性验证"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 属性验证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-KVC-取值和设值原理"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 KVC 取值和设值原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-1-基本-getter"><span class="nav-number">2.6.1.</span> <span class="nav-text">2.6.1 基本 getter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-2-基本-setter"><span class="nav-number">2.6.2.</span> <span class="nav-text">2.6.2 基本 setter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、自定义-KVC"><span class="nav-number">3.</span> <span class="nav-text">三、自定义 KVC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-自定义设值"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 自定义设值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-自定义取值"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 自定义取值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、总结"><span class="nav-number">4.</span> <span class="nav-text">四、总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">5.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leejunhui</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        




  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=66522444";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
