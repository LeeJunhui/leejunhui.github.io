<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS,Objective-C,KVO,">





  <link rel="alternate" href="/atom.xml" title="leejunhui's blog" type="application/atom+xml">






<meta name="description" content="在 Objective-C 和 Cocoa 中，有许多事件之间进行通信的方式，并且每个都有不同程度的形式和耦合:NSNotification &amp;amp; NSNotificationCenter 提供了一个中央枢纽，一个应用的任何部分都可能通知或者被通知应用的其他部分的变化。唯一需要做的是要知道在寻找什么，主要是通知的名字。例如，UIApplicationDidReceiveMemoryWarn">
<meta name="keywords" content="iOS,Objective-C,KVO">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 底层探索 - KVO">
<meta property="og:url" content="http://leejunhui.com/2020/02/19/iOS-底层探索-KVO/index.html">
<meta property="og:site_name" content="leejunhui&#39;s blog">
<meta property="og:description" content="在 Objective-C 和 Cocoa 中，有许多事件之间进行通信的方式，并且每个都有不同程度的形式和耦合:NSNotification &amp;amp; NSNotificationCenter 提供了一个中央枢纽，一个应用的任何部分都可能通知或者被通知应用的其他部分的变化。唯一需要做的是要知道在寻找什么，主要是通知的名字。例如，UIApplicationDidReceiveMemoryWarn">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151907.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151909.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151913.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151911.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151916.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152116.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152126.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152131.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152121.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152142.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152032.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152136.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152148.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152151.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152154.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152159.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152204.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152208.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152208.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152216.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152219.jpg">
<meta property="og:updated_time" content="2020-02-19T07:40:40.308Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS 底层探索 - KVO">
<meta name="twitter:description" content="在 Objective-C 和 Cocoa 中，有许多事件之间进行通信的方式，并且每个都有不同程度的形式和耦合:NSNotification &amp;amp; NSNotificationCenter 提供了一个中央枢纽，一个应用的任何部分都可能通知或者被通知应用的其他部分的变化。唯一需要做的是要知道在寻找什么，主要是通知的名字。例如，UIApplicationDidReceiveMemoryWarn">
<meta name="twitter:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151907.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://leejunhui.com/2020/02/19/iOS-底层探索-KVO/">





  <title>iOS 底层探索 - KVO | leejunhui's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">leejunhui's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://leejunhui.com/2020/02/19/iOS-底层探索-KVO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leejunhui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leejunhui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS 底层探索 - KVO</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-19T15:38:09+08:00">
                2020-02-19
              </time>
            

            

            
          </span>
          
          <span class="post-updated">
            &nbsp; | &nbsp; 更新于
            <time itemprop="dateUpdated" datetime="2020-02-19T15:40:40+08:00" content="2020-02-19">
              2020-02-19
            </time>
          </span>
          

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-底层原理/" itemprop="url" rel="index">
                    <span itemprop="name">iOS 底层原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>在 <code>Objective-C</code> 和 <code>Cocoa</code> 中，有许多事件之间进行通信的方式，并且每个都有不同程度的形式和耦合:<br><code>NSNotification</code> &amp; <code>NSNotificationCenter</code> 提供了一个中央枢纽，一个应用的任何部分都可能通知或者被通知应用的其他部分的变化。唯一需要做的是要知道在寻找什么，主要是通知的名字。例如，<code>UIApplicationDidReceiveMemoryWarningNotification</code> 是给应用发了一个内存不足的信号。<br><code>Key-Value Observing</code> 键值观察通过侦听特定键路径上的更改，可以在特定对象实例之间进行特殊的事件自省。例如：一个 <code>ProgressView</code> 可以观察 网络请求的 <code>numberOfBytesRead</code> 来更新它自己的 <code>progress</code> 属性。<br><code>Delegate</code> 是一个流行的传递事件的设计模式，通过定义一系列的方法来传递给指定的处理对象。例如：<code>UIScrollView</code> 每次它的 <code>scroll offset</code> 改变的时候都会发送 <code>scrollViewDidScroll:</code> 到它的代理<br><code>Callbacks</code> 不管是像 <code>NSOperation</code> 里的 <code>completionBlock</code>（当 <code>isFinished==YES</code> 的时候会触发），还是 <code>C</code> 里边的函数指针，传递一个函数钩子比如 <code>SCNetworkReachabilitySetCallback(3)</code>。</p>
</blockquote>
<a id="more"></a>

<h1 id="一、KVO-初探"><a href="#一、KVO-初探" class="headerlink" title="一、KVO 初探"></a>一、KVO 初探</h1><p>根据苹果官方文档的定义，<code>KVO</code> (Key Value Observing) 键值观察是建立在 <code>KVC</code> 基础之上的，所以如果对 <code>KVC</code> 不是很了解的读者可以查看上一篇 <code>KVC</code> 底层探索的文章。</p>
<p>我相信大多数开发者应该对于 <code>KVO</code> 都能熟练掌握，不过我们还是回顾一下官网对于 <code>KVO</code> 的解释吧。</p>
<h2 id="1-1-什么是-KVO"><a href="#1-1-什么是-KVO" class="headerlink" title="1.1 什么是 KVO?"></a>1.1 什么是 <code>KVO</code>?</h2><p><code>KVO</code> 提供了一种当其他对象的属性发生变化就会通知观察者对象的机制。根据官网的定义，属性的分类可以分为下列三种：</p>
<ul>
<li><strong>Attributes</strong>: 简单属性，比如基本数据类型，字符串和布尔值，而诸如 <code>NSNumber</code> 和其它一些不可变类型比如 <code>NSColor</code> 也可以被认为是简单属性</li>
<li><strong>To-one relationships</strong>: 这些是具有自己属性的可变对象属性。即对象的属性可以更改，而无需更改对象本身。例如，一个 <code>Account</code> 对象可能具有一个 <code>owner</code> 属性，该属性是 <code>Person</code> 对象的实例，而 <code>Person</code> 对象本身具有 <code>address</code> 属性。<code>owner</code> 的地址可以更改，但却而无需更改 <code>Account</code> 持有的 <code>owner</code> 属性。也就是说 <code>Account</code> 的 <code>owner</code> 属性未被更改，只是 <code>address</code> 被更改了。</li>
<li><strong>To-many relationships</strong>: 这些是集合对象属性。尽管也可以使用自定义集合类，但是通常使用 <code>NSArray</code> 或 <code>NSSet</code> 的实例来持有此集合。</li>
</ul>
<p>而 <code>KVO</code> 对于这三种属性都能适用。下面举一个例子：</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151907.jpg" alt></p>
<p>如上所示，<code>Person</code> 对象有一个 <code>Account</code> 属性，而 <code>Account</code> 对象又有 <code>balance</code> 和 <code>interestRate</code> 两个属性。并且这两个属性对于 <code>Person</code> 对象来说都是可读写的。如果想实现一个功能：当余额或利率变化的时候需要通知到用户。一般来说可以使用轮询的方式，<code>Person</code> 对象定期从 <code>Account</code> 属性中取出 <code>balance</code> 和 <code>interestRate</code>。但这种方式是效率低下且不切实际的，更好的方式是使用 <code>KVO</code>，类似于余额或利率变动时， <code>Person</code> 对象收到了通知一样。</p>
<p>要实现 <code>KVO</code> 的前提是要确保被观察对象是符合 <code>KVO</code> 机制的。一般来说，继承于 <code>NSObject</code> 根类的对象及其属性都自动符合 <code>KVO</code> 这一机制。当然也可以自己去实现 <code>KVO</code> 符合。也就是说实际上 <code>KVO</code> 机制分为<strong>自动符合</strong>和<strong>手动符合</strong>。</p>
<p>一旦确定了对象和属性是 <code>KVO</code> 符合的话，就需要历经三个步骤：</p>
<ul>
<li>观察者注册</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151909.jpg" alt></p>
<p><code>Person</code> 对象需要将自己注册到 <code>Account</code> 的某一个具体属性上。这个过程是通过<br><code>addObserver:forKeyPath:options:context:</code> 实现的，这个方法需要指定监听者(<code>observer</code>)、监听谁(<code>keypath</code>)、监听策略(<code>options</code>)、监听上下文(<code>context</code>)</p>
<ul>
<li>被观察者触发回调</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151913.jpg" alt></p>
<p><code>Person</code> 对象要接收 <code>Account</code> 被监听属性改动后发出的通知，需要自身实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法来接收通知。</p>
<ul>
<li>观察者取消注册</li>
</ul>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151911.jpg" alt></p>
<p>在观察者不需要再监听或自身生命周期结束的时候，需要取消注册。具体实现是通过向被观察对象发出 <code>removeObserver:forKeyPath:</code> 消息。</p>
<p><code>KVO</code> 机制的最大好处你不需要自己去实现一个机制来获取对象属性何时改变以及改变后的结果。</p>
<h2 id="1-2-KVO-三大流程解析"><a href="#1-2-KVO-三大流程解析" class="headerlink" title="1.2 KVO 三大流程解析"></a>1.2 <code>KVO</code> 三大流程解析</h2><h3 id="1-2-1-观察者注册"><a href="#1-2-1-观察者注册" class="headerlink" title="1.2.1 观察者注册"></a>1.2.1 观察者注册</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer</span><br><span class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</span><br><span class="line">            context:(<span class="keyword">void</span> *)context</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>observer</strong>:注册 <code>KVO</code> 通知的对象。观察者必须实现 <code>key-value observing</code> 方法 <code>observeValueForKeyPath:ofObject:change:context:</code>。<br><strong>keyPath</strong>:被观察者的属性的 <code>keypath</code>，相对于接受者，值不能是 <code>nil</code>。<br><strong>options</strong>: <code>NSKeyValueObservingOptions</code> 的组合，它指定了观察通知中包含了什么<br><strong>context</strong>:在 <code>observeValueForKeyPath:ofObject:change:context:</code> 传给 <code>observer</code> 参数的上下文</p>
</blockquote>
<p>前两个参数很好理解，而 <code>options</code> 和 <code>context</code> 参数则需要额外注意。</p>
<p><code>options</code> 代表 <code>NSKeyValueObservingOptions</code> 的位掩码，需要注意 <code>NSKeyValueObservingOptionNew &amp; NSKeyValueObservingOptionOld</code>，因为这些是你经常要用到的，可以跳过 <code>NSKeyValueObservingOptionInitial &amp; NSKeyValueObservingOptionPrior:</code>。</p>
<blockquote>
<p><code>NSKeyValueObservingOptionNew</code>: 表明通知中的更改字典应该提供<strong>新的属性值</strong>，如何可以的话。<br><code>NSKeyValueObservingOptionOld</code>: 表明通知中的更改字典应该包含<strong>旧的属性值</strong>，如何可以的话。<br><code>NSKeyValueObservingOptionInitial</code>: 这个枚举值比较特殊，如果指定了这个枚举值，<br>在属性发生变化后立即通知观察者，这个过程甚至早于观察者注册。如果在注册的时候配置了 <code>NSKeyValueObservingOptionNew</code>，那么在通知的更改字典中也会包含 <code>NSKeyValueChangeNewKey</code>，但是不会包括 <code>NSKeyValueChangeOldKey</code>。（在初始通知中，观察到的属性值可能是旧的，但是对于观察者来说是<strong>新的</strong>）其实简单来说就是这个枚举值会在属性变化前先触发一次 <code>observeValueForKeyPath</code> 回调。<br><code>NSKeyValueObservingOptionPrior</code>: 这个枚举值会先后连续出发两次 <code>observeValueForKeyPath</code> 回调。同时在回调中的可变字典中会有一个布尔值的 <code>key</code> - <code>notificationIsPrior</code> 来标识属性值是变化前还是变化后的。如果是变化后的回调，那么可变字典中就只有 <code>new</code> 的值了，如果同时制定了 <code>NSKeyValueObservingOptionNew</code> 的话。如果你需要启动手动 <code>KVO</code> 的话，你可以指定这个枚举值然后通过 <code>willChange</code> 实例方法来观察属性值。在出发 <code>observeValueForKeyPath</code> 回调后再去调用 <code>willChange</code> 可能就太晚了。</p>
</blockquote>
<blockquote>
<p>这些选项允许一个对象在发生变化的前后获取值。在实践中，这不是必须的，因为从当前属性值获取的新值一般是可用的 也就是说 <code>NSKeyValueObservingOptionInitial</code> 对于在反馈 <code>KVO</code> 事件的时候减少代码路径是很有好处的。比如，如果你有一个方法，它能够动态的使一个基于 <code>text</code> 值的按钮有效，传 <code>NSKeyValueObservingOptionInitial</code> 可以使事件随着它的初始化状态触发一旦观察者被添加进去的话。</p>
</blockquote>
<blockquote>
<p>如何设置一个好的 <code>context</code> 值呢？这里有个建议：</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * XXContext = &amp;XXContext;</span><br></pre></td></tr></table></figure>

<p>就是这么简单：一个静态变量存着它自己的指针。这意味着它自己什么也没有，使 <code>&lt;NSKeyValueObserving&gt;</code> 更完美。</p>
<p>我们简单测试一下在注册观察者时指定不同的枚举值会有怎么样的结果：</p>
<ul>
<li>只指定 <code>NSKeyValueObservingOptionNew</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151916.jpg" alt></p>
<ul>
<li>只指定 <code>NSKeyValueObservingOptionOld</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152116.jpg" alt></p>
<ul>
<li>指定 <code>NSKeyValueObservingOptionInitial</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152126.jpg" alt></p>
<p>可以看到，只指定了 <code>NSKeyValueObservingOptionInitial</code> 后触发了两个回调，并且一次是在属性值变化前，一次是在属性值变化后。同时并且没有新值和旧值返回，我们加一个 <code>NSKeyValueObservingOptionNew</code> 和 <code>NSKeyValueObservingOptionOld</code>:</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152131.jpg" alt></p>
<p>在我们加上新值和旧值的枚举之后，新值在两次回调后被返回，<strong>但是第一次的新值其实是最开始的属性值</strong>，第二次才是改变之后的属性值，而旧值在第二次真正属性值被改变后返回。</p>
<ul>
<li>指定 <code>NSKeyValueObservingOptionPrior</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152121.jpg" alt></p>
<p>可以看到，<code>NSKeyValueObservingOptionPrior</code> 枚举值是在属性值发生变化后触发了两次回调，同时也没有新值和旧值的返回，我们加一个 <code>NSKeyValueObservingOptionNew</code> 和 <code>NSKeyValueObservingOptionOld</code>:</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152142.jpg" alt></p>
<p>可以看到，在第一次回调里没有新值，第二次才有，而旧值在两次回调里面都有。</p>
<hr>
<ul>
<li>keyPath 字符串问题</li>
</ul>
<p>我们在注册观察者的时候，要求传入的 <code>keyPath</code> 是字符串类型，如果我们拼写错误的话，编译器是不能帮我们检查出来的，所有最佳实践应该是使用 <code>NSStringFromSelector(SEL aSelector)</code>，比如我们要观察 <code>tableView</code> 的 <code>contentSize</code> 属性，我们可以这样使用：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(contentSize))</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-观察者接收通知"><a href="#1-2-2-观察者接收通知" class="headerlink" title="1.2.2 观察者接收通知"></a>1.2.2 观察者接收通知</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">                       context:(<span class="keyword">void</span> *)context</span><br></pre></td></tr></table></figure>

<p>这个方法就是观察者接收通知的地方，除了 <code>change</code> 参数之外，其他三个参数都与观察者注册的时候传入的三个参数一一对应。</p>
<ul>
<li>不同对象监听相同的 <code>keypath</code></li>
</ul>
<p>默认情况下，我们在 <code>addObserver:forKeyPath:options:context:</code> 方法的最后一个参数传入的是 <code>NULL</code>，因为这个方法签名中最后一个参数 <code>context</code> 是 <code>void *</code>，所以需要传入一个空指针，而根据下图我们可知，<code>nil</code> 只是一个对象的字面零值，这里需要的是一个指针，所以需要传 <code>NULL</code>。</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152032.jpg" alt></p>
<p>但是如果是不同的对象都监听同一属性，我们就需要给 <code>context</code> 传入一个可以区分不同对象的字符串指针：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *StudentNameContext = &amp;StudentNameContext;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *PersonNameContext = &amp;PersonNameContext;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>) context:PersonNameContext];</span><br><span class="line">[<span class="keyword">self</span>.student addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>) context:StudentNameContext];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (context == PersonNameContext) &#123;</span><br><span class="line">  </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context == StudentNameContext) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要自己处理 <code>superclass</code> 的 <code>observe</code> 事务</li>
</ul>
<blockquote>
<p>对于 <code>Objective-C</code>，很多时候 <code>Runtime</code> 系统都会自动帮助处理 <code>superclass</code> 的方法。譬如对于 <code>dealloc</code>，假设类 <code>Father</code> 继承自 <code>NSObject</code>，而类 <code>Son</code> 继承自<code>Father</code>，创建一个 <code>Son</code> 的实例 <code>aSon</code>，在 <code>aSon</code> 被释放的时候，<code>Runtime</code> 会先调用 <code>Son#dealloc</code>，之后会自动调用 <code>Father#dealloc</code>，而无需在 <code>Son#dealloc</code> 中显式执行 <code>[super dealloc]</code>;。但 <code>KVO</code> 不会这样，所以为了保证父类（父类可能也会自己 <code>observe</code> 事务要处理）的 <code>observe</code> 事务也能被处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; - (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">&gt;                      ofObject:(id)object</span><br><span class="line">&gt;                        change:(NSDictionary *)change</span><br><span class="line">&gt;                       context:(void *)context &#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    if (object == _tableView &amp;&amp; [keyPath &gt;isEqualToString:@&quot;contentSize&quot;]) &#123;</span><br><span class="line">&gt;        [self configureView];</span><br><span class="line">&gt;    &#125; else &#123;</span><br><span class="line">&gt;        [super observeValueForKeyPath:keyPath ofObject:object &gt;change:change context:context];</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-2-3-取消注册"><a href="#1-2-3-取消注册" class="headerlink" title="1.2.3 取消注册"></a>1.2.3 取消注册</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">void</span> *)context;</span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>

<p>取消注册有两个方法，不过建议还是跟注册和通知两个流程统一，选用带有 <code>context</code> 参数的方法。</p>
<ul>
<li>取消注册与注册是一对一的关系</li>
</ul>
<p>一旦对某个对象上的属性注册了键值观察，可以选择在收到属性值变化后取消注册，也可以在观察者声明周期结束之前(比如：<code>dealloc</code> 方法) 取消注册，如果忘记调用取消注册方法，那么一旦观察者被销毁后，<code>KVO</code> 机制会给一个不存在的对象发送变化回调消息导致<strong>野指针</strong>错误。</p>
<ul>
<li>不能重复取消注册</li>
</ul>
<p>取消注册也不能对同一个观察者重复多次，为了避免 <code>crash</code>，可以把取消注册的代码包裹在 <code>try&amp;catch</code> 代码块中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * ContentSizeContext = &amp;ContentSizeContext;</span><br><span class="line">    </span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. subscribe</span></span><br><span class="line">    [_tableView addObserver:<span class="keyword">self</span></span><br><span class="line">                 forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(contentSize))</span><br><span class="line">                    options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                    context:ContentSizeContext];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2. responding</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">                       context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == ContentSizeContext) &#123;</span><br><span class="line">        <span class="comment">// configure view</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="comment">// 3. unsubscribe</span></span><br><span class="line">        [_tableView removeObserver:<span class="keyword">self</span></span><br><span class="line">                        forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(contentSize))</span><br><span class="line">                           context:ContentSizeContext];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-“自动挡”-和-“手动挡”"><a href="#1-3-“自动挡”-和-“手动挡”" class="headerlink" title="1.3 “自动挡” 和 “手动挡”"></a>1.3 “自动挡” 和 “手动挡”</h2><p>默认情况下，我们只需要按照前面说的 <code>三步曲</code> 的方式来实现对属性的键值观察，不过这属于是 「自动挡」，什么意思呢？就是说属性值变化完全是由系统控制，我们只需要告诉系统监听什么属性，然后就直接等系统告诉我们就完事了。而实际上，<code>KVO</code> 还支持「手动挡」。</p>
<p>要让系统知道我们想开启手动挡，需要修改类方法 <code>automaticallyNotifiesObserversForKey:</code> 的返回值，这个方法如果返回 <code>YES</code> 就是自动挡，返回 <code>NO</code> 就是手动挡。同时该类方法还能精准实策，让我们选择对哪些属性是自动，哪些属性是手动。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)theKey &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">BOOL</span> automatic = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> ([theKey isEqualToString:<span class="string">@"balance"</span>]) &#123;</span><br><span class="line">        automatic = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        automatic = [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:theKey];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> automatic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，如上代码所示，我们使用 <code>automaticallyNotifiesObserversForKey</code> 的最佳实践仍然需要把我们需要手动或自动的代码排除后去调用下父类的方法来确保不会有问题出现。</p>
<ul>
<li>自动 <code>KVO</code> 触发方式</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call the accessor method.</span></span><br><span class="line">[account setName:<span class="string">@"Savings"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Use setValue:forKey:.</span></span><br><span class="line">[account setValue:<span class="string">@"Savings"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Use a key path, where 'account' is a kvc-compliant property of 'document'.</span></span><br><span class="line">[document setValue:<span class="string">@"Savings"</span> forKeyPath:<span class="string">@"account.name"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Use mutableArrayValueForKey: to retrieve a relationship proxy object.</span></span><br><span class="line">Transaction *newTransaction = &lt;<span class="meta">#Create a new transaction for the account#&gt;;</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *transactions = [account mutableArrayValueForKey:<span class="string">@"transactions"</span>];</span><br><span class="line">[transactions addObject:newTransaction];</span><br></pre></td></tr></table></figure>

<p>如上代码所示是自动 <code>KVO</code> 的触发方式</p>
<ul>
<li>手动 <code>KVO</code> 触发方式</li>
</ul>
<p>其实手动 <code>KVO</code> 可以帮助我们将多个属性值的更改合并成一个，这样在回调的时候就有一次了，同时也能最大程度地减少处于应用程序特定原因而导致的通知发生。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">    _balance = theBalance;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码所示，最朴素的手动 <code>KVO</code> 使用方法就是在属性值改变前对观察者发送 <code>willChangeValueForKey</code> 实例方法，在属性值改变之后对观察者发送 <code>didChangeValueForKey</code> 实例方法，参数都是所观察的键。<br>当然，上面这种方式不是最佳的，为了性能最佳，可以在属性的 <code>setter</code> 中判断是否要执行 <code>will</code> + <code>did</code>:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    <span class="keyword">if</span> (theBalance != _balance) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">        _balance = theBalance;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果对一个属性的改变会影响到多个键的话，则需要如下的操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"itemChanged"</span>];</span><br><span class="line">    _balance = theBalance;</span><br><span class="line">    _itemChanged = _itemChanged+<span class="number">1</span>;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"itemChanged"</span>];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于有序的一对多关系属性，不仅必须指定已更改的键，还必须指定更改的类型和所涉及对象的索引。 更改的类型是 <code>NSKeyValueChange</code>，它指定 <code>NSKeyValueChangeInsertion</code>，<code>NSKeyValueChangeRemoval</code> 或 <code>NSKeyValueChangeReplacement</code>，受影响的对象的索引作为 <code>NSIndexSet</code> 对象传递:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeTransactionsAtIndexes:(NSIndexSet *)indexes &#123;</span><br><span class="line">    [self willChange:NSKeyValueChangeRemoval</span><br><span class="line">        valuesAtIndexes:indexes forKey:@&quot;transactions&quot;];</span><br><span class="line"> </span><br><span class="line">    // Remove the transaction objects at the specified indexes.</span><br><span class="line"> </span><br><span class="line">    [self didChange:NSKeyValueChangeRemoval</span><br><span class="line">        valuesAtIndexes:indexes forKey:@&quot;transactions&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-注册从属关系的-KVO"><a href="#1-4-注册从属关系的-KVO" class="headerlink" title="1.4 注册从属关系的 KVO"></a>1.4 注册从属关系的 <code>KVO</code></h2><p>所谓从属关系，指的是一个对象的某个属性的值取决于另一个对象的一个或多个属性。对于不同类型的属性，有不同的方式来实现。</p>
<ul>
<li>一对一关系</li>
</ul>
<p>要触发 <strong>一对一</strong> 类型属性的自动 <code>KVO</code>，有两种方式。一种是重写 <code>keyPathsForValuesAffectingValueForKey</code> 方法，一种是实现一个合适的方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)fullName &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %@"</span>,firstName, lastName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如上面的代码，<code>fullName</code> 由 <code>firstName</code> 和 <code>lastName</code> 组成，所以重写 <code>fullName</code> 属性的 <code>getter</code> 方法。这样，不论是 <code>firstName</code> 还是 <code>lastName</code> 发生了改变，监听 <code>fullName</code> 属性的观察者都会收到通知。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"fullName"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *affectingKeys = @[<span class="string">@"lastName"</span>, <span class="string">@"firstName"</span>];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码所示，通过实现类方法 <code>keyPathsForValuesAffectingValueForKey</code> 来返回一个集合。值得注意的是，这里需要先对父类发送 <code>keyPathsForValuesAffectingValueForKey</code> 消息，以免干扰父类中对此方法的重写。</p>
<p>实际上还有一个便利的方法，就是 <code>keyPathsForValuesAffecting&lt;Key&gt;</code>，<code>Key</code> 是属性的名称（需要首字母大写）。这个方法的效果和 <code>keyPathsForValuesAffectingValueForKey</code> 是一样的，但针对的某个具体属性。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingFullName &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"lastName"</span>, <span class="string">@"firstName"</span>, <span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对来说，在分类中去使用 <code>keyPathsForValuesAffectingFullName</code> 更合理，因为分类中是不允许重载方法的，所以 <code>keyPathsForValuesAffectingValueForKey</code> 方法肯定是不能在分类中使用的。</p>
<hr>
<ul>
<li>一对多关系</li>
</ul>
<p><code>keyPathsForValuesAffectingValueForKey</code>：方法不支持包含一对多关系的 <code>Key Path</code>。例如，假设你有一个 <code>Department</code>对象，该对象与 <code>Employee</code> 有一对多关系（即 <code>employees</code> 属性），而 <code>Employee</code> 具有 <code>salary</code> 属性。 如果需要在 <code>Department</code> 对象上增加<code>totalSalary</code> 属性，而该属性取决于关系中所有 <code>Employees</code> 的薪水。例如，您不能使用 <code>keyPathsForValuesAffectingTotalSalary</code> 和返回 <code>employees.salary</code> 作为键来执行此操作。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (context == totalSalaryContext) &#123;</span><br><span class="line">        [<span class="keyword">self</span> updateTotalSalary];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// deal with other observations and/or invoke super...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)updateTotalSalary &#123;</span><br><span class="line">    [<span class="keyword">self</span> setTotalSalary:[<span class="keyword">self</span> valueForKeyPath:<span class="string">@"employees.@sum.salary"</span>]];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)setTotalSalary:(<span class="built_in">NSNumber</span> *)newTotalSalary &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (totalSalary != newTotalSalary) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"totalSalary"</span>];</span><br><span class="line">        _totalSalary = newTotalSalary;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"totalSalary"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="built_in">NSNumber</span> *)totalSalary &#123;</span><br><span class="line">    <span class="keyword">return</span> _totalSalary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码所示，将 <code>Department</code> 实例对象注册为观察者，然后观察对象为 <code>totalSalary</code> 属性，但是在通知回调中会手动调用 <code>totalSalary</code> 属性的 <code>setter</code> 方法，并且传入值是通过 <code>KVC</code> 的集合运算符的方式取出 <code>employees</code> 属性所对应的集合中所有 <code>sum</code> 值之和。然后在 <code>totalSalary</code> 属性的 <code>setter</code> 方法中，会相应的调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 方法。</p>
<p>如果使用的是 <code>Core Data</code>，你还可以把 <code>Department</code> 注册到 <code>NSNotificationCenter</code> 中来作为托管对象上下文的观察者。<code>Department</code> 应以类似于观察键值的方式响应 <code>Employee</code> 发布的相关变更通知。</p>
<h1 id="二、KVO-原理探究"><a href="#二、KVO-原理探究" class="headerlink" title="二、KVO 原理探究"></a>二、KVO 原理探究</h1><blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling.<br>【译】自动的键值观察的实现基于 <code>isa-swizzling</code>。</p>
<p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.<br>【译】<code>isa</code> 指针，顾名思义，指向的是对象所属的类，这个类维护了一个哈希表。这个哈希表基本上存储的是方法的 <code>SEL</code> 和 <code>IMP</code> 的键值对。 </p>
<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>
<p>【译】当一个观察者注册了对一个对象的某个属性键值观察之后，被观察对象的 <code>isa</code> 指针所指向的内容发生了变化，指向了一个<strong>中间类</strong>而不是真正的类。这也导致 <code>isa</code> 指针并不一定是指向实例所属的真正的类。</p>
</blockquote>
<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>
<blockquote>
<p>【译】你永远不应依靠 <code>isa</code> 指针来确定类成员身份。相反，你应该使用 <code>class</code> 方法来确定对象实例所属的类。</p>
</blockquote>
<h2 id="2-1-中间类"><a href="#2-1-中间类" class="headerlink" title="2.1 中间类"></a>2.1 中间类</h2><p>根据官网文档的内容，我们初步判断，在 <code>KVO</code> 底层实现中，会有一个所谓的中间类生成。而这个中间类会让对象的 <code>isa</code> 指针发生变化。我们不妨测试一下：</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152136.jpg" alt></p>
<p>如上图所示，<code>person</code> 对象和 <code>personForTest</code> 对象都是属于 <code>JHPerson</code> 类的，而 <code>person</code> 对象又实现了 <code>KVO</code>，但是在控制台打印结果里面可以看到它们二者的类都是 <code>JHPerson</code> 类。不是说会有一个中间类生成吗？难道是这个中间类生成又被干掉了？我们直接<code>LLDB</code> 大法测试一下：</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152148.jpg" alt></p>
<p>Bingo~，所谓的中间类 <code>NSKVONotifying_JHPerson</code> 被我们找出来了。那么其实这里显然，系统是重写了中间类 <code>NSKVONotifying_JHPerson</code> 的 <code>class</code> 方法，让我们以为对象的 <code>isa</code> 指针一直指向的都是 <code>JHPerson</code> 类。那么这个中间类和原来的类是什么关系呢?我们可以测试一下：</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152151.jpg" alt></p>
<p>其中 <code>printClasses</code> 实现如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printClasses:(Class)cls&#123;</span><br><span class="line">    <span class="keyword">int</span> count = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mArray = [<span class="built_in">NSMutableArray</span> arrayWithObject:cls];</span><br><span class="line">    Class* classes = (Class*)malloc(<span class="keyword">sizeof</span>(Class)*count);</span><br><span class="line">    objc_getClassList(classes, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cls == class_getSuperclass(classes[i])) &#123;</span><br><span class="line">            [mArray addObject:classes[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(classes);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"classes = %@"</span>, mArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终打印结果如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">classes = (</span><br><span class="line">    JHPerson</span><br><span class="line">)</span><br><span class="line">classes = (</span><br><span class="line">    JHPerson,</span><br><span class="line">    <span class="string">"NSKVONotifying_JHPerson"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>结果很清晰，中间类 <code>NSKVONotifying_JHPerson</code> 是作为原始真正的类 <code>JHPerson</code> 的子类的角色。</p>
<h2 id="2-2-KVO-观察的是什么？"><a href="#2-2-KVO-观察的是什么？" class="headerlink" title="2.2 KVO 观察的是什么？"></a>2.2 <code>KVO</code> 观察的是什么？</h2><p><code>KVO</code> 所关注的是属性值的变化，而属性值本质上是成员变量+<code>getter</code>+<code>setter</code>，<code>getter</code> 是用来获取值的，而显然只有 <code>setter</code> 和成员变量赋值两种方式可以改变属性值。我们测试一下这两种方式：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JHPerson.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JHPerson</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="built_in">NSString</span> *_nickName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152154.jpg" alt></p>
<p>如上图所示，<code>setter</code> 方法对属性 <code>name</code> 做了修改被 <code>KVO</code> 监听到了，而成员变量 <code>_nickName</code> 的修改并没有被监听到，说明 <code>KVO</code> 底层其实观察的是 <code>setter</code> 方法。</p>
<h2 id="2-3-中间类重写了哪些方法？"><a href="#2-3-中间类重写了哪些方法？" class="headerlink" title="2.3 中间类重写了哪些方法？"></a>2.3 中间类重写了哪些方法？</h2><p>我们可以通过打印原始类和中间类的方法列表来验证：</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152159.jpg" alt></p>
<p><code>printClassAllMethod</code> 方法实现如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printClassAllMethod:(Class)cls&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"*********************"</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        SEL sel = method_getName(method);</span><br><span class="line">        IMP imp = class_getMethodImplementation(cls, sel);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@-%p"</span>,<span class="built_in">NSStringFromSelector</span>(sel),imp);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到如上图所示，原始类和中间类都有 <code>setter</code> 方法。根据我们前面所探索的消息发送以及转发流程，这里的中间类应该是重写了 <code>setName:</code> 、<code>class</code>、 <code>dealloc</code> 和 <code>_isKVOA</code> 方法。</p>
<p>由我们上一小节的测试结果可知，中间类重写的 <code>class</code> 方法结果仍然是返回的是原始类，显然系统这样做的目的就是隐藏中间类的存在，让调用者调用 <code>class</code> 方法结果前后一致。</p>
<h2 id="2-4-KVO-中间类何时指回去？"><a href="#2-4-KVO-中间类何时指回去？" class="headerlink" title="2.4 KVO 中间类何时指回去？"></a>2.4 <code>KVO</code> 中间类何时指回去？</h2><p>我们推断 <code>KVO</code> 注册观察者到移除观察者这一个流程里面，被观察对象的 <code>isa</code> 指针才会指向中间类，我们用代码测试一下:</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152204.jpg" alt></p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152208.jpg" alt></p>
<p>由上图可知，观察者的 <code>dealloc</code> 方法中的移除观察者之后，对象的 <code>isa</code> 指针已经指回了原始的类。那么是不是此时中间类就被销毁了呢，我们不妨打印一下此时原始类的所有子类信息：</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152208.jpg" alt></p>
<p>结果表明中间类仍然存在，也就是说移除观察者并不会导致中间类销毁，显然这样对于多次添加和移除观察者来说性能上更好。</p>
<h2 id="2-5-KVO-调用顺序"><a href="#2-5-KVO-调用顺序" class="headerlink" title="2.5 KVO 调用顺序"></a>2.5 <code>KVO</code> 调用顺序</h2><p>而我们前面说了，有一个中间类的存在，既然要生成中间类，肯定是有意义的，我们梳理一下整个 <code>KVO</code> 的流程，从注册观察者到观察者的回调通知，既然有回调通知，那么肯定是在某个地方发出回调的，而由于中间类是不能编译的，所以我们对中间类的父类也就是 <code>JHPerson</code> 类，我们重写一下相应的 <code>setter</code> 方法，我们不妨测试一下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JHPerson.m</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    [<span class="keyword">super</span> willChangeValueForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"willChangeValueForKey"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey - begin"</span>);</span><br><span class="line">    [<span class="keyword">super</span> didChangeValueForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey - end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152216.jpg" alt></p>
<p>也就是说 <code>KVO</code> 的调用顺序是:</p>
<ul>
<li>调用 <code>willChangeValueForKey:</code></li>
<li>调用原来的 <code>setter</code> 实现</li>
<li>调用 <code>didChangeValueForKey:</code></li>
</ul>
<p>也就是说 <code>didChangeValueForKey:</code> 内部必然是调用了 <code>observer</code> 的<code>observeValueForKeyPath:ofObject:change:context:</code>方法。</p>
<h1 id="三、自定义-KVO-如何实现"><a href="#三、自定义-KVO-如何实现" class="headerlink" title="三、自定义 KVO 如何实现"></a>三、自定义 KVO 如何实现</h1><p>我们已经初步了解了 <code>KVO</code> 底层原理，接下来我们尝试自己简单实现一下 <code>KVO</code>。<br>我们直接跳转到 <code>addObserver:forKeyPath:options:context:</code> 方法的声明处：</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152219.jpg" alt></p>
<p>可以看到，跟 <code>KVC</code> 一样，<code>KVO</code> 在底层也是以分类的形式加载的，这个分类叫做 <code>NSKeyValueObserverRegistration</code>。我们不妨也以这种方式来自定义实现一下 <code>KVO</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSObject+JHKVO.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">JHKVO</span>)</span></span><br><span class="line"><span class="comment">// 观察者注册</span></span><br><span class="line">- (<span class="keyword">void</span>)jh_addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(JHKeyValueObservingOptions)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"><span class="comment">// 回调通知观察者</span></span><br><span class="line">- (<span class="keyword">void</span>)jh_observeValueForKeyPath:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object change:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *)change context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"><span class="comment">// 移除观察者</span></span><br><span class="line">- (<span class="keyword">void</span>)jh_removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>这里为了避免与系统的方法冲突，所以添加了一个方法前缀。同时对于观察策略，为了简化实现，这里只声明了新值和旧值两种策略。</p>
<h2 id="3-1-自定义观察者注册"><a href="#3-1-自定义观察者注册" class="headerlink" title="3.1 自定义观察者注册"></a>3.1 自定义观察者注册</h2><p>在开始之前，我们回忆下自定义 <code>KVC</code> 的时候的第一个步骤就是判断 <code>key</code> 或者 <code>keyPath</code>，那么 <code>KVO</code> 是否也需要进行这样的判断呢?经过笔者实际测试，如果观察对象的一个不存在的属性的话，并不会报错，也不会来到 <code>KVO</code> 回调方法，由此可见，判断 <code>keyPath</code> 是否存在并没有必要。但是，我们回想一下上一节 <code>KVO</code> 底层原理，<code>KVO</code> 关注的是属性的 <code>setter</code> 方法，那其实判断对象所属的类是否有这样的 <code>setter</code> 就相当于同时判断了 <code>keyPath</code> 是否存在。接着我们就需要去动态的创建子类，创建子类的过程中包括了重写 <code>setter</code> 等一系列方法。然后就需要保存观察者和 <code>keyPath</code> 等信息，这里我们借助关联对象来实现，我们把传入的观察者对象、<code>keyPath</code>和观察策略封装成一个新的对象存储在关联对象中。因为同一个对象的属性可以被不同的观察者所观察，所以这里实质上是以对象数组的方式存储在关联对象里面。<br>话不多说，直接上代码:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JHKVOInfo.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, JHKeyValueObservingOptions) &#123;</span><br><span class="line">    JHKeyValueObservingOptionNew = <span class="number">0x01</span>,</span><br><span class="line">    JHKeyValueObservingOptionOld = <span class="number">0x02</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JHKVOInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSObject</span>  *observer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>  *keyPath;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) JHKeyValueObservingOptions options;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWitObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(JHKeyValueObservingOptions)options;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JHKVOInfo.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JHKVOInfo</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWitObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(JHKeyValueObservingOptions)options</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _observer = observer;</span><br><span class="line">        _keyPath = keyPath;</span><br><span class="line">        _options = options;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>上面的代码是自定义的 <code>JHKVOInfo</code> 对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kJHKVOPrefix = <span class="string">@"JHKVONotifying_"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kJHKVOAssiociateKey = <span class="string">@"kJHKVO_AssiociateKey"</span>;</span><br><span class="line">- (<span class="keyword">void</span>)jh_addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(JHKeyValueObservingOptions)options context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.判断 getter 是否存在</span></span><br><span class="line">    SEL setterSelector = <span class="built_in">NSSelectorFromString</span>(setterForGetter(keyPath));</span><br><span class="line">    Method setterMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], setterSelector);</span><br><span class="line">    <span class="keyword">if</span> (!setterMethod) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *reason = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"对象 %@ 的 key %@ 没有 setter 实现"</span>, <span class="keyword">self</span>, keyPath];</span><br><span class="line">        <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInvalidArgumentException</span></span><br><span class="line">                                       reason:reason</span><br><span class="line">                                     userInfo:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.动态创建中间子类</span></span><br><span class="line">    Class newClass = [<span class="keyword">self</span> createChildClassWithKeyPath:keyPath];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.将对象的isa指向为新的中间子类</span></span><br><span class="line">    object_setClass(<span class="keyword">self</span>, newClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.保存观察者</span></span><br><span class="line">    JHKVOInfo *info = [[JHKVOInfo alloc] initWitObserver:observer forKeyPath:keyPath options:options];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *observerArr = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!observerArr) &#123;</span><br><span class="line">        observerArr = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">1</span>];</span><br><span class="line">        [observerArr addObject:info];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey), observerArr, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是完整的添加观察者的流程：</p>
<ul>
<li>判断对象所属的类上是否有要观察的 <code>keyPath</code> 对应的 <code>setter</code> 方法</li>
</ul>
<blockquote>
<p>这里的 <code>setterForGetter</code> 实现如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">static</span> <span class="built_in">NSString</span> * setterForGetter(<span class="built_in">NSString</span> *<span class="keyword">getter</span>)</span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;    <span class="comment">// 判断 getter 是否为空字符串</span></span><br><span class="line">&gt;    <span class="keyword">if</span> (<span class="keyword">getter</span>.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">&gt;        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="comment">// 取出 getter 字符串的第一个字母并转大写 </span></span><br><span class="line">&gt;    <span class="built_in">NSString</span> *firstLetter = [[<span class="keyword">getter</span> substringToIndex:<span class="number">1</span>] uppercaseString];</span><br><span class="line">&gt;    <span class="comment">// 取出剩下的字符串内容</span></span><br><span class="line">&gt;    <span class="built_in">NSString</span> *remainingLetters = [<span class="keyword">getter</span> substringFromIndex:<span class="number">1</span>];</span><br><span class="line">&gt;    <span class="comment">// 将首字母大写的字母与剩下的字母拼接起来得到 `set&lt;KeyPath&gt;` 格式的字符串</span></span><br><span class="line">&gt;    <span class="built_in">NSString</span> *<span class="keyword">setter</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@%@:"</span>, firstLetter, remainingLetters];</span><br><span class="line">&gt;    <span class="keyword">return</span> <span class="keyword">setter</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>如果存在相应的 <code>setter</code> 方法，那么就创建有对应前缀的中间子类</li>
</ul>
<blockquote>
<p>这里的 <code>createChildClassWithKeyPath</code> 实现如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; - (Class)createChildClassWithKeyPath:(<span class="built_in">NSString</span> *)keyPath&#123;</span><br><span class="line">&gt;     <span class="comment">// 获得原始类的类名</span></span><br><span class="line">&gt;     <span class="built_in">NSString</span> *oldClassName = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">&gt;     <span class="comment">// 在原始类名前添加中间子类的前缀来获得中间子类名</span></span><br><span class="line">&gt;     <span class="built_in">NSString</span> *newClassName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@"</span>,kJHKVOPrefix,oldClassName];</span><br><span class="line">&gt;     <span class="comment">// 通过中间子类名来判断是否创建过</span></span><br><span class="line">&gt;     Class newClass = <span class="built_in">NSClassFromString</span>(newClassName);</span><br><span class="line">&gt;     <span class="comment">// 如果创建过中间子类，直接返回</span></span><br><span class="line">&gt;     <span class="keyword">if</span> (newClass) <span class="keyword">return</span> newClass;</span><br><span class="line">&gt;     <span class="comment">// 如果没有创建过，则需要创建一下, objc_allocateClassPair 方法的三个参数分别为: 1.父类 2.新类的名字 3.创建新类所需额外的空间</span></span><br><span class="line">&gt;     newClass = objc_allocateClassPair([<span class="keyword">self</span> <span class="keyword">class</span>], newClassName.UTF8String, <span class="number">0</span>);</span><br><span class="line">&gt;     <span class="comment">// 注册中间子类</span></span><br><span class="line">&gt;     objc_registerClassPair(newClass);</span><br><span class="line">&gt;     <span class="comment">// 从父类上拿到 `class` 方法的 `SEL` 以及类型编码，然后在中间子类上添加一个新的子类实现 `jh_class`</span></span><br><span class="line">&gt;     SEL classSEL = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"class"</span>);</span><br><span class="line">&gt;     Method classMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], classSEL);</span><br><span class="line">&gt;     <span class="keyword">const</span> <span class="keyword">char</span> *classTypes = method_getTypeEncoding(classMethod);</span><br><span class="line">&gt;     class_addMethod(newClass, classSEL, (IMP)jh_class, classTypes);</span><br><span class="line">&gt;     <span class="comment">// 从父类上拿到 `getter` 方法的 `SEL` 以及类型编码，然后在中间子类上添加一个新的子类实现 `jh_setter`</span></span><br><span class="line">&gt;     SEL setterSEL = <span class="built_in">NSSelectorFromString</span>(setterForGetter(keyPath));</span><br><span class="line">&gt;     Method setterMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], setterSEL);</span><br><span class="line">&gt;     <span class="keyword">const</span> <span class="keyword">char</span> *setterTypes = method_getTypeEncoding(setterMethod);</span><br><span class="line">&gt;     class_addMethod(newClass, setterSEL, (IMP)jh_setter, setterTypes);</span><br><span class="line">&gt;     <span class="keyword">return</span> newClass;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><code>jh_class</code> 的实现如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; Class jh_class(<span class="keyword">id</span> <span class="keyword">self</span>,SEL _cmd) &#123;</span><br><span class="line">&gt;    <span class="comment">// 通过 class_getSuperclass 来返回父类的 `Class`，达到对调用者隐藏中间子类的效果</span></span><br><span class="line">&gt;    <span class="keyword">return</span> class_getSuperclass(object_getClass(<span class="keyword">self</span>));</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><code>jh_setter</code> 的实现如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">static</span> <span class="keyword">void</span> jh_setter(<span class="keyword">id</span> <span class="keyword">self</span>,SEL _cmd,<span class="keyword">id</span> newValue)&#123;</span><br><span class="line">&gt;     <span class="comment">// 因为 `_cmd` 作为方法的第二个参数其实就是 `setter` 的 `SEL`，这里反向获得对应 `getter` 字符串形式作为 `keyPath`，然后通过 `KVC` 来获取到旧的属性值</span></span><br><span class="line">&gt;     <span class="built_in">NSString</span> *keyPath = getterForSetter(<span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">&gt;     <span class="keyword">id</span> oldValue       = [<span class="keyword">self</span> valueForKey:keyPath];</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="comment">// 因为是重写父类的 `setter`，所以还需要通过消息发送的方式手动执行以下父类的 `setter` 方法</span></span><br><span class="line">&gt;     <span class="comment">// 通过强转的方式将 `objc_msgSendSuper` 转成 `jh_msgSendSuper` 函数指针，同时，由于 `objc_msgSendSuper` 要比我们常见的 `objc_msgSend` 多一个父类结构体参数，所以需要手动构建一下这个父类结构体，结构体有两个属性，分别是实例对象以及实例对象的类的父类</span></span><br><span class="line">&gt;     <span class="keyword">void</span> (*jh_msgSendSuper)(<span class="keyword">void</span> *, SEL, <span class="keyword">id</span>) = (<span class="keyword">void</span> *)objc_msgSendSuper;</span><br><span class="line">&gt;     <span class="comment">// void /* struct objc_super *super, SEL op, ... */</span></span><br><span class="line">&gt;     <span class="keyword">struct</span> objc_super superStruct = &#123;</span><br><span class="line">&gt;         .receiver = <span class="keyword">self</span>,</span><br><span class="line">&gt;         .super_class = class_getSuperclass(object_getClass(<span class="keyword">self</span>)),</span><br><span class="line">&gt;     &#125;;</span><br><span class="line">&gt;     <span class="comment">// 准备工作完成后手动调用 `jh_msgSendSuper`，因为 `superStruct` 是结构体类型，而 `jh_msgSendSuper` 的第一个参数是空指针对象，所以这里需要加取地址符来把结构体地址赋值给指针对象</span></span><br><span class="line">&gt;     jh_msgSendSuper(&amp;superStruct, _cmd, newValue);</span><br><span class="line">&gt;     <span class="comment">// 调用完父类的 `setter` 之后，从关联对象中取出存储了自定义的对象数组</span></span><br><span class="line">&gt;     <span class="built_in">NSMutableArray</span> *observerArr = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey));</span><br><span class="line">&gt;     <span class="comment">// 循环遍历自定义的对象</span></span><br><span class="line">&gt;     <span class="keyword">for</span> (JHKVOInfo *info <span class="keyword">in</span> observerArr) &#123;</span><br><span class="line">&gt;     <span class="comment">// 如果 `keyPath` 匹配则进入下一步</span></span><br><span class="line">&gt;         <span class="keyword">if</span> ([info.keyPath isEqualToString:keyPath]) &#123;</span><br><span class="line">&gt;             <span class="comment">// 基于线程安全的考虑，使用 `GCD` 的全局队列异步执行下面的操作 </span></span><br><span class="line">&gt;             <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">&gt;                 <span class="comment">// 初始化一个通知字典</span></span><br><span class="line">&gt;                 <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *change = [<span class="built_in">NSMutableDictionary</span> dictionaryWithCapacity:<span class="number">1</span>];</span><br><span class="line">&gt;                 <span class="comment">// 判断存储的观察策略，如果是新值，则在通知字典中设置新值  </span></span><br><span class="line">&gt;                 <span class="keyword">if</span> (info.options &amp; JHKeyValueObservingOptionNew) &#123;</span><br><span class="line">&gt;                     [change setObject:newValue forKey:<span class="built_in">NSKeyValueChangeNewKey</span>];</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;                 <span class="comment">// 如果是旧值，在通知字典中设置旧值</span></span><br><span class="line">&gt;                 <span class="keyword">if</span> (info.options &amp; JHKeyValueObservingOptionOld) &#123;</span><br><span class="line">&gt;                     [change setObject:<span class="string">@""</span> forKey:<span class="built_in">NSKeyValueChangeOldKey</span>];</span><br><span class="line">&gt;                     <span class="keyword">if</span> (oldValue) &#123;</span><br><span class="line">&gt;                         [change setObject:oldValue forKey:<span class="built_in">NSKeyValueChangeOldKey</span>];</span><br><span class="line">&gt;                     &#125;</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;                 <span class="comment">// 取得通知观察者方法的 `SEL`</span></span><br><span class="line">&gt;                 SEL observerSEL = <span class="keyword">@selector</span>(jh_observeValueForKeyPath:ofObject:change:context:);</span><br><span class="line">&gt;                 <span class="comment">// 通过 `objc_msgSend` 手动发送消息，达到观察者收到回调的效果</span></span><br><span class="line">&gt;                 ((<span class="keyword">void</span>(*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>, <span class="keyword">id</span>, <span class="built_in">NSMutableDictionary</span> *, <span class="keyword">void</span> *))objc_msgSend)(info.observer, observerSEL, keyPath, <span class="keyword">self</span>, change, <span class="literal">NULL</span>);</span><br><span class="line">&gt;             &#125;);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><code>getterForSetter</code> 实现如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">static</span> <span class="built_in">NSString</span> *getterForSetter(<span class="built_in">NSString</span> *<span class="keyword">setter</span>)&#123;</span><br><span class="line">&gt;     <span class="comment">// 判断传入的 `setter` 字符串长度是否大于 0，以及是否有 `set` 的前缀和 `:` 的后缀</span></span><br><span class="line">&gt;     <span class="keyword">if</span> (<span class="keyword">setter</span>.length &lt;= <span class="number">0</span> || ![<span class="keyword">setter</span> hasPrefix:<span class="string">@"set"</span>] || ![<span class="keyword">setter</span> hasSuffix:<span class="string">@":"</span>]) &#123; <span class="keyword">return</span> <span class="literal">nil</span>;&#125;</span><br><span class="line">&gt;     <span class="comment">// 排除掉 `setter` 字符串中的 `set:` 部分以取得 getter 字符串</span></span><br><span class="line">&gt;     <span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(<span class="number">3</span>, <span class="keyword">setter</span>.length<span class="number">-4</span>);</span><br><span class="line">&gt;     <span class="built_in">NSString</span> *<span class="keyword">getter</span> = [<span class="keyword">setter</span> substringWithRange:range];</span><br><span class="line">&gt;     <span class="comment">// 对 getter 字符串首字母小写处理</span></span><br><span class="line">&gt;     <span class="built_in">NSString</span> *firstString = [[<span class="keyword">getter</span> substringToIndex:<span class="number">1</span>] lowercaseString];</span><br><span class="line">&gt;     <span class="keyword">return</span>  [<span class="keyword">getter</span> stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>) withString:firstString];</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<h2 id="3-2-自定义移除观察者"><a href="#3-2-自定义移除观察者" class="headerlink" title="3.2 自定义移除观察者"></a>3.2 自定义移除观察者</h2><p>我们接着开始自定义移除观察者，首先，我们需要把 <code>isa</code> 指回原来的类，然后需要对关联对象中存储的自定义对象数组对应的观察者移除掉。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)jh_removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从关联对象中取出数组</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *observerArr = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey));</span><br><span class="line">    <span class="comment">// 如果数组中没有内容，说明没有添加过观察者，那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (observerArr.count&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历取出的所有自定义对象</span></span><br><span class="line">    <span class="keyword">for</span> (JHKVOInfo *info <span class="keyword">in</span> observerArr) &#123;</span><br><span class="line">        <span class="comment">// 如果 `keyPath` 匹配上了 则从数组中移除响应对象，然后存储最新的数组到关联对象上</span></span><br><span class="line">        <span class="keyword">if</span> ([info.keyPath isEqualToString:keyPath]) &#123;</span><br><span class="line">            [observerArr removeObject:info];</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey), observerArr, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 要将 `isa` 指回原来的类的前提条件是，被观察属性的对象已经没有任何观察者在观察了，那么就需要指回去</span></span><br><span class="line">    <span class="keyword">if</span> (observerArr.count&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        Class superClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        object_setClass(<span class="keyword">self</span>, superClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-实现自动移除观察者"><a href="#3-3-实现自动移除观察者" class="headerlink" title="3.3 实现自动移除观察者"></a>3.3 实现自动移除观察者</h2><p>现在我们自定义的 <code>KVO</code> 已经可以实现简单的通知观察者新值和旧值的变化了，但其实对于 <code>api</code> 的使用者来说，还是要严格的执行 <code>addObserver</code> 和 <code>removeObserver</code> 的配套操作，难免有些繁琐。虽然一般来说为了方便起见，都是在观察者的 <code>dealloc</code> 方法中去手动调用 <code>removeObserver</code> 方法，但还是太麻烦了。因此，我们可以借助 <code>methodSwizzling</code> 的技术来替换默认 <code>dealloc</code> 方法的实现，直接上代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)jh_hookOrigInstanceMenthod:(SEL)oriSEL newInstanceMenthod:(SEL)swizzledSEL &#123;</span><br><span class="line">    <span class="comment">// 获取 Class 对象</span></span><br><span class="line">    Class cls = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 通过 `SEL` 获取原始方法</span></span><br><span class="line">    Method oriMethod = class_getInstanceMethod(cls, oriSEL);</span><br><span class="line">    <span class="comment">// 通过 `SEL` 获取要替换的方法</span></span><br><span class="line">    Method swiMethod = class_getInstanceMethod(cls, swizzledSEL);</span><br><span class="line">    <span class="comment">// 如果要替换的方法不存在，返回 NO</span></span><br><span class="line">    <span class="keyword">if</span> (!swiMethod) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果原始方法不存在，那么就直接在 Class 上添加要替换的方法，注意，添加的方法实现为要替换的方法，但是方法 `SEL` 还是原始方法的 `SEL`</span></span><br><span class="line">    <span class="keyword">if</span> (!oriMethod) &#123;</span><br><span class="line">        class_addMethod(cls, oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(swiMethod));</span><br><span class="line">        method_setImplementation(swiMethod, imp_implementationWithBlock(^(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)&#123; &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否添加成功</span></span><br><span class="line">    <span class="built_in">BOOL</span> didAddMethod = class_addMethod(cls, oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(swiMethod));</span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">    <span class="comment">// 如果成功，说明 Class 上已经存在了要替换的方法的实现，那么就把原始方法实现替换掉 `swizzledSEL` 对应的方法实现</span></span><br><span class="line">        class_replaceMethod(cls, swizzledSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 如果不成功，说明原始方法已经存在，则直接交换方法实现</span></span><br><span class="line">        method_exchangeImplementations(oriMethod, swiMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> jh_hookOrigInstanceMenthod:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"dealloc"</span>) newInstanceMenthod:<span class="keyword">@selector</span>(myDealloc)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)myDealloc&#123;</span><br><span class="line">    Class superClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">    object_setClass(<span class="keyword">self</span>, superClass);</span><br><span class="line">    <span class="comment">// 这里并不会造成循环引用的递归，因为 `myDealloc` 的方法实现是真正的原始 `dealloc`</span></span><br><span class="line">    [<span class="keyword">self</span> myDealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过实现自动移除观察者，<code>api</code> 的使用者可以完全放心的只使用 <code>addObserver</code> 来添加观察者以及 <code>observeValueForKeyPath</code> 来接收回调。</p>
<h2 id="3-4-函数式编程思想重构"><a href="#3-4-函数式编程思想重构" class="headerlink" title="3.4 函数式编程思想重构"></a>3.4 函数式编程思想重构</h2><p>我们虽然已经实现了自动的移除观察者，但是从函数式编程思想来看，现在的设计还不是很完美，对同一个属性的观察的代码散落在不同的地方，如果业务一旦增多，对于可读性和可维护性都有很大的影响。所以，我们可以把现在这种回调的形式重构为 <code>Block</code> 的方式。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSObject+JHBlockKVO.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^JHKVOBlock)(<span class="keyword">id</span> observer,<span class="built_in">NSString</span> *keyPath,<span class="keyword">id</span> oldValue,<span class="keyword">id</span> newValue);</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">JHBlockKVO</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)jh_addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath block:(JHKVOBlock)block;</span><br><span class="line">- (<span class="keyword">void</span>)jh_removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSObject+JHBlockKVO.m</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JHBlockKVOInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSObject</span>   *observer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>   *keyPath;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) JHKVOBlock  handleBlock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JHBlockKVOInfo</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWitObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath handleBlock:(JHKVOBlock)block&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>=[<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _observer = observer;</span><br><span class="line">        _keyPath  = keyPath;</span><br><span class="line">        _handleBlock = block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">JHBlockKVO</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)jh_addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath block:(JHKVOBlock)block&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.判断 getter 是否存在</span></span><br><span class="line">    SEL setterSelector = <span class="built_in">NSSelectorFromString</span>(setterForGetter(keyPath));</span><br><span class="line">    Method setterMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], setterSelector);</span><br><span class="line">    <span class="keyword">if</span> (!setterMethod) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *reason = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"对象 %@ 的 key %@ 没有 setter 实现"</span>, <span class="keyword">self</span>, keyPath];</span><br><span class="line">        <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInvalidArgumentException</span></span><br><span class="line">                                       reason:reason</span><br><span class="line">                                     userInfo:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.动态创建中间子类</span></span><br><span class="line">    Class newClass = [<span class="keyword">self</span> createChildClassWithKeyPath:keyPath];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.将对象的isa指向为新的中间子类</span></span><br><span class="line">    object_setClass(<span class="keyword">self</span>, newClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.保存观察者</span></span><br><span class="line">    JHBlockKVOInfo *info = [[JHBlockKVOInfo alloc] initWitObserver:observer forKeyPath:keyPath handleBlock:block];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mArray = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey));</span><br><span class="line">    <span class="keyword">if</span> (!mArray) &#123;</span><br><span class="line">        mArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">1</span>];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey), mArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    [mArray addObject:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们直接通过传入分类一个 <code>block</code>，然后存储在对应的自定义观察对象中，然后我们还需要在重写 <code>setter</code> 方法中做出修改，原来是直接通过发送消息来实现回调，现在需要改成 <code>block</code> 回调</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> jh_setter(<span class="keyword">id</span> <span class="keyword">self</span>,SEL _cmd,<span class="keyword">id</span> newValue)&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *keyPath = getterForSetter(<span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">    <span class="keyword">id</span> oldValue = [<span class="keyword">self</span> valueForKey:keyPath];</span><br><span class="line">    <span class="keyword">void</span> (*jh_msgSendSuper)(<span class="keyword">void</span> *,SEL , <span class="keyword">id</span>) = (<span class="keyword">void</span> *)objc_msgSendSuper;</span><br><span class="line">    <span class="keyword">struct</span> objc_super superStruct = &#123;</span><br><span class="line">        .receiver = <span class="keyword">self</span>,</span><br><span class="line">        .super_class = class_getSuperclass(object_getClass(<span class="keyword">self</span>)),</span><br><span class="line">    &#125;;</span><br><span class="line">    jh_msgSendSuper(&amp;superStruct,_cmd,newValue);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mArray = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey));</span><br><span class="line">    <span class="keyword">for</span> (JHBlockKVOInfo *info <span class="keyword">in</span> mArray) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([info.keyPath isEqualToString:keyPath] &amp;&amp; info.handleBlock) &#123;</span><br><span class="line">            info.handleBlock(info.observer, keyPath, oldValue, newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>经过探索 <code>KVC</code> 和 <code>KVO</code> 的底层，我们可以看到 <code>KVO</code> 是建立在 <code>KVC</code> 基础之上的。<code>KVO</code> 作为观察者设计模式在 <code>iOS</code> 中的具体落地，其原理到实现我们都探索完了。其实我们可以看出来在早期设计 <code>api</code> 的时候，原生的 <code>KVO</code> 其实并不好用，所以诸如 <code>FaceBook</code> 的库 <a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">KVOController</a> 会大受欢迎。当然本文的自定义 <code>KVO</code> 实现并不严谨，感兴趣的读者可以查看这两个代码库：</p>
<ul>
<li>根据原生的 <code>KVC</code> 和 <code>KVO</code> 反汇编而成 <a href="https://github.com/renjinkui2719/DIS_KVC_KVO" target="_blank" rel="noopener">DIS_KVC_KVO</a></li>
<li>开源的 <code>GNUStep</code> 的 <code>libs-base</code> <a href="https://github.com/gnustep/libs-base" target="_blank" rel="noopener">gnustep/libs-base</a></li>
</ul>
<p>我们的 <code>iOS</code> 底层探索系列接下来将会进入多线程篇章，敬请期待~</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA" target="_blank" rel="noopener">Key-Value Observing Programming Guide - Apple 官方文档 </a></p>
<p><a href="https://nshipster.cn/nil/" target="_blank" rel="noopener">nil/Nil/Null/NSNull - NSHipster</a></p>
<p><a href="https://nshipster.cn/key-value-observing/" target="_blank" rel="noopener">Key-Value Observing - NSHipster</a></p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    leejunhui
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://leejunhui.com/2020/02/19/iOS-底层探索-KVO/" title="iOS 底层探索 - KVO">http://leejunhui.com/2020/02/19/iOS-底层探索-KVO/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/Objective-C/" rel="tag"># Objective-C</a>
          
            <a href="/tags/KVO/" rel="tag"># KVO</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/15/iOS-底层探索-KVC/" rel="next" title="iOS 底层探索 - KVC">
                <i class="fa fa-chevron-left"></i> iOS 底层探索 - KVC
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">leejunhui</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、KVO-初探"><span class="nav-number">1.</span> <span class="nav-text">一、KVO 初探</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-什么是-KVO"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 什么是 KVO?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-KVO-三大流程解析"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 KVO 三大流程解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-观察者注册"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 观察者注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-观察者接收通知"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 观察者接收通知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-取消注册"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3 取消注册</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-“自动挡”-和-“手动挡”"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 “自动挡” 和 “手动挡”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-注册从属关系的-KVO"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 注册从属关系的 KVO</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、KVO-原理探究"><span class="nav-number">2.</span> <span class="nav-text">二、KVO 原理探究</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-中间类"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 中间类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-KVO-观察的是什么？"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 KVO 观察的是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-中间类重写了哪些方法？"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 中间类重写了哪些方法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-KVO-中间类何时指回去？"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 KVO 中间类何时指回去？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-KVO-调用顺序"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 KVO 调用顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、自定义-KVO-如何实现"><span class="nav-number">3.</span> <span class="nav-text">三、自定义 KVO 如何实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-自定义观察者注册"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 自定义观察者注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-自定义移除观察者"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 自定义移除观察者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-实现自动移除观察者"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 实现自动移除观察者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-函数式编程思想重构"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 函数式编程思想重构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、总结"><span class="nav-number">4.</span> <span class="nav-text">四、总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">5.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leejunhui</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
