<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS,Objective-C,RunLoop,">





  <link rel="alternate" href="/atom.xml" title="leejunhui's blog" type="application/atom+xml">






<meta name="description" content="RunLoop 在 0202 年的今天其实已经不是个新鲜的话题了，关于这方面的文章网上有很多大神总结得非常精辟。 作为 iOS 查漏补缺系列，这篇文章是笔者探索 RunLoop 底层的一些知识点总结，同时也借鉴了网上一些优秀的 RunLoop 技术文章的内容。 本文内容如有错误，欢迎指正。">
<meta name="keywords" content="iOS,Objective-C,RunLoop">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 查漏补缺 - RunLoop">
<meta property="og:url" content="http://leejunhui.com/2020/03/16/iOS-查漏补缺-RunLoop/index.html">
<meta property="og:site_name" content="leejunhui&#39;s blog">
<meta property="og:description" content="RunLoop 在 0202 年的今天其实已经不是个新鲜的话题了，关于这方面的文章网上有很多大神总结得非常精辟。 作为 iOS 查漏补缺系列，这篇文章是笔者探索 RunLoop 底层的一些知识点总结，同时也借鉴了网上一些优秀的 RunLoop 技术文章的内容。 本文内容如有错误，欢迎指正。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200316102159.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200316102205.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200316102208.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200316102155.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200316102211.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200316102217.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200316102221.jpg">
<meta property="og:updated_time" content="2020-03-16T02:25:08.187Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS 查漏补缺 - RunLoop">
<meta name="twitter:description" content="RunLoop 在 0202 年的今天其实已经不是个新鲜的话题了，关于这方面的文章网上有很多大神总结得非常精辟。 作为 iOS 查漏补缺系列，这篇文章是笔者探索 RunLoop 底层的一些知识点总结，同时也借鉴了网上一些优秀的 RunLoop 技术文章的内容。 本文内容如有错误，欢迎指正。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200316102159.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://leejunhui.com/2020/03/16/iOS-查漏补缺-RunLoop/">





  <title>iOS 查漏补缺 - RunLoop | leejunhui's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">leejunhui's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://leejunhui.com/2020/03/16/iOS-查漏补缺-RunLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="leejunhui">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leejunhui's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS 查漏补缺 - RunLoop</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-16T10:20:29+08:00">
                2020-03-16
              </time>
            

            

            
          </span>
          
          <span class="post-updated">
            &nbsp; | &nbsp; 更新于
            <time itemprop="dateUpdated" datetime="2020-03-16T10:25:08+08:00" content="2020-03-16">
              2020-03-16
            </time>
          </span>
          

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-查漏补缺/" itemprop="url" rel="index">
                    <span itemprop="name">iOS 查漏补缺</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><code>RunLoop</code> 在 0202 年的今天其实已经不是个新鲜的话题了，关于这方面的文章网上有很多大神总结得非常精辟。</p>
<p>作为 <code>iOS</code> 查漏补缺系列，这篇文章是笔者探索 <code>RunLoop</code> 底层的一些知识点总结，同时也借鉴了网上一些优秀的 <code>RunLoop</code> 技术文章的内容。</p>
<p>本文内容如有错误，欢迎指正。</p>
<a id="more"></a>
<h1 id="RunLoop-前导知识"><a href="#RunLoop-前导知识" class="headerlink" title="RunLoop 前导知识"></a>RunLoop 前导知识</h1><h2 id="iOS-OS-X-系统架构"><a href="#iOS-OS-X-系统架构" class="headerlink" title="iOS/OS X 系统架构"></a>iOS/OS X 系统架构</h2><h3 id="iOS-进化史"><a href="#iOS-进化史" class="headerlink" title="iOS 进化史"></a>iOS 进化史</h3><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200316102159.jpg" alt="iOS Evolutionary history "></p>
<blockquote>
<p>Mac OS Classic 拥有伟大的 GUI，但系统设计却非常糟糕，尤其是协作式的多任务系统和低效的内存管理，以今天的标准看非常原始。</p>
<p>NeXTSTEP 操作系统作为乔布斯回归苹果的嫁妆，连同架构中的 Mach 和 OC 等一起融合进了Mac OS Classic。与其说是 Mac OS Classic 融合了 NeXTSTEP，不如说是后者反客为主替换了前者，这个转变并不是一瞬间发生的。</p>
<p>Mac OS Classic 拥有不错的 GUI 但系统设计糟糕，NeXTSTEP 设计很棒，但 GUI 非常平淡。这两个小众操作系统融合的结果是一个继承二者优点的成功得多的全新操作系统—Mac OS X</p>
<p>全新的 Mac OS X 在设计与实现上都同 NeXTSTEP 非常接近，诸如 Cocoa、Mach 、Interface Builder 等核心组件都源自 NeXTSTEP</p>
<p>iOS 最初称为 iPhone OS,是 Mac OS X 应对移动平台的分支，iOS 拥有和 <code>Mac OS X</code>一样的操作系统层次结构以及相同的操作系统核心Dawin。</p>
</blockquote>
<h3 id="iOS-系统架构"><a href="#iOS-系统架构" class="headerlink" title="iOS 系统架构"></a>iOS 系统架构</h3><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200316102205.jpg" alt="iOS System Architecture"></p>
<blockquote>
<p>苹果官方将整个系统大致划分为上述4个层次：</p>
<p>应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua(macOS)、SpringBoard(iOS) 等。</p>
<p>应用框架层即开发人员接触到的 Cocoa 等框架。</p>
<p>核心框架层包括各种核心框架、OpenGL 等内容。</p>
<p>Darwin层是操作系统核心，包括 XNU 内核(2017 年已开源)、驱动和 UNIX shell</p>
</blockquote>
<h3 id="Darwin-架构"><a href="#Darwin-架构" class="headerlink" title="Darwin 架构"></a>Darwin 架构</h3><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200316102208.jpg" alt="Darwin Architecture"></p>
<blockquote>
<p>Darwin 的内核是 XNU，XNU is Not Unix。XNU 是两种技术的混合体，Mach和BSD。BSD 层确保了 Darwin 系统的 UNIX 特性，真正的内核是 Mach，但是对外部隐藏。BSD 以上属于用户态，所有的内容都可以被应用程序访问，而应用程序不能访问内核态。当需要从用户态切换到内核态的时候，需要通过 mach trap 实现切换。</p>
<p>—《深入解析Mac OS X &amp; iOS 操作系统》</p>
</blockquote>
<blockquote>
<p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。</p>
<p>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。</p>
<p>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。</p>
<p>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>
<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。<br>在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。<br>和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。<br>”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>
<p>— 《深入理解RunLoop》ibireme</p>
</blockquote>
<h2 id="mach-msg-函数"><a href="#mach-msg-函数" class="headerlink" title="mach_msg 函数"></a>mach_msg 函数</h2><p><code>mach_msg</code> 函数位于 <code>mach</code> 内核的 <code>message.h</code> 头文件中</p>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200316102155.jpg" alt="-w525"></p>
<blockquote>
<p>这是系统内核在某个 port 收发消息所使用的函数，理解这个函数对于理解 runloop 的运行机制非常重要。</p>
<p>详细的说明可参考 <a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_msg.html" target="_blank" rel="noopener">这里</a>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mach 消息基础结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="comment">// 消息头部</span></span><br><span class="line">	<span class="keyword">mach_msg_header_t</span>       header;</span><br><span class="line">	<span class="comment">// 消息体</span></span><br><span class="line">	<span class="keyword">mach_msg_body_t</span>         body;</span><br><span class="line">&#125; <span class="keyword">mach_msg_base_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mach 消息头结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="comment">// 消息头的 bits</span></span><br><span class="line">	<span class="keyword">mach_msg_bits_t</span>       msgh_bits;</span><br><span class="line">	<span class="comment">// 消息头的大小</span></span><br><span class="line">	<span class="keyword">mach_msg_size_t</span>       msgh_size;</span><br><span class="line">	<span class="comment">// 远程端口号</span></span><br><span class="line">	<span class="keyword">mach_port_t</span>           msgh_remote_port;</span><br><span class="line">	<span class="comment">// 本地端口号</span></span><br><span class="line">	<span class="keyword">mach_port_t</span>           msgh_local_port;</span><br><span class="line">	<span class="comment">// 凭证端口号</span></span><br><span class="line">	<span class="keyword">mach_port_name_t</span>      msgh_voucher_port;</span><br><span class="line">	<span class="comment">// 消息ID</span></span><br><span class="line">	<span class="keyword">mach_msg_id_t</span>         msgh_id;</span><br><span class="line">&#125; <span class="keyword">mach_msg_header_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mach_msg 函数</span></span><br><span class="line"><span class="keyword">mach_msg_return_t</span> mach_msg(</span><br><span class="line">    <span class="comment">// 消息头</span></span><br><span class="line">    <span class="keyword">mach_msg_header_t</span> *msg,</span><br><span class="line">    <span class="comment">// 消息选项，可用来指定是发消息(MACH_SEND_MSG)还是收消息(MACH_RCV_MSG)</span></span><br><span class="line">    <span class="keyword">mach_msg_option_t</span> option,</span><br><span class="line">    <span class="comment">// 发消息时设置的缓存区大小，无符号整型</span></span><br><span class="line">    <span class="keyword">mach_msg_size_t</span> send_size,</span><br><span class="line">    <span class="comment">// 收消息时设置的缓存区大小，无符号整型</span></span><br><span class="line">    <span class="keyword">mach_msg_size_t</span> rcv_size,</span><br><span class="line">    <span class="comment">// 收消息的端口，无符号整型</span></span><br><span class="line">    <span class="keyword">mach_port_name_t</span> rcv_name,</span><br><span class="line">    <span class="comment">// 消息过期时间</span></span><br><span class="line">    <span class="comment">// 当 option 参数中包含 MACH_SEND_TIMEOUT 或 MACH_RCV_TIMEOUT 的时候，传入以毫秒单位的过期时间</span></span><br><span class="line">    <span class="keyword">mach_msg_timeout_t</span> timeout,</span><br><span class="line">    <span class="comment">// 接收通知的端口</span></span><br><span class="line">    <span class="comment">// 当 option 参数中包含 MACH_SEND_CANCEL 和 MACH_RCV_NOTIFY 时，设置接收通知的端口；否则，传入 MACH_PORT_NULL。</span></span><br><span class="line">    <span class="keyword">mach_port_name_t</span> notify);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以简单的将 mach_msg 理解为<strong>多进程之间的一种通信机制</strong>，不同的进程可以使用<strong>同一个消息队列</strong>来交流数据，当使用 mach_msg 从消息队列里读取 msg 时，可以在参数中设置 timeout 值，在 timeout 之前如果没有读到 msg，当前线程会一直处于休眠状态。这也是 runloop 在没有任务可执行的时候，能够进入 sleep 状态的原因。</p>
<p>— 《解密 Runloop》MrPeak</p>
</blockquote>
<p>–</p>
<blockquote>
<p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数 mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作。</p>
<p>— 《深入理解RunLoop》ibireme</p>
</blockquote>
<h2 id="CoreFoundation-基础"><a href="#CoreFoundation-基础" class="headerlink" title="CoreFoundation 基础"></a>CoreFoundation 基础</h2><p>CoreFoundation 是一套基于 <code>C</code> 的 <code>API</code>，为 <code>iOS</code> 提供了基本数据管理和服务功能。因为 CoreFoundation 对象是基于 C 实现的，也有引用计数的概念，而 Foundation 对象是基于 OC 实现的。两种对象在相互转换的时候需要用到三个关键字: <strong>bridge、</strong>bridge_retained、__bridge_transfer，下面进行简单的介绍。</p>
<h3 id="bridge"><a href="#bridge" class="headerlink" title="__bridge"></a>__bridge</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> *p = (__bridge <span class="keyword">void</span> *)obj;</span><br><span class="line"><span class="keyword">id</span> o = (__bridge <span class="keyword">id</span>)p;</span><br></pre></td></tr></table></figure>

<p>将 Objective-C 的对象类型用 __bridge 转换为 void* 类型和使用 __unsafe_unretained 关键字修饰的变量是一样的。</p>
<blockquote>
<p>__bridge: 只做类型转换，不修改相关对象的引用计数，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法</p>
</blockquote>
<h3 id="bridge-retained"><a href="#bridge-retained" class="headerlink" title="__bridge_retained"></a>__bridge_retained</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d obj = [[<span class="built_in">NSObject</span> alloc] init]; </span><br><span class="line"><span class="keyword">void</span> *p = (__bridge_retained <span class="keyword">void</span> *)obj;</span><br></pre></td></tr></table></figure>

<p>从名字上我们应该能理解其意义：类型被转换时，其对象的所有权也将被变换后变量所持有。<br>如果是 MRC 中:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> *p = obj;</span><br><span class="line">[(<span class="keyword">id</span>)p <span class="keyword">retain</span>];</span><br></pre></td></tr></table></figure>

<p>下面的例子验证了出了大括号的范围后，p 仍然指向一个有效的实体。说明她拥有该对象的所有权，该对象没有因为出其定义范围而被销毁。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = <span class="number">0</span>;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"> p = (__bridge_retained <span class="keyword">void</span> *)obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [(__bridge <span class="keyword">id</span>)p <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>__bridge_retained: 类型转换后，将相关对象的引用计数加 1，原来的 Core Foundation 对象在不用时，需要调用 CFRelease 方法</p>
</blockquote>
<h3 id="bridge-transfer"><a href="#bridge-transfer" class="headerlink" title="__bridge_transfer"></a>__bridge_transfer</h3><p>MRC 中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 变量原先持有对象的所有权</span></span><br><span class="line"><span class="keyword">id</span> obj = (<span class="keyword">id</span>)p;</span><br><span class="line">[obj <span class="keyword">retain</span>];</span><br><span class="line">[(<span class="keyword">id</span>)p release];</span><br></pre></td></tr></table></figure>

<p>ARC 中:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 变量原先持有对象的所有权</span></span><br><span class="line"><span class="keyword">id</span> obj = (__bridge_transfer <span class="keyword">id</span>)p;</span><br></pre></td></tr></table></figure>

<p>可以看出来，__bridge_retained 是编译器替我们做了 retain 操作，而 __bridge_transfer 是替我们做了 release。</p>
<blockquote>
<p>__bridge_transfer: 类型转换后，将该对象的引用计数交给 ARC 管理，Core Foundation 对象在不用时，不需要调用 CFRelease 方法</p>
</blockquote>
<h3 id="Toll-Free-bridged"><a href="#Toll-Free-bridged" class="headerlink" title="Toll-Free bridged"></a>Toll-Free bridged</h3><p>CoreFoundation 和 Foundation 之间有一个 <code>Toll-free bridging</code> 机制。<br>在 MRC 时代，可以直接通过类型强转完成两个框架对象的类型转换。但是在 ARC 时代，则需要使用 <code>Toll-free bridging</code> 机制提供的方法来操作。上面已经介绍了三种不同的转换机制，而实际上在 Foundation 中，有更简便的方法来操作。如下所示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// After using a CFBridgingRetain on an NSObject, the caller must take responsibility for calling CFRelease at an appropriate time.</span></span><br><span class="line"><span class="built_in">NS_INLINE</span> <span class="built_in">CF_RETURNS_RETAINED</span> <span class="built_in">CFTypeRef</span> _Nullable <span class="built_in">CFBridgingRetain</span>(<span class="keyword">id</span> _Nullable X) &#123;</span><br><span class="line">    <span class="keyword">return</span> (__bridge_retained <span class="built_in">CFTypeRef</span>)X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_INLINE</span> <span class="keyword">id</span> _Nullable <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CFTypeRef</span> <span class="built_in">CF_CONSUMED</span> _Nullable X) &#123;</span><br><span class="line">    <span class="keyword">return</span> (__bridge_transfer <span class="keyword">id</span>)X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CFBridgingRetain 可以代替 __bridge_retained，CFBridgingRelease 可以代替 __bridge_transfer。</p>
<h1 id="RunLoop-初探"><a href="#RunLoop-初探" class="headerlink" title="RunLoop 初探"></a>RunLoop 初探</h1><h2 id="什么是-RunLoop"><a href="#什么是-RunLoop" class="headerlink" title="什么是 RunLoop"></a>什么是 RunLoop</h2><p>根据<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="noopener">苹果官方文档</a>的定义</p>
<blockquote>
<p>Run loops are part of the fundamental infrastructure associated with threads.</p>
<p>RunLoop 是与线程相关的基础结构。</p>
</blockquote>
<blockquote>
<p>A run loop is an event processing loop that you use to schedule work and coordinate the receipt of incoming events. The purpose of a run loop is to keep your thread busy when there is work to do and put your thread to sleep when there is none.</p>
<p>RunLoop 是一个调度任务和处理事件的事件循环。其意义在于让线程有事做的时候繁忙起来，没事做的时候休眠。</p>
</blockquote>
<p>了解过 <code>NodeJS</code> 事件循环机制的同学应该不会对 <code>事件循环</code> 这一名词陌生，用伪代码实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(AppIsRunning) &#123;</span><br><span class="line">    id whoWakesMe = SleepForWakingUp();</span><br><span class="line">    id event = GetEvent(whoWakesMe);</span><br><span class="line">    HandleEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这份伪代码来自 <a href="http://blog.sunnyxx.com/" target="_blank" rel="noopener">sunnyx</a> 大神的 RunLoop 技术分享</p>
</blockquote>
<p>可以看到，RunLoop 就是这么一个简单的工作原理。但是其内部实现要比上面的代码复杂得多。我们下一节将深入 RunLoop 底层一探究竟。</p>
<blockquote>
<p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。</p>
</blockquote>
<p>CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。</p>
<blockquote>
<p>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200316102211.jpg" alt="NSRunLoop And CFRunLoop"></p>
<h2 id="RunLoop-底层数据结构"><a href="#RunLoop-底层数据结构" class="headerlink" title="RunLoop 底层数据结构"></a>RunLoop 底层数据结构</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200316102217.jpg" alt="RunLoop"></p>
<p>如上图所示，每一个 RunLoop 内部有多个 mode，而每一个 mode 内部有 sources0，source1, observers 和 timers。mode 中的元素统称为 <code>mode item</code>。下面我们一起回顾下这五个类的数据结构定义:</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<h3 id="CFRunLoopRef"><a href="#CFRunLoopRef" class="headerlink" title="CFRunLoopRef"></a>CFRunLoopRef</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> * <span class="title">CFRunLoopRef</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// CoreFoundation 中的 runtime 基础信息</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="comment">// 针对获取 mode 列表操作的锁</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock; <span class="comment">/* locked for accessing mode list */</span></span><br><span class="line">    <span class="comment">// 唤醒端口</span></span><br><span class="line">    __CFPort _wakeUpPort;  <span class="comment">// used for CFRunLoopWakeUp</span></span><br><span class="line">    <span class="comment">// 是否使用过</span></span><br><span class="line">    Boolean _unused;</span><br><span class="line">    <span class="comment">// runloop 运行会重置的一个数据结构</span></span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *_perRunData; <span class="comment">// reset for runs of the run loop</span></span><br><span class="line">    <span class="comment">// runloop 所对应线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> _pthread;</span><br><span class="line">    <span class="keyword">uint32_t</span> _winthread;</span><br><span class="line">    <span class="comment">// 存放 common mode 的集合</span></span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    <span class="comment">// 存放 common mode item 的集合</span></span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    <span class="comment">// runloop 当前所在 mode</span></span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    <span class="comment">// 存放 mode 的集合</span></span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// runloop 内部 block 链表表头指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_head</span>;</span></span><br><span class="line">    <span class="comment">// runloop 内部 block 链表表尾指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_tail</span>;</span></span><br><span class="line">    <span class="comment">// 运行时间点</span></span><br><span class="line">    CFAbsoluteTime _runTime;</span><br><span class="line">    <span class="comment">// 休眠时间点</span></span><br><span class="line">    CFAbsoluteTime _sleepTime;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次 RunLoop 运行后会重置</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">per_run_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> a;</span><br><span class="line">    <span class="keyword">uint32_t</span> b;</span><br><span class="line">    <span class="keyword">uint32_t</span> stopped;   <span class="comment">// runloop 是否停止</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ignoreWakeUps; <span class="comment">// runloop 是否已唤醒</span></span><br><span class="line">&#125; _per_run_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 指向下一个 _block_item</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 要么是 string 类型，要么是集合类型，也就是说一个 block 可能对应单个或多个 mode</span></span><br><span class="line">    CFTypeRef _mode; <span class="comment">// CFString or CFSet</span></span><br><span class="line">    <span class="comment">// 存放的真正要执行的 block</span></span><br><span class="line">    <span class="keyword">void</span> (^_block)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以看出，CFRunLoopRef 其实是一个 <code>__CFRunLoop</code> 类型的结构体指针。<code>__CFRunLoop</code> 内部以下属性需要重点关注:</p>
<ul>
<li><code>_pthread</code></li>
<li><code>_commonModes</code></li>
<li><code>_currentMode</code></li>
<li><code>_modes</code></li>
</ul>
<h3 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> *<span class="title">CFRunLoopModeRef</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// CoreFoundation 中的 runtime 基础信息</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="comment">// 互斥锁，加锁前需要 runloop 先加锁</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock; <span class="comment">/* must have the run loop locked before locking this */</span></span><br><span class="line">    <span class="comment">// mode 的名称</span></span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    <span class="comment">// mode 是否停止</span></span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    <span class="keyword">char</span> _padding[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// source0</span></span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    <span class="comment">// source1</span></span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    <span class="comment">// observers</span></span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    <span class="comment">// timers</span></span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">    <span class="comment">// port 的集合</span></span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    <span class="comment">// observer 的 mask</span></span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line">    <span class="comment">// 如果定义了 GCD 定时器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    <span class="comment">// GCD 定时器</span></span><br><span class="line">    <span class="keyword">dispatch_source_t</span> _timerSource;</span><br><span class="line">    <span class="comment">// 队列</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> _queue;</span><br><span class="line">    <span class="comment">// 当 GCD 定时器触发时设置为 true</span></span><br><span class="line">    Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// 如果使用 MK_TIMER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">    <span class="comment">// MK_TIMER 的 port</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    <span class="keyword">void</span> (*_msgPump)(<span class="keyword">void</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 定时器软临界点</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerSoftDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">    <span class="comment">// 定时器硬临界点</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerHardDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以看出，CFRunLoopModeRef 其实是一个 <code>__CFRunLoopMode</code> 类型的结构体指针。<br><code>__CFRunLoopMode</code> 内部以下属性需要重点关注:</p>
<ul>
<li><code>_sources0</code></li>
<li><code>_sources1</code></li>
<li><code>_observers</code></li>
<li><code>_timers</code></li>
</ul>
<h3 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopSource</span> * <span class="title">CFRunLoopSourceRef</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopSource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// CoreFoundation 中的 runtime 基础信息</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">uint32_t</span> _bits;</span><br><span class="line">    <span class="comment">// 互斥锁</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</span><br><span class="line">    <span class="comment">// source 的优先级，值为小，优先级越高</span></span><br><span class="line">    CFIndex _order; <span class="comment">/* immutable */</span></span><br><span class="line">    <span class="comment">// runloop 集合</span></span><br><span class="line">    CFMutableBagRef _runLoops;</span><br><span class="line">    <span class="comment">// 一个联合体，说明 source 要么为 source0，要么为 source1</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        CFRunLoopSourceContext version0;  <span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">        CFRunLoopSourceContext1 version1; <span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">    &#125; _context;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CFIndex version;</span><br><span class="line">    <span class="comment">// source 的信息</span></span><br><span class="line">    <span class="keyword">void</span> *  info;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>    (*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    CFStringRef (*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="comment">// 判断 source 相等的函数</span></span><br><span class="line">    Boolean (*equal)(<span class="keyword">const</span> <span class="keyword">void</span> *info1, <span class="keyword">const</span> <span class="keyword">void</span> *info2);</span><br><span class="line">    CFHashCode  (*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>    (*schedule)(<span class="keyword">void</span> *info, CFRunLoopRef rl, CFStringRef mode);</span><br><span class="line">    <span class="keyword">void</span>    (*cancel)(<span class="keyword">void</span> *info, CFRunLoopRef rl, CFStringRef mode);</span><br><span class="line">    <span class="comment">// source 要执行的任务块</span></span><br><span class="line">    <span class="keyword">void</span>    (*perform)(<span class="keyword">void</span> *info);</span><br><span class="line">&#125; CFRunLoopSourceContext;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以看出，CFRunLoopSourceRef 其实是一个 <code>__CFRunLoopSource</code> 类型的结构体指针。<br><code>__CFRunLoopSource</code> 的结构相对来说要简单一点，有几个属性要重点关注：</p>
<ul>
<li><code>_order</code></li>
<li><code>_context</code></li>
<li><code>CFRunLoopSourceContext</code> 下的 <code>perform</code> 函数指针</li>
</ul>
<h3 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">CF_BRIDGED_MUTABLE_TYPE</span><span class="params">(NSTimer)</span> __CFRunLoopTimer * CFRunLoopTimerRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopTimer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// CoreFoundation 中的 runtime 基础信息</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">uint16_t</span> _bits;</span><br><span class="line">    <span class="comment">// 互斥锁</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</span><br><span class="line">    <span class="comment">// timer 对应的 runloop</span></span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    <span class="comment">// timer 对应的 mode 集合</span></span><br><span class="line">    CFMutableSetRef _rlModes;</span><br><span class="line">    <span class="comment">// 下一次触发时间点</span></span><br><span class="line">    CFAbsoluteTime _nextFireDate;</span><br><span class="line">    <span class="comment">// 定时器每次任务的间隔</span></span><br><span class="line">    CFTimeInterval _interval;        <span class="comment">/* immutable */</span></span><br><span class="line">    <span class="comment">// 定时器所允许的误差</span></span><br><span class="line">    CFTimeInterval _tolerance;       <span class="comment">/* mutable */</span></span><br><span class="line">    <span class="comment">// 触发时间点</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _fireTSR;               <span class="comment">/* TSR units */</span></span><br><span class="line">    <span class="comment">// 定时器的优先级</span></span><br><span class="line">    CFIndex _order;                  <span class="comment">/* immutable */</span></span><br><span class="line">    <span class="comment">// 定时器所要执行的任务</span></span><br><span class="line">    CFRunLoopTimerCallBack _callout; <span class="comment">/* immutable */</span></span><br><span class="line">    <span class="comment">// 定时器上下文</span></span><br><span class="line">    CFRunLoopTimerContext _context;  <span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CFIndex	version;</span><br><span class="line">    <span class="keyword">void</span> *	info;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    CFStringRef	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">&#125; CFRunLoopTimerContext;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*CFRunLoopTimerCallBack)</span><span class="params">(CFRunLoopTimerRef timer, <span class="keyword">void</span> *info)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以看出，CFRunLoopTimerRef 其实是一个 <code>__CFRunLoopTimer</code> 类型的结构体指针，并且这里 <code>__CFRunLoopTimer</code> 在前面还有一个 <code>CF_BRIDGED_MUTABLE_TYPE(NSTimer)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CF_BRIDGED_TYPE(T)		__attribute__((objc_bridge(T)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CF_BRIDGED_MUTABLE_TYPE(T)	__attribute__((objc_bridge_mutable(T)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CF_RELATED_TYPE(T,C,I)		__attribute__((objc_bridge_related(T,C,I)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CF_BRIDGED_TYPE(T)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CF_BRIDGED_MUTABLE_TYPE(T)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CF_RELATED_TYPE(T,C,I)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>从这里说明 <code>CFRunLoopTimerRef</code> 与 <code>NSTimer</code> 是 <code>toll-free bridged</code> 的。</p>
<p><code>__CFRunLoopTimer</code> 中有几个属性需要重点关注:</p>
<ul>
<li>_order</li>
<li>_callout</li>
<li>_context</li>
</ul>
<h3 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopObserver</span> * <span class="title">CFRunLoopObserverRef</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopObserver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// CoreFoundation 中的 runtime 基础信息</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="comment">// 互斥锁</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</span><br><span class="line">    <span class="comment">// observer 对应的 runloop</span></span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    <span class="comment">// observer 观察了多少个 runloop</span></span><br><span class="line">    CFIndex _rlCount;</span><br><span class="line">    CFOptionFlags _activities;          <span class="comment">/* immutable */</span></span><br><span class="line">    <span class="comment">// observer 优先级</span></span><br><span class="line">    CFIndex _order;                     <span class="comment">/* immutable */</span></span><br><span class="line">    <span class="comment">// observer 回调函数</span></span><br><span class="line">    CFRunLoopObserverCallBack _callout; <span class="comment">/* immutable */</span></span><br><span class="line">    <span class="comment">// observer 上下文</span></span><br><span class="line">    CFRunLoopObserverContext _context;  <span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CFIndex	version;</span><br><span class="line">    <span class="keyword">void</span> *	info;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *(*retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="keyword">void</span>	(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    CFStringRef	(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">&#125; CFRunLoopObserverContext;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*CFRunLoopObserverCallBack)</span><span class="params">(CFRunLoopObserverRef observer, CFRunLoopActivity activity, <span class="keyword">void</span> *info)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以看出，CFRunLoopObserverRef 其实是一个 <code>__CFRunLoopObserver</code> 类型的结构体指针。</p>
<p><code>__CFRunLoopObserver</code> 中有几个属性需要重点关注:</p>
<ul>
<li>_order</li>
<li>_callout</li>
<li>_context</li>
</ul>
<h3 id="CFRunLoopActivity"><a href="#CFRunLoopActivity" class="headerlink" title="CFRunLoopActivity"></a>CFRunLoopActivity</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),</span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>),</span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>),</span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>),</span><br><span class="line">    kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>),</span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过上面的源码可知，RunLoop 有以下状态</p>
<ul>
<li>kCFRunLoopEntry: 即将进入 Loop</li>
<li>kCFRunLoopBeforeTimers: 即将处理 Timer</li>
<li>kCFRunLoopBeforeSources: 即将处理 Source</li>
<li>kCFRunLoopBeforeWaiting: 即将进入休眠</li>
<li>kCFRunLoopAfterWaiting: 刚从休眠中唤醒</li>
<li>kCFRunLoopExit: 即将推出 Loop</li>
</ul>
<h2 id="RunLoop-与线程关系"><a href="#RunLoop-与线程关系" class="headerlink" title="RunLoop 与线程关系"></a>RunLoop 与线程关系</h2><p>要想搞清楚 RunLoop 与线程的关系，我们从 <code>CFRunLoopGetMain</code> 和 <code>CFRunLoopGetCurrent</code> 函数开始研究:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="comment">// 声明一个空的 RunLoop </span></span><br><span class="line">    <span class="keyword">static</span> CFRunLoopRef __main = <span class="literal">NULL</span>; <span class="comment">// no retain needed</span></span><br><span class="line">    <span class="comment">// 如果 __main 为空，则调用 _CFRunLoopGet0 函数来获取 RunLoop</span></span><br><span class="line">    <span class="keyword">if</span> (!__main)</span><br><span class="line">        __main = _CFRunLoopGet0(pthread_main_thread_np()); <span class="comment">// no CAS needed</span></span><br><span class="line">    <span class="keyword">return</span> __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="comment">// 从 线程的 TSD(Thread Specific Data) 中获取 runloop</span></span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    <span class="comment">// 如果拿到了就返回</span></span><br><span class="line">    <span class="keyword">if</span> (rl)</span><br><span class="line">        <span class="keyword">return</span> rl;</span><br><span class="line">    <span class="comment">// 如果在 TSD 中没有，那么就调用 _CFRunLoopGet0 函数</span></span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>pthread_main_thread_np()</code> 获取的是主线程，其内部实现如下</p>
</blockquote>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">define</span> pthread_main_thread_np() _CF_pthread_main_thread_np()</span></span><br><span class="line"></span><br><span class="line">&gt;CF_EXPORT <span class="keyword">pthread_t</span> _CF_pthread_main_thread_np(<span class="keyword">void</span>);</span><br><span class="line">&gt;<span class="keyword">pthread_t</span> _CF_pthread_main_thread_np(<span class="keyword">void</span>) &#123;</span><br><span class="line">&gt;    <span class="keyword">return</span> _CFMainPThread;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">void</span> __CFInitialize(<span class="keyword">void</span>) &#123;</span><br><span class="line"> &gt;   ...</span><br><span class="line">    </span><br><span class="line"> &gt;   _CFMainPThread = pthread_self();</span><br><span class="line">    </span><br><span class="line"> &gt;  ...</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们接着探索 <code>_CFRunLoopGet0</code> 函数，其实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储了 runloop 与线程的字典</span></span><br><span class="line"><span class="keyword">static</span> CFMutableDictionaryRef __CFRunLoops = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> CFLock_t loopsLock = CFLockInit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// should only be called by Foundation</span></span><br><span class="line"><span class="comment">// t==0 is a synonym for "main thread" that always works</span></span><br><span class="line"><span class="comment">// t为0的话，表示是要获取 主线程对应的 RunLoop</span></span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(<span class="keyword">pthread_t</span> t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果传入的现场为空，则再通过 pthread_main_thread_np() 获取到主线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT))</span><br><span class="line">    &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    __CFLock(&amp;loopsLock);</span><br><span class="line">    <span class="comment">// 如果 __CFRunLoops 字典为空，则初始化字典，并把 mainLoop 加入字典</span></span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">        <span class="comment">// 初始化一个 可变字典</span></span><br><span class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        <span class="comment">// 拿到主线程对应的 RunLoop</span></span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        <span class="comment">// 将 runloop 和 线程存入字典中，线程为 key，runloop 为 value</span></span><br><span class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">        <span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, dict, (<span class="keyword">void</span> *<span class="keyword">volatile</span> *)&amp;__CFRunLoops))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 释放 字典</span></span><br><span class="line">            CFRelease(dict);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放 mainLoop</span></span><br><span class="line">        CFRelease(mainLoop);</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据传入的 线程 t 从字典中获取 loop 对象</span></span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    <span class="comment">// 对 loops 字典解锁</span></span><br><span class="line">    __CFUnlock(&amp;loopsLock);</span><br><span class="line">    <span class="comment">// 如果 loop 为空</span></span><br><span class="line">    <span class="keyword">if</span> (!loop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的 loop</span></span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        <span class="comment">// 对 loops 字典加锁</span></span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">        <span class="comment">// 从 loops 字典中获取 loop</span></span><br><span class="line">        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">        <span class="keyword">if</span> (!loop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果在字典中没有找到 loop，把新的 loop 存入 loops 字典中</span></span><br><span class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">            loop = newLoop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span></span><br><span class="line">        <span class="comment">// 不要在 字典锁作用域里面释放 runloop 对象，因为 CFRunLoopDeallocate 会释放掉 runloop</span></span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">        <span class="comment">// 释放 newLoop</span></span><br><span class="line">        CFRelease(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 t 是否是当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, pthread_self()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置 thread specific data，简称 TSD，这也是一个字典</span></span><br><span class="line">        <span class="comment">// 以 __CFTSDKeyRunLoop 为 key, loop 对象为 value 存入 TSD 中</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         // Set some thread specific data in a pre-assigned slot. Don't pick a random value.</span></span><br><span class="line"><span class="comment">         Make sure you're using a slot that is unique.</span></span><br><span class="line"><span class="comment">         Pass in a destructor to free this data, or NULL if none is needed. Unlike pthread TSD, the destructor is per-thread.</span></span><br><span class="line"><span class="comment">         // 和 pthread 的 TSD 不一样的时，第三个参数 析构函数指针是每个线程都拥有的</span></span><br><span class="line"><span class="comment">         CF_EXPORT void *_CFSetTSD(uint32_t slot, void *newVal, void (*destructor)(void *));</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="keyword">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr))</span><br><span class="line">        &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="keyword">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS - <span class="number">1</span>), (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的源码，我们明确了在底层有一个字典的数据结构。<br>这个字典存储方式的是以 <code>pthread_t</code> 线程为 key，CFRunLoopRef 为 value。<br>我们可以有以下的结论：</p>
<ul>
<li>每条线程都有唯一的一个与之对应的RunLoop对象</li>
<li>RunLoop 保存在一个全局的 Dictionary 里，线程作为 key，RunLoop 作为 value</li>
<li>线程刚创建时并没有 RunLoop 对象，RunLoop 会在第一次获取它时创建</li>
<li>RunLoop 会在线程结束时销毁</li>
<li>主线程的 RunLoop 已经自动获取（创建），子线程默认没有开启RunLoop<h1 id="Runloop-底层"><a href="#Runloop-底层" class="headerlink" title="Runloop 底层"></a>Runloop 底层</h1></li>
</ul>
<h2 id="RunLoop-启动方式"><a href="#RunLoop-启动方式" class="headerlink" title="RunLoop 启动方式"></a>RunLoop 启动方式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">return</span> CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的源码可知：</p>
<ul>
<li>默认启动方式，底层是通过 <code>CFRunLoopRun</code> 来实现，超时时间传入的是 <code>1.0e10</code>，这是一个很大的数字，所以可以理解为不超时。</li>
<li>自定义启动方式，可以配置超时时间以及 mode 等其它参数。</li>
</ul>
<h2 id="RunLoop-核心逻辑"><a href="#RunLoop-核心逻辑" class="headerlink" title="RunLoop 核心逻辑"></a>RunLoop 核心逻辑</h2><p>我们接着进入 <code>CFRunLoopRunSpecific</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="comment">// 如果 runloop 正在回收中，直接返回 kCFRunLoopRunFinished ，表示 runloop 已经完成</span></span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl))</span><br><span class="line">        <span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line">    <span class="comment">// 对 runloop 加锁</span></span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="comment">// 从 runloop 中查找给定的 mode</span></span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 如果找不到 mode，且当前 runloop 的 currentMode 也为空，进入 if 逻辑</span></span><br><span class="line">    <span class="comment">// __CFRunLoopModeIsEmpty 函数结果为空的话，说明 runloop 已经处理完所有任务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode))</span><br><span class="line">    &#123;</span><br><span class="line">        Boolean did = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果 currentMode 不为空</span></span><br><span class="line">        <span class="keyword">if</span> (currentMode)</span><br><span class="line">            <span class="comment">// 对 currentMode 解锁</span></span><br><span class="line">            __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">        <span class="comment">// 对 runloop 解锁</span></span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">        <span class="keyword">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暂时取出 runloop 的 per_run_data</span></span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</span><br><span class="line">    <span class="comment">// 取出 runloop 的当前 mode</span></span><br><span class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</span><br><span class="line">    <span class="comment">// 将查找到的 mode 赋值到 runloop 的 _curentMode，也就是说在这 runloop 完成了 mode 的切换</span></span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    <span class="comment">// 初始化返回结果 result</span></span><br><span class="line">    <span class="keyword">int32_t</span> result = kCFRunLoopRunFinished;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果注册了 observer 监听 kCFRunLoopEntry 状态(即将进入 loop)，则通知 observer</span></span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry)</span><br><span class="line">        __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    <span class="comment">// runloop 核心函数 __CFRunLoopRun</span></span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    <span class="comment">// 如果注册了 observer 监听 kCFRunLoopExit 状态(即将推出 loop)，则通知 observer</span></span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit)</span><br><span class="line">        __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    <span class="comment">// 对 currentMode 解锁</span></span><br><span class="line">    __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">    <span class="comment">// 还原原来的 previousPerRun</span></span><br><span class="line">    __CFRunLoopPopPerRunData(rl, previousPerRun);</span><br><span class="line">    <span class="comment">// 还原原来的 mode</span></span><br><span class="line">    rl-&gt;_currentMode = previousMode;</span><br><span class="line">    <span class="comment">// 对 runloop 解锁</span></span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这块的代码精简一下之后:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    <span class="comment">// 通知 Observers 进入 loop</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体要做的事情</span></span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知 Observers 退出 loop</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功夫不负有心人，终于来到了最核心的流程 <code>__CFRunLoopRun</code> 函数，说白了，一次运行循环就是一次 <code>__CFRunLoopRun</code> 的运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)</span><br></pre></td></tr></table></figure>

<p><code>__CFRunLoopRun</code> 参数有 5 个，分别表示:</p>
<ul>
<li><code>rl</code>: CFRunLoopRef 对象</li>
<li><code>rlm</code>: mode 的名称</li>
<li><code>seconds</code>: 超时时间</li>
<li><code>stopAfterHandle</code>: 处理完 source 后是否直接返回</li>
<li><code>previousMode</code>: 前一次运行循环的 mode</li>
</ul>
<blockquote>
<p>下面提供 <code>__CFRunLoopRun</code> 的完整代码和精简代码，读者可根据自身需要选择阅读。</p>
</blockquote>
<h2 id="CFRunLoopRun-完整代码"><a href="#CFRunLoopRun-完整代码" class="headerlink" title="__CFRunLoopRun 完整代码"></a>__CFRunLoopRun 完整代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取开始时间</span></span><br><span class="line">    <span class="keyword">uint64_t</span> startTSR = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsStopped(rl))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Runloop 处于停止状态，修改runloop底层数据结构 停止状态 flag</span></span><br><span class="line">        __CFRunLoopUnsetStopped(rl);</span><br><span class="line">        <span class="comment">// 返回 kCFRunLoopRunStopped 状态</span></span><br><span class="line">        <span class="keyword">return</span> kCFRunLoopRunStopped;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Mode 处于停止状态，修改 mode 的成员变量 _stopped 为 false</span></span><br><span class="line">        rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 返回 kCFRunLoopRunStopped 状态</span></span><br><span class="line">        <span class="keyword">return</span> kCFRunLoopRunStopped;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否有主队列的 Mach Port</span></span><br><span class="line">    <span class="keyword">mach_port_name_t</span> dispatchPort = MACH_PORT_NULL;</span><br><span class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="literal">NULL</span> == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="number">0</span> == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</span><br><span class="line">    <span class="keyword">if</span> (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name))</span><br><span class="line">        dispatchPort = _dispatch_get_main_queue_port_4CF();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    <span class="comment">// 从 mode 的 成员变量 _queue 中取出对应的 Mach Port</span></span><br><span class="line">    <span class="keyword">mach_port_name_t</span> modeQueuePort = MACH_PORT_NULL;</span><br><span class="line">    <span class="keyword">if</span> (rlm-&gt;_queue)</span><br><span class="line">    &#123;</span><br><span class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</span><br><span class="line">        <span class="keyword">if</span> (!modeQueuePort)</span><br><span class="line">        &#123;</span><br><span class="line">            CRASH(<span class="string">"Unable to get port for run loop mode queue (%d)"</span>, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个空的 GCD 定时器</span></span><br><span class="line">    <span class="keyword">dispatch_source_t</span> timeout_timer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 初始化一个 「超时上下文」 结构体指针对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">timeout_context</span> *<span class="title">timeout_context</span> = (<span class="title">struct</span> __<span class="title">timeout_context</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(*<span class="title">timeout_context</span>));</span></span><br><span class="line">    <span class="comment">// 如果 runloop 超时时间小于等于0</span></span><br><span class="line">    <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>)</span><br><span class="line">    &#123; <span class="comment">// instant timeout</span></span><br><span class="line">        <span class="comment">// 将 seconds 置为 0s</span></span><br><span class="line">        seconds = <span class="number">0.0</span>;</span><br><span class="line">        <span class="comment">// 将 「超时上下文」的 termTSR 属性设置为 0，0ULL 后面的 ULL 表示 Unsigned Long Long 即无符号 long long 整型</span></span><br><span class="line">        timeout_context-&gt;termTSR = <span class="number">0U</span>LL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果 runloop 超时时间小于等于 TIMER_INTERVAL_LIMIT 常量</span></span><br><span class="line">        <span class="comment">// 如果主线程存在，则获取主线程的主队列</span></span><br><span class="line">        <span class="comment">// 如果主线程不存在，则获取全局队列</span></span><br><span class="line">        <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground();</span><br><span class="line">        <span class="comment">// 将队列传入并初始化一个 GCD 对象，对象类型为定时器</span></span><br><span class="line">        timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">queue</span>);</span><br><span class="line">        <span class="comment">// 对 GCD 对象进行 retain</span></span><br><span class="line">        dispatch_retain(timeout_timer);</span><br><span class="line">        <span class="comment">// 将 GCD 对象赋值于 「超时上下文」 结构体的 ds 属性</span></span><br><span class="line">        timeout_context-&gt;ds = timeout_timer;</span><br><span class="line">        <span class="comment">// 对 runloop 对象进行 retain，然后赋值于「超时上下文」 结构体的 rl 属性</span></span><br><span class="line">        timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</span><br><span class="line">        <span class="comment">// 将本次运行循环的开始时间加上要运行的时间得到runloop的生命周期时间</span></span><br><span class="line">        <span class="comment">// 然后赋值于「超时上下文」 结构体的 termTSR 属性</span></span><br><span class="line">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置 GCD 对象的上下文为 自定义的 「超时上下文」 结构体</span></span><br><span class="line">        dispatch_set_context(timeout_timer, timeout_context); <span class="comment">// source gets ownership of context</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置 GCD 对象的回调 可以理解为要执行的任务</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         static void __CFRunLoopTimeout(void *arg)</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">             struct __timeout_context *context = (struct __timeout_context *)arg;</span></span><br><span class="line"><span class="comment">             context-&gt;termTSR = 0ULL;</span></span><br><span class="line"><span class="comment">             CFRUNLOOP_WAKEUP_FOR_TIMEOUT();</span></span><br><span class="line"><span class="comment">             CFRunLoopWakeUp(context-&gt;rl);</span></span><br><span class="line"><span class="comment">             // The interval is DISPATCH_TIME_FOREVER, so this won't fire again</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         __CFRunLoopTimeout 函数内部</span></span><br><span class="line"><span class="comment">         1.将 「超时上下文」 结构体的 termTSR 属性赋值为0</span></span><br><span class="line"><span class="comment">         2.CFRUNLOOP_WAKEUP_FOR_TIMEOUT() 宏内部是一个 do-while(0) 的无用操作，可以忽略</span></span><br><span class="line"><span class="comment">         3.然后通过 CFRunLoopWakeUp 函数来唤醒 runloop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">        <span class="comment">// 设置 GCD 对象的取消回调 可以理解为取消任务时的回调</span></span><br><span class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将开始时间加上给定的 runloop 过期时间，因为此时结果为 秒，需要转换为 纳秒，所以再乘以 10 ^ 9</span></span><br><span class="line">        <span class="keyword">uint64_t</span> ns_at = (<span class="keyword">uint64_t</span>)((__CFTSRToTimeInterval(startTSR) + seconds) * <span class="number">1000000000U</span>LL);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置 GCD 定时器</span></span><br><span class="line">        <span class="comment">// 第二个参数表示定时器开始时间 也就是说，如果是 CFRunLoopRun 进来的话</span></span><br><span class="line">        <span class="comment">// 因为传入的值是 1.0e10，所以这个定时器永远不会触发，也就意味着 runloop 永远不会超时</span></span><br><span class="line">        <span class="comment">// 第三个参数表示 定时器 纳秒级的 间隔，这里传入的是 DISPATCH_TIME_FOREVER，说明定时器只会触发一次，不会触发多次</span></span><br><span class="line">        <span class="comment">// 第四个参数表示 定时器 纳秒级 的容错时间</span></span><br><span class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(<span class="number">1</span>, ns_at), DISPATCH_TIME_FOREVER, <span class="number">1000U</span>LL);</span><br><span class="line">        <span class="comment">// 开启 GCD 定时器</span></span><br><span class="line">        dispatch_resume(timeout_timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">// infinite timeout</span></span><br><span class="line">        <span class="comment">// 设置超时时间为 9999999999</span></span><br><span class="line">        <span class="comment">// 然后设置 自定义的 「超时上下文」 结构体的 termTSR 属性值为 UNIT64_MAX</span></span><br><span class="line">        seconds = <span class="number">9999999999.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个布尔值 上一次是否通过 dispatch port</span></span><br><span class="line">    Boolean didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">        <span class="keyword">voucher_mach_msg_state_t</span> voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</span><br><span class="line">        <span class="keyword">voucher_t</span> voucherCopy = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 初始化一个 无符号 int8 整型类型的 消息缓冲区，缓冲区大小为 3KB</span></span><br><span class="line">        <span class="keyword">uint8_t</span> msg_buffer[<span class="number">3</span> * <span class="number">1024</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">        <span class="comment">// 初始化一个空的 mach_msg_header_t 类型的 msg 结构体指针变量</span></span><br><span class="line">        <span class="keyword">mach_msg_header_t</span> *msg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 初始化一个值为 MACH_PORT_NULL 的 port</span></span><br><span class="line">        <span class="keyword">mach_port_t</span> livePort = MACH_PORT_NULL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 mode 的 _portSet 取出</span></span><br><span class="line">        __CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 runloop 底层数据结构的 ignoreWakeUps 值为 0</span></span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断如果 mode 的 observer 的 mask 与上 kCFRunLoopBeforeTimers 枚举值是否为1</span></span><br><span class="line">        <span class="comment">// 如果成功，通知 Observers 即将处理 Timers</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断如果 mode 的 observer 的 mask 与上 kCFRunLoopBeforeSources 枚举值是否为1</span></span><br><span class="line">        <span class="comment">// 如果成功，通知 Observers 即将处理 Sources</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 Blocks，传入 runloop 和 mode</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 Source0，传入 runloop 和 mode，以及 stopAfterHandle</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="comment">// 如果处理 Sources0 成功，再次处理 Blocks</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop)</span><br><span class="line">        &#123;</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果本次 loop 执行 source0 成功 或 超时时间为0，设置 poll 为 true</span></span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0U</span>LL == timeout_context-&gt;termTSR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果主队列 port 不为空且上一次 loop 没有主队列 port</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">            <span class="comment">// 初始化一个 mach_msg_header_t 结构的 msg</span></span><br><span class="line">            msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">            <span class="comment">// 判断主队列的port上是否有消息，如果有，进入 handle_msg 流程</span></span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 说明主队列的port上有消息过来，需要唤醒 runloop</span></span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将上一次 loop 主队列 值为空</span></span><br><span class="line">        didDispatchPortLastTime = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明没有从 port 拉取消息，并且 mode 的 _observerMask 与上 kCFRunLoopBeforeWaiting 为真，</span></span><br><span class="line">        <span class="comment">// 则通知 Observers 即将休眠</span></span><br><span class="line">        <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting))</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         CF_INLINE void __CFRunLoopSetSleeping(CFRunLoopRef rl)</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">             __CFBitfieldSetValue(((CFRuntimeBase *)rl)-&gt;_cfinfo[CF_INFO_BITS], 1, 1, 1);</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 设置 runloop sleeping 的flag</span></span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        <span class="comment">// do not do any user callouts after this point (after notifying of sleeping)</span></span><br><span class="line">        <span class="comment">// 在 runloop 已经睡眠之后，不要做任何用户调用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Must push the local-to-this-activation ports in on every loop</span></span><br><span class="line">        <span class="comment">// iteration, as this mode could be run re-entrantly and we don't</span></span><br><span class="line">        <span class="comment">// want these ports to get serviced.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         //必须在每个循环中都将 local-to-this-activation 端口推入</span></span><br><span class="line"><span class="comment">         //迭代，因为此模式可以重新运行，我们不</span></span><br><span class="line"><span class="comment">         //希望这些端口可以被服务。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 将主队列 port 加入 waitSet 中</span></span><br><span class="line">        __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解锁 mode</span></span><br><span class="line">        __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        <span class="comment">// 解锁 runloop</span></span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 poll 为真，sleepStart 为 0，否则为当前时间</span></span><br><span class="line">        CFAbsoluteTime sleepStart = poll ? <span class="number">0.0</span> : CFAbsoluteTimeGetCurrent();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">        <span class="comment">// 这个 do - while 循环主要针对于 GCD 定时器</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (kCFUseCollectableAllocator)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// objc_clear_stack(0);</span></span><br><span class="line">                <span class="comment">// &lt;rdar://problem/16393959&gt;</span></span><br><span class="line">                <span class="comment">// 将 msg_buffer 缓冲区 置为0</span></span><br><span class="line">                <span class="built_in">memset</span>(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</span><br><span class="line">            &#125;</span><br><span class="line">            msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">            <span class="comment">// 判断 waitSet 的 port 是否有消息</span></span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断 modeQueuePort 这个 port 不为空，且 livePort 为 modeQueuePort</span></span><br><span class="line">            <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 清空内部队列。 如果其中一个标注块设置了 timerFired 标志，请中断并为计时器提供服务。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">while</span> (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue))</span><br><span class="line">                    ;</span><br><span class="line">                <span class="comment">// 如果 mode 的 _timerFired 为 真，则置为 false，并退出 do-while 循环</span></span><br><span class="line">                <span class="keyword">if</span> (rlm-&gt;_timerFired)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Leave livePort as the queue port, and service timers below</span></span><br><span class="line">                    rlm-&gt;_timerFired = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (msg &amp;&amp; msg != (<span class="keyword">mach_msg_header_t</span> *)msg_buffer)</span><br><span class="line">                        <span class="built_in">free</span>(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Go ahead and leave the inner loop.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (kCFUseCollectableAllocator)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// objc_clear_stack(0);</span></span><br><span class="line">            <span class="comment">// &lt;rdar://problem/16393959&gt;</span></span><br><span class="line">            <span class="comment">// 将 msg_buffer 缓冲区 置为0</span></span><br><span class="line">            <span class="built_in">memset</span>(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</span><br><span class="line">        &#125;</span><br><span class="line">        msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">        <span class="comment">// 判断 waitSet 的 port 是否有消息</span></span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 对 runloop 加锁</span></span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        <span class="comment">// 对 mode 加锁</span></span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 poll 为真，说明主队了唤醒了 runloop，反之则获得 runloop 的睡眠时间</span></span><br><span class="line">        rl-&gt;_sleepTime += (poll ? <span class="number">0.0</span> : (CFAbsoluteTimeGetCurrent() - sleepStart));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Must remove the local-to-this-activation ports in on every loop</span></span><br><span class="line">        <span class="comment">// iteration, as this mode could be run re-entrantly and we don't</span></span><br><span class="line">        <span class="comment">// want these ports to get serviced. Also, we don't want them left</span></span><br><span class="line">        <span class="comment">// in there if this function returns.</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         CF_INLINE kern_return_t __CFPortSetRemove(__CFPort port, __CFPortSet portSet)</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">             if (MACH_PORT_NULL == port)</span></span><br><span class="line"><span class="comment">             &#123;</span></span><br><span class="line"><span class="comment">                 return -1;</span></span><br><span class="line"><span class="comment">             &#125;</span></span><br><span class="line"><span class="comment">             return mach_port_extract_member(mach_task_self(), port, portSet);</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 将 dispatchPort 从 waitSet 中移除，因为每次 runloop 迭代中 dispatchPort 都会被加入 waitSet</span></span><br><span class="line">        __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         CF_INLINE void __CFRunLoopSetIgnoreWakeUps(CFRunLoopRef rl)</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">             rl-&gt;_perRunData-&gt;ignoreWakeUps = 0x57414B45; // 'WAKE'</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         唤醒 runloop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// user callouts now OK again</span></span><br><span class="line">        <span class="comment">// 设置 runloop 的 sleeping flag 为 0</span></span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observers 结束休眠</span></span><br><span class="line">        <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">    handle_msg:;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         CF_INLINE void __CFRunLoopSetIgnoreWakeUps(CFRunLoopRef rl)</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">             rl-&gt;_perRunData-&gt;ignoreWakeUps = 0x57414B45; // 'WAKE'</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         表示收到了 port 消息，需要处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果唤醒的端口为空，啥事也不干</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL == livePort)</span><br><span class="line">        &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</span><br><span class="line">            <span class="comment">// handle nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果唤醒端口是 runloop 的 _wakeUpPort，则执行 CFRUNLOOP_WAKEUP_FOR_WAKEUP() 函数</span></span><br><span class="line">        <span class="comment">// CFRUNLOOP_WAKEUP_FOR_WAKEUP() 函数其实啥也没干</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == rl-&gt;_wakeUpPort)</span><br><span class="line">        &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</span><br><span class="line">            <span class="comment">// do nothing on Mac OS</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">        <span class="comment">// 如果唤醒端口是 modeQueuePort，说明是 定时器唤醒了 runloop</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 调用 CFRUNLOOP_WAKEUP_FOR_TIMER 函数，</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            <span class="comment">// 执行 timer</span></span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time()))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer, because we apparently fired early</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">        <span class="comment">// 如果唤醒端口是 mode 的 _timerPort</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort)</span><br><span class="line">        &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            <span class="comment">// On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be 'too early' for the next timer, and no timers are handled.</span></span><br><span class="line">            <span class="comment">// In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754</span></span><br><span class="line">            <span class="comment">// 执行 timer</span></span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time()))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 如果唤醒端口是 dispatchPort，说明是主队列唤醒了 Runloop</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 执行 CFRUNLOOP_WAKEUP_FOR_DISPATCH() 函数</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</span><br><span class="line">            <span class="comment">// 解锁 mode</span></span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            <span class="comment">// 解锁 runloop</span></span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            <span class="comment">// 设置 TSD，以 __CFTSDKeyIsInGCDMainQ 为 key， 6 为值</span></span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="keyword">void</span> *)<span class="number">6</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 执行主队列任务</span></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            <span class="comment">// 设置 TSD，以 __CFTSDKeyIsInGCDMainQ 为 key， 0 为值</span></span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="keyword">void</span> *)<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 对 runloop 加锁</span></span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            <span class="comment">// 对 mode 加锁</span></span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">            <span class="comment">// 标记本次 loop 处理了主队列</span></span><br><span class="line">            sourceHandledThisLoop = <span class="literal">true</span>;</span><br><span class="line">            didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 来到这，说明是被 source1 唤醒</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we received a voucher from this mach_msg, then put a copy of the new voucher into TSD. CFMachPortBoost will look in the TSD for the voucher. By using the value in the TSD we tie the CFMachPortBoost to this received mach_msg explicitly without a chance for anything in between the two pieces of code to set the voucher again.</span></span><br><span class="line">            <span class="keyword">voucher_t</span> previousVoucher = _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, (<span class="keyword">void</span> *)voucherCopy, os_release);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Despite the name, this works for windows handles as well</span></span><br><span class="line">            <span class="comment">// 从端口中取出 source1</span></span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            <span class="keyword">if</span> (rls)</span><br><span class="line">            &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">                <span class="keyword">mach_msg_header_t</span> *reply = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">// 执行 source1 z任务</span></span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != reply)</span><br><span class="line">                &#123;</span><br><span class="line">                    (<span class="keyword">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">                    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Restore the previous voucher</span></span><br><span class="line">            _CFSetTSD(__CFTSDKeyMachMessageHasVoucher, previousVoucher, os_release);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">        <span class="keyword">if</span> (msg &amp;&amp; msg != (<span class="keyword">mach_msg_header_t</span> *)msg_buffer)</span><br><span class="line">            <span class="built_in">free</span>(msg);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 处理 Blocks，传入 runloop 和 mode</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         CFRunLoopRunInMode() 函数返回的原因，有四种</span></span><br><span class="line"><span class="comment">         // Reasons for CFRunLoopRunInMode() to Return</span></span><br><span class="line"><span class="comment">         enum &#123;</span></span><br><span class="line"><span class="comment">             kCFRunLoopRunFinished = 1, // 完成了 loop</span></span><br><span class="line"><span class="comment">             kCFRunLoopRunStopped = 2,  // loop 被终止</span></span><br><span class="line"><span class="comment">             kCFRunLoopRunTimedOut = 3, // loop 超时</span></span><br><span class="line"><span class="comment">             kCFRunLoopRunHandledSource = 4 // loop 执行了 主队列任务</span></span><br><span class="line"><span class="comment">         &#125;;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 如果执行了主队列任务并且 stopAfterHandle 为真，则退出 do-while 循环</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle)</span><br><span class="line">        &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果超时，则退出 do-while 循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time())</span><br><span class="line">        &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 runloop 已经停止，则退出 do-while 循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl))</span><br><span class="line">        &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 mode 的 _stopped 属性为真，则退出 do-while 循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped)</span><br><span class="line">        &#123;</span><br><span class="line">            rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 mode 此时为空，则退出 do-while 循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode))</span><br><span class="line">        &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">        voucher_mach_msg_revert(voucherState);</span><br><span class="line">        os_release(voucherCopy);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果开启了 GCD 定时器</span></span><br><span class="line">    <span class="keyword">if</span> (timeout_timer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 停掉定时器并释放资源</span></span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 释放 超时上下文 结构体指针</span></span><br><span class="line">        <span class="built_in">free</span>(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CFRunLoopRun-精简代码"><a href="#CFRunLoopRun-精简代码" class="headerlink" title="__CFRunLoopRun 精简代码"></a>__CFRunLoopRun 精简代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通知 Observers 即将处理 Timers</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observers 即将处理 Sources</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 Blocks</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 Source0</span></span><br><span class="line">        <span class="keyword">if</span> (__CFRunLoopDoSources0(rl, rlm, stopAfterHandle))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理 Blocks</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0U</span>LL == timeout_context-&gt;termTSR);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断有无 Source1</span></span><br><span class="line">        <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果有 Source1，就跳转到 handle_msg</span></span><br><span class="line">            <span class="keyword">goto</span> handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        didDispatchPortLastTime = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知 Observers 即将休眠</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">            </span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line"></span><br><span class="line">        CFAbsoluteTime sleepStart = poll ? <span class="number">0.0</span> : CFAbsoluteTimeGetCurrent();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (kCFUseCollectableAllocator)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// objc_clear_stack(0);</span></span><br><span class="line">                <span class="comment">// &lt;rdar://problem/16393959&gt;</span></span><br><span class="line">                <span class="built_in">memset</span>(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</span><br><span class="line">            &#125;</span><br><span class="line">            msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待别的消息来唤醒当前线程</span></span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span></span><br><span class="line">                <span class="keyword">while</span> (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue))</span><br><span class="line">                    ;</span><br><span class="line">                <span class="keyword">if</span> (rlm-&gt;_timerFired)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Leave livePort as the queue port, and service timers below</span></span><br><span class="line">                    rlm-&gt;_timerFired = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (msg &amp;&amp; msg != (<span class="keyword">mach_msg_header_t</span> *)msg_buffer)</span><br><span class="line">                        <span class="built_in">free</span>(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Go ahead and leave the inner loop.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// user callouts now OK again</span></span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observers 结束休眠</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">    handle_msg:</span><br><span class="line">        <span class="keyword">if</span> (被 timer 唤醒)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理 timers</span></span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (被 GCD 唤醒)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 处理 GCD 主队列</span></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 被 Source1 唤醒</span></span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 Blocks</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle)</span><br><span class="line">        &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time())</span><br><span class="line">        &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl))</span><br><span class="line">        &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped)</span><br><span class="line">        &#123;</span><br><span class="line">            rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode))</span><br><span class="line">        &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        voucher_mach_msg_revert(voucherState);</span><br><span class="line">        os_release(voucherCopy);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RunLoop-执行的任务"><a href="#RunLoop-执行的任务" class="headerlink" title="RunLoop 执行的任务"></a>RunLoop 执行的任务</h2><p>通过 <code>__CFRunLoopRun</code>，我们知道了 <code>RunLoop</code> 执行的任务有以下几个:</p>
<ul>
<li><code>__CFRunLoopDoObservers</code></li>
<li><code>__CFRunLoopDoBlocks</code></li>
<li><code>__CFRunLoopDoSources0</code></li>
<li><code>__CFRunLoopDoSource1</code></li>
<li><code>__CFRunLoopDoTimers</code></li>
<li><code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code></li>
</ul>
<p>下面，我们将一个一个进行分析:</p>
<h3 id="CFRunLoopDoObservers"><a href="#CFRunLoopDoObservers" class="headerlink" title="__CFRunLoopDoObservers"></a>__CFRunLoopDoObservers</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rl is locked, rlm is locked on entrance and exit */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRunLoopDoObservers() __attribute__((noinline));</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRunLoopDoObservers(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopActivity activity)</span><br><span class="line">&#123; <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断传入的 mode 对应的 observer 数量是否为 0</span></span><br><span class="line">    CFIndex cnt = rlm-&gt;_observers ? CFArrayGetCount(rlm-&gt;_observers) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fire the observers */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// #define STACK_BUFFER_DECL(T, N, C) T N[C]</span></span><br><span class="line">    <span class="comment">// 这里可以分为两种情况</span></span><br><span class="line">    <span class="comment">// 如果 mode 中的 observer 数量小于等于 1024 个，那么相当于 CFRunLoopObserverRef buffer[cnt]</span></span><br><span class="line">    <span class="comment">// 如果 mode 中的 observer 数量大于 1024 个，那么相当于 CFRunLoopObserverRef buffer[1]</span></span><br><span class="line">    <span class="comment">// 所以这里通过 observer 数量来分配不同大小的缓存区</span></span><br><span class="line">    STACK_BUFFER_DECL(CFRunLoopObserverRef, buffer, (cnt &lt;= <span class="number">1024</span>) ? cnt : <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断如果 observer 数量小于 1024 个，则把上一步得到的 buffer 缓存区赋值给 collectedObservers</span></span><br><span class="line">    <span class="comment">// 如果 observer 数量大于 1024 个，则调用 malloc 函数来分配空间, 最终空间大小为 =  observer数目 * CFRunLoopObserverRef 类型占用内存大小</span></span><br><span class="line">    <span class="comment">// 最终获得了一个 类型为 CFRunLoopObserverRef 的数组指针变量 collectedObservers</span></span><br><span class="line">    CFRunLoopObserverRef *collectedObservers = (cnt &lt;= <span class="number">1024</span>) ? buffer : (CFRunLoopObserverRef *)<span class="built_in">malloc</span>(cnt * <span class="keyword">sizeof</span>(CFRunLoopObserverRef));</span><br><span class="line">    </span><br><span class="line">    CFIndex obs_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环遍历传入的 runloop mode 中所有的 observers</span></span><br><span class="line">    <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>; idx &lt; cnt; idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从 observers 集合中取出一个 observer</span></span><br><span class="line">        CFRunLoopObserverRef rlo = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 满足下列三个条件后进入 if 内部的逻辑</span></span><br><span class="line">        <span class="comment">// 1.判断 observer 当前的状态是否与传入的状态匹配，这里是通过 与 运算来完成，如果相等，结果应为 1，所以这里判断是不等于 0</span></span><br><span class="line">        <span class="comment">// 2.判断 observer 是否是有效的</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         // Bit 3 in the base reserved bits is used for invalid state in run loop objects</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         CF_INLINE Boolean __CFIsValid(const void *cf)</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">             return (Boolean)__CFBitfieldGetValue(((const CFRuntimeBase *)cf)-&gt;_cfinfo[CF_INFO_BITS], 3, 3);</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         CF_INLINE void __CFSetValid(void *cf)</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">             __CFBitfieldSetValue(((CFRuntimeBase *)cf)-&gt;_cfinfo[CF_INFO_BITS], 3, 3, 1);</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         CF_INLINE void __CFUnsetValid(void *cf)</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">             __CFBitfieldSetValue(((CFRuntimeBase *)cf)-&gt;_cfinfo[CF_INFO_BITS], 3, 3, 0);</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 3.判断 observer 是否已经 fire 了</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         Bit 0 of the base reserved bits is used for firing state</span></span><br><span class="line"><span class="comment">         Bit 1 of the base reserved bits is used for repeats state</span></span><br><span class="line"><span class="comment">         CF_INLINE Boolean __CFRunLoopObserverIsFiring(CFRunLoopObserverRef rlo)</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">             return (Boolean)__CFBitfieldGetValue(((const CFRuntimeBase *)rlo)-&gt;_cfinfo[CF_INFO_BITS], 0, 0);</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         探索第二步和第三步操作之后，可以发现 CFRuntimeBase 结构中的</span></span><br><span class="line"><span class="comment">         Bit 0 是用来表示 启动状态</span></span><br><span class="line"><span class="comment">         Bit 1 是用来表示 重复状态</span></span><br><span class="line"><span class="comment">         Bit 3 是用来表示 runloop 对象的可用状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != (rlo-&gt;_activities &amp; activity) &amp;&amp; __CFIsValid(rlo) &amp;&amp; !__CFRunLoopObserverIsFiring(rlo))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对 observer 进行 retain，然后存入 collectedObservers 集合中</span></span><br><span class="line">            <span class="comment">// CoreFoundation 框架中 需要手动MRC，也就是对接收到的对象需要调用 CFRetain，与此同时，需要有配对的 CFRelease 操作防止内存泄漏</span></span><br><span class="line">            collectedObservers[obs_cnt++] = (CFRunLoopObserverRef)CFRetain(rlo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对传入的 mode 解锁</span></span><br><span class="line">    <span class="comment">// 底层实现是一个互斥锁</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     CF_INLINE void __CFRunLoopModeUnlock(CFRunLoopModeRef rlm)</span></span><br><span class="line"><span class="comment">     &#123;</span></span><br><span class="line"><span class="comment">         //CFLog(6, CFSTR("__CFRunLoopModeLock unlocking %p"), rlm);</span></span><br><span class="line"><span class="comment">         pthread_mutex_unlock(&amp;(rlm-&gt;_lock));</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    <span class="comment">// 对传入的 runloop 解锁</span></span><br><span class="line">    <span class="comment">// 底层实现是一个互斥锁</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     CF_INLINE void __CFRunLoopUnlock(CFRunLoopRef rl)</span></span><br><span class="line"><span class="comment">     &#123;</span></span><br><span class="line"><span class="comment">         //    CFLog(6, CFSTR("__CFRunLoopLock unlocking %p"), rl);</span></span><br><span class="line"><span class="comment">         pthread_mutex_unlock(&amp;(((CFRunLoopRef)rl)-&gt;_lock));</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="comment">// 根据上面 for 循环内部自增的变量 obs_cnt ，也就是有效的 observer 的个数进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>; idx &lt; obs_cnt; idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取出一个 observer</span></span><br><span class="line">        CFRunLoopObserverRef rlo = collectedObservers[idx];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对 observer 进行加锁</span></span><br><span class="line">        <span class="comment">// 底层实现是一把互斥锁</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         CF_INLINE void __CFRunLoopObserverLock(CFRunLoopObserverRef rlo)</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">             pthread_mutex_lock(&amp;(rlo-&gt;_lock));</span></span><br><span class="line"><span class="comment">             //    CFLog(6, CFSTR("__CFRunLoopObserverLock locked %p"), rlo);</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        __CFRunLoopObserverLock(rlo);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再次判断 observer 是否已失效</span></span><br><span class="line">        <span class="keyword">if</span> (__CFIsValid(rlo))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从 observer 中取出 重复状态，然后取反，赋值给 doInvalidate 布尔变量</span></span><br><span class="line">            <span class="comment">// 这个布尔变量在后面用作判断，即如果 observer 的 repeat 为真，那么 doInvalidate 就为假，</span></span><br><span class="line">            <span class="comment">// 如果 observer 的 repeat 为假，那么 doInvalidate 就为真，</span></span><br><span class="line">            <span class="comment">// 就会调用 CFRunLoopObserverInvalidate 来将 observer 从所属 runloop 中剔除，然后 observer 被释放</span></span><br><span class="line">            Boolean doInvalidate = !__CFRunLoopObserverRepeats(rlo);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 设置 observer 的 runtimebase 里面的 bit 0 值为1 ，即标记 observer 已经启动</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             CF_INLINE void __CFRunLoopObserverSetFiring(CFRunLoopObserverRef rlo)</span></span><br><span class="line"><span class="comment">             &#123;</span></span><br><span class="line"><span class="comment">                 __CFBitfieldSetValue(((CFRuntimeBase *)rlo)-&gt;_cfinfo[CF_INFO_BITS], 0, 0, 1);</span></span><br><span class="line"><span class="comment">             &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            __CFRunLoopObserverSetFiring(rlo);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 对 observer 解锁</span></span><br><span class="line">            __CFRunLoopObserverUnlock(rlo);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ 函数，传入 observer 对应的 callout，以及 observer 自己，runloop 当前状态，以及 observer 上下文信息</span></span><br><span class="line">            __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(rlo-&gt;_callout, rlo, activity, rlo-&gt;_context.info);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (doInvalidate)</span><br><span class="line">            &#123;</span><br><span class="line">                CFRunLoopObserverInvalidate(rlo);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取消 observer 的 firing 状态</span></span><br><span class="line">            __CFRunLoopObserverUnsetFiring(rlo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 说明 observer 已经失效，对 observer 解锁</span></span><br><span class="line">            __CFRunLoopObserverUnlock(rlo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为此时 observer 要么已经触发了回调，要么由于已经失效啥也没干，所以需要释放释放掉 observer，然后开启下一次循环过程</span></span><br><span class="line">        CFRelease(rlo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 runloop 加锁</span></span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="comment">// 对 mode 加锁</span></span><br><span class="line">    __CFRunLoopModeLock(rlm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断集合如果不等于 buffer ，说明是使用的 malloc 函数初始化而来，需要调用 free 函数释放</span></span><br><span class="line">    <span class="keyword">if</span> (collectedObservers != buffer)</span><br><span class="line">        <span class="built_in">free</span>(collectedObservers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最终执行回调任务的是 <code>__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</code>，我们来到它的内部:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__() __attribute__((noinline));</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(CFRunLoopObserverCallBack func, CFRunLoopObserverRef observer, CFRunLoopActivity activity, <span class="keyword">void</span> *info)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (func)</span><br><span class="line">    &#123;</span><br><span class="line">        func(observer, activity, info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">asm</span> __volatile__(<span class="string">""</span>); <span class="comment">// thwart tail-call optimization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CFRunLoopDoBlocks"><a href="#CFRunLoopDoBlocks" class="headerlink" title="__CFRunLoopDoBlocks"></a>__CFRunLoopDoBlocks</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 从 runloop 的 _block_item 链表里面匹配 mode，匹配上了的就执行 block 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Boolean __CFRunLoopDoBlocks(CFRunLoopRef rl, CFRunLoopModeRef rlm)</span><br><span class="line">&#123; <span class="comment">// Call with rl and rlm locked</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     因为 runloop 内部有这样的结构</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     struct _block_item *_blocks_head;  // 链表的头指针</span></span><br><span class="line"><span class="comment">     struct _block_item *_blocks_tail;  // 链表的尾指针</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     struct _block_item</span></span><br><span class="line"><span class="comment">     &#123;</span></span><br><span class="line"><span class="comment">         struct _block_item *_next;     // 指向下一个 _block_item</span></span><br><span class="line"><span class="comment">         CFTypeRef _mode; // CFString or CFSet // mode 可能是字符串，也可能是集合</span></span><br><span class="line"><span class="comment">         void (^_block)(void);          // block</span></span><br><span class="line"><span class="comment">     &#125;;</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     所以 runloop 底层是以单链表的方式存储着 _block_item 结构体指针对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 如果 block 链表头指针为空，说明当前 runloop 没有要执行的 block，直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (!rl-&gt;_blocks_head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果 mode 为空或者 mode 的名称为空，也直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (!rlm || !rlm-&gt;_name)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否执行了 block</span></span><br><span class="line">    Boolean did = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 取出 block 链表头指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *<span class="title">head</span> = <span class="title">rl</span>-&gt;_<span class="title">blocks_head</span>;</span></span><br><span class="line">    <span class="comment">// 取出 block 链表尾指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *<span class="title">tail</span> = <span class="title">rl</span>-&gt;_<span class="title">blocks_tail</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 runloop 上的 block 链表头指针置空</span></span><br><span class="line">    rl-&gt;_blocks_head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 将 runloop 上的 block 链表尾指针置空</span></span><br><span class="line">    rl-&gt;_blocks_tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 获取 runloop 的 commonModes</span></span><br><span class="line">    CFSetRef commonModes = rl-&gt;_commonModes;</span><br><span class="line">    <span class="comment">// 获取传入的 mode 的名称</span></span><br><span class="line">    CFStringRef curMode = rlm-&gt;_name;</span><br><span class="line">    <span class="comment">// 对 mode 解锁</span></span><br><span class="line">    __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    <span class="comment">// 对 runloop 解锁</span></span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一个空的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">// 初始化一个指向链表头结点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *<span class="title">item</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">// 从取得的 block 链表头指针开始遍历整个 block 链表</span></span><br><span class="line">    <span class="keyword">while</span> (item)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前拿到的 _block_item 结构体变量</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *<span class="title">curr</span> = <span class="title">item</span>;</span></span><br><span class="line">        <span class="comment">// 指针往前移动一个位置，用于下一次循环</span></span><br><span class="line">        item = item-&gt;_next;</span><br><span class="line">        <span class="comment">// 初始化 doit 布尔值</span></span><br><span class="line">        Boolean doit = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 判断 _block_item 的 mode 是字符串还是集合，即这个 block_item 是对应一个 mode 还是多个 mode</span></span><br><span class="line">        <span class="keyword">if</span> (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 说明是一个 mode</span></span><br><span class="line">            <span class="comment">// 判断两种情况</span></span><br><span class="line">            <span class="comment">// 1.传入的 mode 是否与 block_item 内部的 mode 相等</span></span><br><span class="line">            <span class="comment">// 2.判断 block_item 内部的 mode 是否为 kCFRunLoopCommonModes，同时判断 commonModes 里面是否有传入的 mode</span></span><br><span class="line">            <span class="comment">// 以上情况有一个满足，则 doit 为 true，否则 doit 为 false</span></span><br><span class="line">            doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 说明是多个 mode</span></span><br><span class="line">            <span class="comment">// 也是判断两种情况</span></span><br><span class="line">            <span class="comment">// 1.判断 _block_item 内部的 mode 集合是否包含传入的 mode</span></span><br><span class="line">            <span class="comment">// 2.判断 _block_item 内部的 mode 集合是否包含 kCFRunLoopCommonModes，以及 commonModes 里面是否有传入的 mode</span></span><br><span class="line">            <span class="comment">// 以上情况有一个满足，则 doit 为 true，否则 doit 为 false</span></span><br><span class="line">            doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说白了只要 _block_item 节点满足 mode 匹配关系，就要执行其内部的 block 任务</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 doit 为 false，说明要执行 block 任务的不是当前的 _block_item,则将 prev 指针指向当前的 _block_item</span></span><br><span class="line">        <span class="comment">// 然后因为在前面已经做过 item = item-&gt;_next 的操作了，此时的 item 已经指向下一个 _block_item 了</span></span><br><span class="line">        <span class="keyword">if</span> (!doit)</span><br><span class="line">            prev = curr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 doit 为 true，说明要执行 block 任务的就是当前的 _block_item</span></span><br><span class="line">        <span class="keyword">if</span> (doit)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里其实可以分为三种情况</span></span><br><span class="line">            <span class="comment">// 一.目标节点在头尾之间的任一节点</span></span><br><span class="line">            <span class="comment">// 二.目标节点在头节点</span></span><br><span class="line">            <span class="comment">// 三.目标节点在尾节点</span></span><br><span class="line">            <span class="comment">// 因为已经执行完了 block 任务，需要删除目标节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断 prev 指针是否为空，如果不为空，则将 prev 指针的 _next 指向 item，注意，此时 item 为下一次要遍历的 _block_item</span></span><br><span class="line">            <span class="comment">// 这里的作用就是情况一</span></span><br><span class="line">            <span class="keyword">if</span> (prev)</span><br><span class="line">                prev-&gt;_next = item;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 下面分别判断了两种边界值情况，即要执行 block 的任务为头节点或尾节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断如果当前正在遍历的 _block_time 是否等于 head 指针</span></span><br><span class="line">            <span class="comment">// 因为 head 在进入 while 循环之前指向的链表的头结点，所以能够进入 if 内部逻辑的条件</span></span><br><span class="line">            <span class="comment">// 说白了也就是刚好头结点就是要执行 block 任务的那个节点，此时将 head 指针指向下一节点，在循环结束后有一个判断，</span></span><br><span class="line">            <span class="comment">// 如果 head 不为空，然后里面的有一步操作就是重新让 rl-&gt;_blocks_head 指向 head，也就是说 执行了 block 任务且刚好为头节点的节点被删除了。</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里的作用就是情况二</span></span><br><span class="line">            <span class="keyword">if</span> (curr == head)</span><br><span class="line">                head = item;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断如果当前正在遍历的 _block_time 是否等于 tail 指针</span></span><br><span class="line">            <span class="comment">// 因为 tail 指针在 while 循环之前是指向的链表的尾节点，所有能够进入 if 内部逻辑条件</span></span><br><span class="line">            <span class="comment">// 说白了就是刚好尾节点就是要执行 block 任务的那个节点，此时将 tail 指针指向 prev 指针指向的节点，</span></span><br><span class="line">            <span class="comment">// 而 prev 指针的指向，我们知道，显然就是尾节点的前一个节点，说白了就是把执行了 block 任务且刚好为尾节点的节点被删除了</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里的作用就是情况三</span></span><br><span class="line">            <span class="keyword">if</span> (curr == tail)</span><br><span class="line">                tail = prev;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 取出如果当前正在遍历的 _block_item 中的 block</span></span><br><span class="line">            <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = curr-&gt;_block;</span><br><span class="line">            <span class="comment">// 释放如果当前正在遍历的 _block_item 的 mode</span></span><br><span class="line">            CFRelease(curr-&gt;_mode);</span><br><span class="line">            <span class="comment">// 释放如果当前正在遍历的 _block_item</span></span><br><span class="line">            <span class="built_in">free</span>(curr);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 再次判断 doit</span></span><br><span class="line">            <span class="keyword">if</span> (doit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 传入 block，执行任务</span></span><br><span class="line">                __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line">                <span class="comment">// 将 did 置为 true</span></span><br><span class="line">                did = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放 block</span></span><br><span class="line">            Block_release(block); <span class="comment">// do this before relocking to prevent deadlocks where some yahoo wants to run the run loop reentrantly from their dealloc</span></span><br><span class="line">            <span class="comment">// 在重新加锁之前释放 blcok 可以防止程序员在 dealloc 方法里面重新让 runloop 运行起来而导致死锁的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 runloop 加锁</span></span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="comment">// 对  mode 加锁</span></span><br><span class="line">    __CFRunLoopModeLock(rlm);</span><br><span class="line">    <span class="comment">// 如果 head 指针不为空，这里 if 的逻辑也是必进</span></span><br><span class="line">    <span class="keyword">if</span> (head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 因为在前面已经对 rl-&gt;_blocks_head 指针进行了置空操作，这里等价于 tail-&gt;_next = NULL</span></span><br><span class="line">        tail-&gt;_next = rl-&gt;_blocks_head;</span><br><span class="line">        <span class="comment">// 让 rl-&gt;_blocks_head 指向 head 指针指向的节点</span></span><br><span class="line">        <span class="comment">// 如果在上面的 while 循环中，没找到要执行的 block，那么 head 其实就是原来 rl-&gt;_blocks_head 的值</span></span><br><span class="line">        <span class="comment">// 如果在上面的 while 循环中，找到了要执行的 block，那么 head 是指向的</span></span><br><span class="line">        rl-&gt;_blocks_head = head;</span><br><span class="line">        <span class="comment">// 因为在前面已经对 rl-&gt;_blocks_tail 指针进行了置空操作,所以这里 if 的逻辑必进</span></span><br><span class="line">        <span class="comment">// 所以这里就是让 rl-&gt;_blocks_tail 指向 tail 指针指向的节点</span></span><br><span class="line">        <span class="keyword">if</span> (!rl-&gt;_blocks_tail)</span><br><span class="line">            rl-&gt;_blocks_tail = tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> did;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到真正执行回调函数的是 <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A</strong>BLOCK__ 函数，其内部实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__() __attribute__((noinline));</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(<span class="keyword">void</span> (^block)(<span class="keyword">void</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (block)</span><br><span class="line">    &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">asm</span> __volatile__(<span class="string">""</span>); <span class="comment">// thwart tail-call optimization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="ti2qJ"></a></p>
<h3 id="CFRunLoopDoSources0"><a href="#CFRunLoopDoSources0" class="headerlink" title="__CFRunLoopDoSources0"></a>__CFRunLoopDoSources0</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rl is locked, rlm is locked on entrance and exit */</span></span><br><span class="line"><span class="keyword">static</span> Boolean __CFRunLoopDoSources0(CFRunLoopRef rl, CFRunLoopModeRef rlm, Boolean stopAfterHandle) __attribute__((noinline));</span><br><span class="line"><span class="keyword">static</span> Boolean __CFRunLoopDoSources0(CFRunLoopRef rl, CFRunLoopModeRef rlm, Boolean stopAfterHandle)</span><br><span class="line">&#123; <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="comment">// 初始化 sources ，并置空</span></span><br><span class="line">    CFTypeRef sources = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 初始化返回值 sourceHandled，并置为 false ，意为是否已经处理了 source0</span></span><br><span class="line">    Boolean sourceHandled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fire the version 0 sources */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm-&gt;_sources0 &amp;&amp; <span class="number">0</span> &lt; CFSetGetCount(rlm-&gt;_sources0))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断 mode 的 _source0 不为空且大小大于0</span></span><br><span class="line">        <span class="comment">// CFSetApplyFunction (Calls a function once for each value in the set.)</span></span><br><span class="line">        <span class="comment">// 这个函数的作用是对传入的 set 里面的每个元素执行 传入的函数指针</span></span><br><span class="line">        <span class="comment">// 第一个参数是 set</span></span><br><span class="line">        <span class="comment">// 第二个参数是 要对set每个元素执行一次的函数指针</span></span><br><span class="line">        <span class="comment">// 第三个参数作为传入的函数指针的第二个参数</span></span><br><span class="line">        CFSetApplyFunction(rlm-&gt;_sources0, (__CFRunLoopCollectSources0), &amp;sources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 sources 里面已经有全部的 source0 了</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != sources)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对 mode 解锁</span></span><br><span class="line">        __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        <span class="comment">// 对 runloop 解锁</span></span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">        <span class="comment">// sources 有可能是一个 runloop source 也有可能是一个装的 runloop source 的数组</span></span><br><span class="line">        <span class="comment">// sources is either a single (retained) CFRunLoopSourceRef or an array of (retained) CFRunLoopSourceRef</span></span><br><span class="line">        <span class="keyword">if</span> (CFGetTypeID(sources) == CFRunLoopSourceGetTypeID())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// sources 是单个 runloop source</span></span><br><span class="line">            <span class="comment">// 类型强转一下</span></span><br><span class="line">            CFRunLoopSourceRef rls = (CFRunLoopSourceRef)sources;</span><br><span class="line">            <span class="comment">// 对 rls 加锁</span></span><br><span class="line">            __CFRunLoopSourceLock(rls);</span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopSourceIsSignaled(rls))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 来到这，说明 rls 被标记为 signaled</span></span><br><span class="line">                <span class="comment">// 取消 signaled 的标志</span></span><br><span class="line">                __CFRunLoopSourceUnsetSignaled(rls);</span><br><span class="line">                <span class="comment">// 判断 rls 是否有效</span></span><br><span class="line">                <span class="keyword">if</span> (__CFIsValid(rls))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 对 rls 进行解锁</span></span><br><span class="line">                    __CFRunLoopSourceUnlock(rls);</span><br><span class="line">                    <span class="comment">// 执行 source0 回调</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__() __attribute__((noinline));</span></span><br><span class="line"><span class="comment">                     static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(void (*perform)(void *), void *info)</span></span><br><span class="line"><span class="comment">                     &#123;</span></span><br><span class="line"><span class="comment">                         if (perform)</span></span><br><span class="line"><span class="comment">                         &#123;</span></span><br><span class="line"><span class="comment">                             perform(info);</span></span><br><span class="line"><span class="comment">                         &#125;</span></span><br><span class="line"><span class="comment">                         asm __volatile__(""); // thwart tail-call optimization</span></span><br><span class="line"><span class="comment">                     &#125;</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);</span><br><span class="line">                    CHECK_FOR_FORK();</span><br><span class="line">                    <span class="comment">// 将处理 source0 的结果置为 true</span></span><br><span class="line">                    sourceHandled = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    __CFRunLoopSourceUnlock(rls);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 对 rls 解锁，来到这，说明 rls 没有被标记为 signaled</span></span><br><span class="line">                __CFRunLoopSourceUnlock(rls);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// sources 是数组</span></span><br><span class="line">            <span class="comment">// 取出 source0 的个数</span></span><br><span class="line">            CFIndex cnt = CFArrayGetCount((CFArrayRef)sources);</span><br><span class="line">            <span class="comment">// 对 sources 进行排序，按照 _order 进行升序排序</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             static CFComparisonResult __CFRunLoopSourceComparator(const void *val1, const void *val2, void *context)</span></span><br><span class="line"><span class="comment">             &#123;</span></span><br><span class="line"><span class="comment">                 CFRunLoopSourceRef o1 = (CFRunLoopSourceRef)val1;</span></span><br><span class="line"><span class="comment">                 CFRunLoopSourceRef o2 = (CFRunLoopSourceRef)val2;</span></span><br><span class="line"><span class="comment">                 if (o1-&gt;_order &lt; o2-&gt;_order)</span></span><br><span class="line"><span class="comment">                     return kCFCompareLessThan;</span></span><br><span class="line"><span class="comment">                 if (o2-&gt;_order &lt; o1-&gt;_order)</span></span><br><span class="line"><span class="comment">                     return kCFCompareGreaterThan;</span></span><br><span class="line"><span class="comment">                 return kCFCompareEqualTo;</span></span><br><span class="line"><span class="comment">             &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            CFArraySortValues((CFMutableArrayRef)sources, CFRangeMake(<span class="number">0</span>, cnt), (__CFRunLoopSourceComparator), <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 遍历 sources 数组</span></span><br><span class="line">            <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>; idx &lt; cnt; idx++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 取出一个 source0 rls</span></span><br><span class="line">                CFRunLoopSourceRef rls = (CFRunLoopSourceRef)CFArrayGetValueAtIndex((CFArrayRef)sources, idx);</span><br><span class="line">                <span class="comment">// 对 rls 加锁</span></span><br><span class="line">                __CFRunLoopSourceLock(rls);</span><br><span class="line">                <span class="keyword">if</span> (__CFRunLoopSourceIsSignaled(rls))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 来到这，说明 rls 被标记为 signaled</span></span><br><span class="line">                    <span class="comment">// 取消 signaled 的标志</span></span><br><span class="line">                    __CFRunLoopSourceUnsetSignaled(rls);</span><br><span class="line">                    <span class="comment">// 判断 rls 是否有效</span></span><br><span class="line">                    <span class="keyword">if</span> (__CFIsValid(rls))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 对 rls 进行解锁</span></span><br><span class="line">                        __CFRunLoopSourceUnlock(rls);</span><br><span class="line">                        <span class="comment">// 执行 source0 回调</span></span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__() __attribute__((noinline));</span></span><br><span class="line"><span class="comment">                         static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(void (*perform)(void *), void *info)</span></span><br><span class="line"><span class="comment">                         &#123;</span></span><br><span class="line"><span class="comment">                             if (perform)</span></span><br><span class="line"><span class="comment">                             &#123;</span></span><br><span class="line"><span class="comment">                                 perform(info);</span></span><br><span class="line"><span class="comment">                             &#125;</span></span><br><span class="line"><span class="comment">                             asm __volatile__(""); // thwart tail-call optimization</span></span><br><span class="line"><span class="comment">                         &#125;</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);</span><br><span class="line">                        CHECK_FOR_FORK();</span><br><span class="line">                        <span class="comment">// 将处理 source0 的结果置为 true</span></span><br><span class="line">                        sourceHandled = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        __CFRunLoopSourceUnlock(rls);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 对 rls 解锁，来到这，说明 rls 没有被标记为 signaled</span></span><br><span class="line">                    __CFRunLoopSourceUnlock(rls);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果有一个 source0 处理完成且 传入的 stopAfterHandle 为 true，则跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (stopAfterHandle &amp;&amp; sourceHandled)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放 sources</span></span><br><span class="line">        CFRelease(sources);</span><br><span class="line">        <span class="comment">// 对 runloop 加锁</span></span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        <span class="comment">// 对 mode 解锁</span></span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回处理 source0 结果</span></span><br><span class="line">    <span class="keyword">return</span> sourceHandled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而真正执行回调的是 <code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</code> 函数，其内部实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__() __attribute__((noinline));</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(<span class="keyword">void</span> (*perform)(<span class="keyword">void</span> *), <span class="keyword">void</span> *info)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (perform)</span><br><span class="line">    &#123;</span><br><span class="line">        perform(info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">asm</span> __volatile__(<span class="string">""</span>); <span class="comment">// thwart tail-call optimization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="Xn8lf"></a></p>
<h3 id="CFRunLoopDoSource1"><a href="#CFRunLoopDoSource1" class="headerlink" title="__CFRunLoopDoSource1"></a>__CFRunLoopDoSource1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msg, size and reply are unused on Windows</span></span><br><span class="line"><span class="keyword">static</span> Boolean __CFRunLoopDoSource1() __attribute__((noinline));</span><br><span class="line"><span class="keyword">static</span> Boolean __CFRunLoopDoSource1(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopSourceRef rls</span><br><span class="line">#<span class="keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">                                    ,</span><br><span class="line">                                    <span class="keyword">mach_msg_header_t</span> *msg, CFIndex size, <span class="keyword">mach_msg_header_t</span> **reply</span><br><span class="line">#endif</span><br><span class="line">)</span><br><span class="line">&#123; <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="comment">// 初始化 是否处理成功 source1 结果</span></span><br><span class="line">    Boolean sourceHandled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fire a version 1 source */</span></span><br><span class="line">    <span class="comment">// 对 source1 进行 retian</span></span><br><span class="line">    CFRetain(rls);</span><br><span class="line">    <span class="comment">// 对 mode 解锁</span></span><br><span class="line">    __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    <span class="comment">// 对 runloop 解锁</span></span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="comment">// 对 source1 加锁</span></span><br><span class="line">    __CFRunLoopSourceLock(rls);</span><br><span class="line">    <span class="comment">// 如果 source1 有效</span></span><br><span class="line">    <span class="keyword">if</span> (__CFIsValid(rls))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         // Bit 1 of the base reserved bits is used for signalled state</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         CF_INLINE Boolean __CFRunLoopSourceIsSignaled(CFRunLoopSourceRef rls)</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">             return (Boolean)__CFBitfieldGetValue(rls-&gt;_bits, 1, 1);</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         CF_INLINE void __CFRunLoopSourceSetSignaled(CFRunLoopSourceRef rls)</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">             __CFBitfieldSetValue(rls-&gt;_bits, 1, 1, 1);</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         CF_INLINE void __CFRunLoopSourceUnsetSignaled(CFRunLoopSourceRef rls)</span></span><br><span class="line"><span class="comment">         &#123;</span></span><br><span class="line"><span class="comment">             __CFBitfieldSetValue(rls-&gt;_bits, 1, 1, 0);</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 设置 source1 状态为未激活</span></span><br><span class="line">        __CFRunLoopSourceUnsetSignaled(rls);</span><br><span class="line">        <span class="comment">// 解锁 source1</span></span><br><span class="line">        __CFRunLoopSourceUnlock(rls);</span><br><span class="line">        __CFRunLoopDebugInfoForRunLoopSource(rls);</span><br><span class="line">        <span class="comment">// 执行 source1 回调</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(rls-&gt;_context.version1.perform,</span><br><span class="line">#<span class="keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">                                                                   msg, size, reply,</span><br><span class="line">#endif</span><br><span class="line">                                                                   rls-&gt;_context.version1.info);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">        sourceHandled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 写入到日志，source1 失效</span></span><br><span class="line">        <span class="keyword">if</span> (_LogCFRunLoop)</span><br><span class="line">        &#123;</span><br><span class="line">            CFLog(kCFLogLevelDebug, CFSTR(<span class="string">"%p (%s) __CFRunLoopDoSource1 rls %p is invalid"</span>), CFRunLoopGetCurrent(), *_CFGetProgname(), rls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对 source1 解锁</span></span><br><span class="line">        __CFRunLoopSourceUnlock(rls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放 source1</span></span><br><span class="line">    CFRelease(rls);</span><br><span class="line">    <span class="comment">// 对 runloop 加锁</span></span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="comment">// 对 mode 加锁</span></span><br><span class="line">    __CFRunLoopModeLock(rlm);</span><br><span class="line">    <span class="keyword">return</span> sourceHandled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中真正的回调函数为 <code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</code> ，其内部实现为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__() __attribute__((noinline));</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(</span><br><span class="line">#<span class="keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span><br><span class="line">    <span class="keyword">void</span> *(*perform)(<span class="keyword">void</span> *msg, CFIndex size, CFAllocatorRef allocator, <span class="keyword">void</span> *info),</span><br><span class="line">    <span class="keyword">mach_msg_header_t</span> *msg, CFIndex size, <span class="keyword">mach_msg_header_t</span> **reply,</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    <span class="keyword">void</span> (*perform)(<span class="keyword">void</span> *),</span><br><span class="line">#endif</span><br><span class="line">    <span class="keyword">void</span> *info)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (perform)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">        *reply = perform(msg, size, kCFAllocatorSystemDefault, info);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        perform(info);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">asm</span> __volatile__(<span class="string">""</span>); <span class="comment">// thwart tail-call optimization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="CqLBJ"></a></p>
<h3 id="CFRunLoopDoTimers"><a href="#CFRunLoopDoTimers" class="headerlink" title="__CFRunLoopDoTimers"></a>__CFRunLoopDoTimers</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rl and rlm are locked on entry and exit</span></span><br><span class="line"><span class="keyword">static</span> Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, <span class="keyword">uint64_t</span> limitTSR)</span><br><span class="line">&#123; <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    <span class="comment">// 初始化 timer 是否被处理成功 结果</span></span><br><span class="line">    Boolean timerHandled = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 初始化一个空的 timers 集合</span></span><br><span class="line">    CFMutableArrayRef timers = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 遍历 mode 的 _itemrs 定时器数组</span></span><br><span class="line">    <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>, cnt = rlm-&gt;_timers ? CFArrayGetCount(rlm-&gt;_timers) : <span class="number">0</span>; idx &lt; cnt; idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取出 timer</span></span><br><span class="line">        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, idx);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 timer 有效且尚未被触发</span></span><br><span class="line">        <span class="keyword">if</span> (__CFIsValid(rlt) &amp;&amp; !__CFRunLoopTimerIsFiring(rlt))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 并且 timer 的触发时间小于等于 限定的时间</span></span><br><span class="line">            <span class="keyword">if</span> (rlt-&gt;_fireTSR &lt;= limitTSR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 初始化 timers 集合</span></span><br><span class="line">                <span class="keyword">if</span> (!timers)</span><br><span class="line">                    timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeArrayCallBacks);</span><br><span class="line">                <span class="comment">// 把 timer 加入 timers 集合</span></span><br><span class="line">                CFArrayAppendValue(timers, rlt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 timers 集合，里面装的都是要干活的 timer</span></span><br><span class="line">    <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>, cnt = timers ? CFArrayGetCount(timers) : <span class="number">0</span>; idx &lt; cnt; idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取出 timer</span></span><br><span class="line">        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);</span><br><span class="line">        <span class="comment">// 执行 timer 回调</span></span><br><span class="line">        Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt);</span><br><span class="line">        timerHandled = timerHandled || did;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放 timers 集合</span></span><br><span class="line">    <span class="keyword">if</span> (timers)</span><br><span class="line">        CFRelease(timers);</span><br><span class="line">    <span class="keyword">return</span> timerHandled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt)</span><br><span class="line">&#123; <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    <span class="comment">// 初始化 timer 被处理成功结果</span></span><br><span class="line">    Boolean timerHandled = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> oldFireTSR = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fire a timer */</span></span><br><span class="line">    <span class="comment">// 对 timer retain</span></span><br><span class="line">    CFRetain(rlt);</span><br><span class="line">    <span class="comment">// 对 timer 加锁</span></span><br><span class="line">    __CFRunLoopTimerLock(rlt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 timer 有效，并且 timer 触发时间点未到，以及 timer 没有被触发，以及 timer 的 runloop 就是传入的 runloop ，进入 if 逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (__CFIsValid(rlt) &amp;&amp; rlt-&gt;_fireTSR &lt;= mach_absolute_time() &amp;&amp; !__CFRunLoopTimerIsFiring(rlt) &amp;&amp; rlt-&gt;_runLoop == rl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化空的 context_info</span></span><br><span class="line">        <span class="keyword">void</span> *context_info = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 初始化空的 context_release 函数指针</span></span><br><span class="line">        <span class="keyword">void</span> (*context_release)(<span class="keyword">const</span> <span class="keyword">void</span> *) = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 如果 timer 的 context 属性的 retain 函数指针不为空，进入 if 逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (rlt-&gt;_context.retain)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将 info retain 后赋值给 context_info</span></span><br><span class="line">            context_info = (<span class="keyword">void</span> *)rlt-&gt;_context.retain(rlt-&gt;_context.info);</span><br><span class="line">            <span class="comment">// 取出 timer 的 release 函数指针赋值给 context_release</span></span><br><span class="line">            context_release = rlt-&gt;_context.release;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出 timer 的 info</span></span><br><span class="line">            context_info = rlt-&gt;_context.info;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// timer 的时间间隔是否为 0</span></span><br><span class="line">        Boolean doInvalidate = (<span class="number">0.0</span> == rlt-&gt;_interval);</span><br><span class="line">        <span class="comment">// 设置 timer 的 是否触发的 bits 为1</span></span><br><span class="line">        __CFRunLoopTimerSetFiring(rlt);</span><br><span class="line">        <span class="comment">// Just in case the next timer has exactly the same deadlines as this one, we reset these values so that the arm next timer code can correctly find the next timer in the list and arm the underlying timer.</span></span><br><span class="line">        <span class="comment">// 以防万一下一个计时器与该计时器的截止日期完全相同，我们重置这些值，以便启用下一个计时器代码可以正确地找到列表中的下一个计时器并启用基础计时器。</span></span><br><span class="line">        rlm-&gt;_timerSoftDeadline = UINT64_MAX;</span><br><span class="line">        rlm-&gt;_timerHardDeadline = UINT64_MAX;</span><br><span class="line">        <span class="comment">// 解锁 timer</span></span><br><span class="line">        __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">        <span class="comment">// 对 timer 触发加锁</span></span><br><span class="line">        __CFRunLoopTimerFireTSRLock();</span><br><span class="line">        <span class="comment">// 取出 _fireTSR</span></span><br><span class="line">        oldFireTSR = rlt-&gt;_fireTSR;</span><br><span class="line">        <span class="comment">// 对 timer 触发解锁</span></span><br><span class="line">        __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 装配下一个 timer</span></span><br><span class="line">        __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对 mode 解锁</span></span><br><span class="line">        __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        <span class="comment">// 对 runloop 解锁</span></span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">        <span class="comment">// 执行 timer 真正的回调</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">        <span class="comment">// 如果 timer 只跑一次</span></span><br><span class="line">        <span class="keyword">if</span> (doInvalidate)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 让 timer 失效</span></span><br><span class="line">            CFRunLoopTimerInvalidate(rlt); <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 context_release 函数指针不为空，则释放掉 context_info</span></span><br><span class="line">        <span class="keyword">if</span> (context_release)</span><br><span class="line">        &#123;</span><br><span class="line">            context_release(context_info);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对 runloop 加锁</span></span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        <span class="comment">// 对 mode 解锁</span></span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line">        <span class="comment">// 对 timer 加锁</span></span><br><span class="line">        __CFRunLoopTimerLock(rlt);</span><br><span class="line">        <span class="comment">// 设置 处理 timer 结果为 true</span></span><br><span class="line">        timerHandled = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 设置 timer 的 是否触发的 bits 为0</span></span><br><span class="line">        __CFRunLoopTimerUnsetFiring(rlt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 timer 有效，并且 timer 被处理成功</span></span><br><span class="line">    <span class="keyword">if</span> (__CFIsValid(rlt) &amp;&amp; timerHandled)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* This is just a little bit tricky: we want to support calling</span></span><br><span class="line"><span class="comment">         * CFRunLoopTimerSetNextFireDate() from within the callout and</span></span><br><span class="line"><span class="comment">         * honor that new time here if it is a later date, otherwise</span></span><br><span class="line"><span class="comment">         * it is completely ignored. */</span></span><br><span class="line">        <span class="comment">// 如果 旧的触发时间 小于 当前的触发时间</span></span><br><span class="line">        <span class="keyword">if</span> (oldFireTSR &lt; rlt-&gt;_fireTSR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Next fire TSR was set, and set to a date after the previous</span></span><br><span class="line"><span class="comment">            * fire date, so we honor it. */</span></span><br><span class="line">            __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">            <span class="comment">// The timer was adjusted and repositioned, during the</span></span><br><span class="line">            <span class="comment">// callout, but if it was still the min timer, it was</span></span><br><span class="line">            <span class="comment">// skipped because it was firing.  Need to redo the</span></span><br><span class="line">            <span class="comment">// min timer calculation in case rlt should now be that</span></span><br><span class="line">            <span class="comment">// timer instead of whatever was chosen.</span></span><br><span class="line">            __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> nextFireTSR = <span class="number">0L</span>L;</span><br><span class="line">            <span class="keyword">uint64_t</span> intervalTSR = <span class="number">0L</span>L;</span><br><span class="line">            <span class="keyword">if</span> (rlt-&gt;_interval &lt;= <span class="number">0.0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (TIMER_INTERVAL_LIMIT &lt; rlt-&gt;_interval)</span><br><span class="line">            &#123;</span><br><span class="line">                intervalTSR = __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                intervalTSR = __CFTimeIntervalToTSR(rlt-&gt;_interval);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (LLONG_MAX - intervalTSR &lt;= oldFireTSR)</span><br><span class="line">            &#123;</span><br><span class="line">                nextFireTSR = LLONG_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (intervalTSR == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 15304159: Make sure we don't accidentally loop forever here</span></span><br><span class="line">                    CRSetCrashLogMessage(<span class="string">"A CFRunLoopTimer with an interval of 0 is set to repeat"</span>);</span><br><span class="line">                    HALT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">uint64_t</span> currentTSR = mach_absolute_time();</span><br><span class="line">                nextFireTSR = oldFireTSR;</span><br><span class="line">                <span class="keyword">while</span> (nextFireTSR &lt;= currentTSR)</span><br><span class="line">                &#123;</span><br><span class="line">                    nextFireTSR += intervalTSR;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            CFRunLoopRef rlt_rl = rlt-&gt;_runLoop;</span><br><span class="line">            <span class="keyword">if</span> (rlt_rl)</span><br><span class="line">            &#123;</span><br><span class="line">                CFRetain(rlt_rl);</span><br><span class="line">                CFIndex cnt = CFSetGetCount(rlt-&gt;_rlModes);</span><br><span class="line">                STACK_BUFFER_DECL(CFTypeRef, modes, cnt);</span><br><span class="line">                CFSetGetValues(rlt-&gt;_rlModes, (<span class="keyword">const</span> <span class="keyword">void</span> **)modes);</span><br><span class="line">                <span class="comment">// To avoid A-&gt;B, B-&gt;A lock ordering issues when coming up</span></span><br><span class="line">                <span class="comment">// towards the run loop from a source, the timer has to be</span></span><br><span class="line">                <span class="comment">// unlocked, which means we have to protect from object</span></span><br><span class="line">                <span class="comment">// invalidation, although that's somewhat expensive.</span></span><br><span class="line">                <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>; idx &lt; cnt; idx++)</span><br><span class="line">                &#123;</span><br><span class="line">                    CFRetain(modes[idx]);</span><br><span class="line">                &#125;</span><br><span class="line">                __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">                <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>; idx &lt; cnt; idx++)</span><br><span class="line">                &#123;</span><br><span class="line">                    CFStringRef name = (CFStringRef)modes[idx];</span><br><span class="line">                    modes[idx] = (CFTypeRef)__CFRunLoopFindMode(rlt_rl, name, <span class="literal">false</span>);</span><br><span class="line">                    CFRelease(name);</span><br><span class="line">                &#125;</span><br><span class="line">                __CFRunLoopTimerFireTSRLock();</span><br><span class="line">                rlt-&gt;_fireTSR = nextFireTSR;</span><br><span class="line">                rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR);</span><br><span class="line">                <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>; idx &lt; cnt; idx++)</span><br><span class="line">                &#123;</span><br><span class="line">                    CFRunLoopModeRef rlm = (CFRunLoopModeRef)modes[idx];</span><br><span class="line">                    <span class="keyword">if</span> (rlm)</span><br><span class="line">                    &#123;</span><br><span class="line">                        __CFRepositionTimerInMode(rlm, rlt, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">                <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>; idx &lt; cnt; idx++)</span><br><span class="line">                &#123;</span><br><span class="line">                    __CFRunLoopModeUnlock((CFRunLoopModeRef)modes[idx]);</span><br><span class="line">                &#125;</span><br><span class="line">                CFRelease(rlt_rl);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">                __CFRunLoopTimerFireTSRLock();</span><br><span class="line">                rlt-&gt;_fireTSR = nextFireTSR;</span><br><span class="line">                rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTimeIntervalUntilTSR(nextFireTSR);</span><br><span class="line">                __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 解锁 timer</span></span><br><span class="line">        __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放掉 timer</span></span><br><span class="line">    CFRelease(rlt);</span><br><span class="line">    <span class="keyword">return</span> timerHandled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中真正执行回调的是 <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong> 函数，其内部实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__() __attribute__((noinline));</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(CFRunLoopTimerCallBack func, CFRunLoopTimerRef timer, <span class="keyword">void</span> *info)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (func)</span><br><span class="line">    &#123;</span><br><span class="line">        func(timer, info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">asm</span> __volatile__(<span class="string">""</span>); <span class="comment">// thwart tail-call optimization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="c2oZn"></a></p>
<h3 id="CFRUNLOOP-IS-SERVICING-THE-MAIN-DISPATCH-QUEUE"><a href="#CFRUNLOOP-IS-SERVICING-THE-MAIN-DISPATCH-QUEUE" class="headerlink" title="CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE"></a><strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() __attribute__((noinline));</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(<span class="keyword">void</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">    _dispatch_main_queue_callback_4CF(msg);</span><br><span class="line">    <span class="keyword">asm</span> __volatile__(<span class="string">""</span>); <span class="comment">// thwart tail-call optimization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200316102221.jpg" alt="RunLoop 流程"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解 RunLoop - ibireme</a></p>
<p><a href="http://mrpeak.cn/blog/ios-runloop/" target="_blank" rel="noopener">解密 RunLoop - MrPeak</a></p>
<p><a href="https://www.jianshu.com/p/5c98ac2dab58" target="_blank" rel="noopener">Core Foundation 详解</a></p>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode3.jpg" alt="leejunhui wechat" style="width: 200px; max-width: 100%;">
    <div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div>
</div>

      </div>
    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    leejunhui
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://leejunhui.com/2020/03/16/iOS-查漏补缺-RunLoop/" title="iOS 查漏补缺 - RunLoop">http://leejunhui.com/2020/03/16/iOS-查漏补缺-RunLoop/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/Objective-C/" rel="tag"># Objective-C</a>
          
            <a href="/tags/RunLoop/" rel="tag"># RunLoop</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/13/iOS-查漏补缺-线程/" rel="next" title="iOS 查漏补缺 - 线程">
                <i class="fa fa-chevron-left"></i> iOS 查漏补缺 - 线程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="leejunhui">
            
              <p class="site-author-name" itemprop="name">leejunhui</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RunLoop-前导知识"><span class="nav-number">1.</span> <span class="nav-text">RunLoop 前导知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS-OS-X-系统架构"><span class="nav-number">1.1.</span> <span class="nav-text">iOS/OS X 系统架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#iOS-进化史"><span class="nav-number">1.1.1.</span> <span class="nav-text">iOS 进化史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iOS-系统架构"><span class="nav-number">1.1.2.</span> <span class="nav-text">iOS 系统架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Darwin-架构"><span class="nav-number">1.1.3.</span> <span class="nav-text">Darwin 架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mach-msg-函数"><span class="nav-number">1.2.</span> <span class="nav-text">mach_msg 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CoreFoundation-基础"><span class="nav-number">1.3.</span> <span class="nav-text">CoreFoundation 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bridge"><span class="nav-number">1.3.1.</span> <span class="nav-text">__bridge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bridge-retained"><span class="nav-number">1.3.2.</span> <span class="nav-text">__bridge_retained</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bridge-transfer"><span class="nav-number">1.3.3.</span> <span class="nav-text">__bridge_transfer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Toll-Free-bridged"><span class="nav-number">1.3.4.</span> <span class="nav-text">Toll-Free bridged</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RunLoop-初探"><span class="nav-number">2.</span> <span class="nav-text">RunLoop 初探</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是-RunLoop"><span class="nav-number">2.1.</span> <span class="nav-text">什么是 RunLoop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-底层数据结构"><span class="nav-number">2.2.</span> <span class="nav-text">RunLoop 底层数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopRef"><span class="nav-number">2.2.1.</span> <span class="nav-text">CFRunLoopRef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopModeRef"><span class="nav-number">2.2.2.</span> <span class="nav-text">CFRunLoopModeRef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopSourceRef"><span class="nav-number">2.2.3.</span> <span class="nav-text">CFRunLoopSourceRef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopTimerRef"><span class="nav-number">2.2.4.</span> <span class="nav-text">CFRunLoopTimerRef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopObserverRef"><span class="nav-number">2.2.5.</span> <span class="nav-text">CFRunLoopObserverRef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopActivity"><span class="nav-number">2.2.6.</span> <span class="nav-text">CFRunLoopActivity</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-与线程关系"><span class="nav-number">2.3.</span> <span class="nav-text">RunLoop 与线程关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Runloop-底层"><span class="nav-number">3.</span> <span class="nav-text">Runloop 底层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-启动方式"><span class="nav-number">3.1.</span> <span class="nav-text">RunLoop 启动方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-核心逻辑"><span class="nav-number">3.2.</span> <span class="nav-text">RunLoop 核心逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CFRunLoopRun-完整代码"><span class="nav-number">3.3.</span> <span class="nav-text">__CFRunLoopRun 完整代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CFRunLoopRun-精简代码"><span class="nav-number">3.4.</span> <span class="nav-text">__CFRunLoopRun 精简代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-执行的任务"><span class="nav-number">3.5.</span> <span class="nav-text">RunLoop 执行的任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopDoObservers"><span class="nav-number">3.5.1.</span> <span class="nav-text">__CFRunLoopDoObservers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopDoBlocks"><span class="nav-number">3.5.2.</span> <span class="nav-text">__CFRunLoopDoBlocks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopDoSources0"><span class="nav-number">3.5.3.</span> <span class="nav-text">__CFRunLoopDoSources0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopDoSource1"><span class="nav-number">3.5.4.</span> <span class="nav-text">__CFRunLoopDoSource1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRunLoopDoTimers"><span class="nav-number">3.5.5.</span> <span class="nav-text">__CFRunLoopDoTimers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CFRUNLOOP-IS-SERVICING-THE-MAIN-DISPATCH-QUEUE"><span class="nav-number">3.5.6.</span> <span class="nav-text">CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">5.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leejunhui</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        




  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=66522444";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
