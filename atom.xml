<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>leejunhui&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://leejunhui.com/"/>
  <updated>2020-03-12T09:30:01.251Z</updated>
  <id>http://leejunhui.com/</id>
  
  <author>
    <name>leejunhui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 查漏补缺 - performSelector</title>
    <link href="http://leejunhui.com/2020/03/12/iOS-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-performSelector/"/>
    <id>http://leejunhui.com/2020/03/12/iOS-查漏补缺-performSelector/</id>
    <published>2020-03-12T09:28:13.000Z</published>
    <updated>2020-03-12T09:30:01.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-查漏补缺-PerformSelector"><a href="#iOS-查漏补缺-PerformSelector" class="headerlink" title="iOS 查漏补缺 - PerformSelector"></a>iOS 查漏补缺 - PerformSelector</h1><blockquote><p><code>performSelector</code> 系列的函数我们都不陌生，但是对于它不同的变种以及底层原理在很多时候还是容易分不清楚，所以笔者希望通过 <code>runtime</code> 源码以及 <code>GUNStep</code> 源码来一个个抽丝剥茧，把不同变种的 <code>performSelector</code> 理顺，并搞清楚每个方法的底层实现，如有错误，欢迎指正。</p><p>本文的代码已放在 <a href="https://github.com/LeeJunhui/PerformSelectorIndepth" target="_blank" rel="noopener">Github</a> ，欢迎自取</p></blockquote><a id="more"></a><h1 id="一、NSObject-下的-PerformSelector"><a href="#一、NSObject-下的-PerformSelector" class="headerlink" title="一、NSObject 下的 PerformSelector"></a>一、NSObject 下的 <code>PerformSelector</code></h1><h2 id="1-1-performSelector-SEL-aSelector"><a href="#1-1-performSelector-SEL-aSelector" class="headerlink" title="1.1 performSelector:(SEL)aSelector"></a>1.1 <code>performSelector:(SEL)aSelector</code></h2><p><code>performSelector</code> 方法是最简单的一个 <code>api</code>，使用方法如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)jh_performSelector</span><br><span class="line">&#123;</span><br><span class="line">     [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(task)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">13</span>:<span class="number">26.321254</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">61807</span>:<span class="number">828757</span>] -[ViewController task]</span><br></pre></td></tr></table></figure><p><code>performSelector:</code> 方法只需要传入一个 <code>SEL</code>，在 <code>runtime</code> 底层实现为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(<span class="keyword">self</span>, sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-performSelector-SEL-aSelector-withObject-id-object"><a href="#1-2-performSelector-SEL-aSelector-withObject-id-object" class="headerlink" title="1.2 performSelector:(SEL)aSelector withObject:(id)object"></a>1.2 <code>performSelector:(SEL)aSelector withObject:(id)object</code></h2><p><code>performSelector:withObject:</code> 方法相比于上一个方法多了一个参数，使用起来如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)jh_performSelectorWithObj</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(taskWithParam:) withObject:@&#123;<span class="string">@"param"</span>: <span class="string">@"leejunhui"</span>&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)taskWithParam:(<span class="built_in">NSDictionary</span> *)param</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">34.473153</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">61790</span>:<span class="number">827408</span>] -[ViewController taskWithParam:]</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">34.473381</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">61790</span>:<span class="number">827408</span>] &#123;</span><br><span class="line">    param = leejunhui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>performSelector:withObject:</code> 方法底层实现如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)sel withObject:(<span class="keyword">id</span>)obj &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))objc_msgSend)(<span class="keyword">self</span>, sel, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-performSelector-SEL-aSelector-withObject-id-object1-withObject-id-object2"><a href="#1-3-performSelector-SEL-aSelector-withObject-id-object1-withObject-id-object2" class="headerlink" title="1.3 performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2"></a>1.3 <code>performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2</code></h2><p>这个方法相比上一个方法又多了一个参数:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)jh_performSelectorWithObj1AndObj2</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(taskWithParam1:param2:) withObject:@&#123;<span class="string">@"param1"</span>: <span class="string">@"lee"</span>&#125; withObject:@&#123;<span class="string">@"param2"</span>: <span class="string">@"junhui"</span>&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)taskWithParam1:(<span class="built_in">NSDictionary</span> *)param1 param2:(<span class="built_in">NSDictionary</span> *)param2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, param1);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, param2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">17</span>:<span class="number">52.889731</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">61859</span>:<span class="number">833076</span>] -[ViewController taskWithParam1:param2:]</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">17</span>:<span class="number">52.889921</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">61859</span>:<span class="number">833076</span>] &#123;</span><br><span class="line">    param1 = lee;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">17</span>:<span class="number">52.890009</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">61859</span>:<span class="number">833076</span>] &#123;</span><br><span class="line">    param2 = junhui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>performSelector:withObject:withObject:</code> 方法底层实现如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)sel withObject:(<span class="keyword">id</span>)obj1 withObject:(<span class="keyword">id</span>)obj2 &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>, <span class="keyword">id</span>))objc_msgSend)(<span class="keyword">self</span>, sel, obj1, obj2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h2><table><thead><tr><th>方法</th><th>底层实现</th></tr></thead><tbody><tr><td>performSelector:</td><td>((id(*)(id, SEL))objc_msgSend)(self, sel)</td></tr><tr><td>performSelector:withObject:</td><td>((id(*)(id, SEL, id))objc_msgSend)(self, sel, obj)</td></tr><tr><td>performSelector:withObject:withObject:</td><td>((id(*)(id, SEL, id, id))objc_msgSend)(self, sel, obj1, obj2)</td></tr></tbody></table><p>这三个方法应该是使用频率很高的 <code>performSelector</code> 系列方法了，我们只需要记住这三个方法在底层都是执行的<strong>消息发送</strong>即可。</p><h1 id="二、Runloop-相关的-PerformSelector"><a href="#二、Runloop-相关的-PerformSelector" class="headerlink" title="二、Runloop 相关的 PerformSelector"></a>二、Runloop 相关的 <code>PerformSelector</code></h1><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200312163817.jpg" alt></p><p>如上图所示，在 <code>NSRunLoop</code> 头文件中，定义了两个的分类，分别是 </p><ul><li><code>NSDelayedPerforming</code> 对应于 <code>NSObject</code> </li><li><code>NSOrderedPerform</code> 对应于 <code>NSRunLoop</code></li></ul><h2 id="2-1-NSObject-分类-NSDelayedPerforming"><a href="#2-1-NSObject-分类-NSDelayedPerforming" class="headerlink" title="2.1 NSObject 分类 NSDelayedPerforming"></a>2.1 NSObject 分类 NSDelayedPerforming</h2><h3 id="2-1-1-performSelector-WithObject-afterDelay"><a href="#2-1-1-performSelector-WithObject-afterDelay" class="headerlink" title="2.1.1 performSelector:WithObject:afterDelay:"></a>2.1.1 <code>performSelector:WithObject:afterDelay:</code></h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)jh_performSelectorwithObjectafterDelay</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(taskWithParam:) withObject:@&#123;<span class="string">@"param"</span>: <span class="string">@"leejunhui"</span>&#125; afterDelay:<span class="number">1.</span>f];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)taskWithParam:(<span class="built_in">NSDictionary</span> *)param</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">01.475634</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">61898</span>:<span class="number">838345</span>] -[ViewController taskWithParam:]</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">25</span>:<span class="number">01.475837</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">61898</span>:<span class="number">838345</span>] &#123;</span><br><span class="line">    param = leejunhui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the default mode (NSDefaultRunLoopMode). When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in the default mode; otherwise, the timer waits until the run loop is in the default mode.</p><p>这个方法会在当前线程所对应的 runloop 中设置一个定时器来执行传入的 SEL。定时器需要在 NSDefaultRunLoopMode 模式下才会被触发。当定时器启动后，线程会尝试从 runloop 中取出 SEL 然后执行。<br>     如果 runloop 已经启动并且处于 NSDefaultRunLoopMode 的话，SEL 执行成功。否则，直到 runloop 处于 NSDefaultRunLoopMode 前，timer 都会一直等待</p></blockquote><p>通过断点调试如下图所示，runloop 底层最终是通过 <code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ ()</code>来触发任务的执行。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200312163803.jpg" alt></p><p>因为 <code>NSRunLoop</code> 并没有开源，所以我们只能通过 <code>GNUStep</code> 来窥探底层实现细节，如下所示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) performSelector: (SEL)aSelector</span><br><span class="line">      withObject: (<span class="keyword">id</span>)argument</span><br><span class="line">      afterDelay: (<span class="built_in">NSTimeInterval</span>)seconds</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSRunLoop</span>*loop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">  GSTimedPerformer*item;</span><br><span class="line"></span><br><span class="line">  item = [[GSTimedPerformer alloc] initWithSelector: aSelector</span><br><span class="line">     target: <span class="keyword">self</span></span><br><span class="line">   argument: argument</span><br><span class="line">      delay: seconds];</span><br><span class="line">  [[loop _timedPerformers] addObject: item];</span><br><span class="line">  RELEASE(item);</span><br><span class="line">  [loop addTimer: item-&gt;timer forMode: <span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The GSTimedPerformer class is used to hold information about</span></span><br><span class="line"><span class="comment"> * messages which are due to be sent to objects at a particular time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GSTimedPerformer</span>: <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">  SELselector;</span><br><span class="line">  <span class="keyword">id</span>target;</span><br><span class="line">  <span class="keyword">id</span>argument;</span><br><span class="line">  <span class="built_in">NSTimer</span>*timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) fire;</span><br><span class="line">- (<span class="keyword">id</span>) initWithSelector: (SEL)aSelector</span><br><span class="line"> target: (<span class="keyword">id</span>)target</span><br><span class="line">       argument: (<span class="keyword">id</span>)argument</span><br><span class="line">  delay: (<span class="built_in">NSTimeInterval</span>)delay;</span><br><span class="line">- (<span class="keyword">void</span>) invalidate;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们可以看到，在 <code>performSelector:WithObject:afterDelay:</code> 底层</p><ul><li>获取当前线程的 <code>NSRunLoop</code> 对象。</li><li>通过传入的 <code>SEL</code> 、<code>argument</code> 和 <code>delay</code> 初始化一个 <code>GSTimedPerformer</code> 实例对象，<code>GSTimedPerformer</code> 类型里面封装了 <code>NSTimer</code> 对象。</li><li>然后把 <code>GSTimedPerformer</code> 实例加入到 <code>RunLoop</code> 对象的 <code>_timedPerformers</code> 成员变量中</li><li>释放掉 <code>GSTimedPerformer</code> 对象</li><li>以 <code>default mode</code> 将 <code>timer</code> 对象加入到 <code>runloop</code> 中</li></ul><h3 id="2-1-2-performSelector-WithObject-afterDelay-inModes"><a href="#2-1-2-performSelector-WithObject-afterDelay-inModes" class="headerlink" title="2.1.2 performSelector:WithObject:afterDelay:inModes"></a>2.1.2 <code>performSelector:WithObject:afterDelay:inModes</code></h3><p><code>performSelector:WithObject:afterDelay:inModes</code> 方法相比上个方法多了一个 <code>modes</code> 参数，根据官方文档的定义，只有当 <code>runloop</code> 处于 <code>modes</code> 中的任意一个 <code>mode</code> 时，才会执行任务，如果 <code>modes</code> 为空，那么将不会执行任务。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)jh_performSelectorwithObjectafterDelayInModes</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(taskWithParam:) withObject:@&#123;<span class="string">@"param"</span>: <span class="string">@"leejunhui"</span>&#125; afterDelay:<span class="number">1.</span>f inModes:@[<span class="built_in">NSRunLoopCommonModes</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)taskWithParam:(<span class="built_in">NSDictionary</span> *)param</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印如下</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">38</span>:<span class="number">58.479152</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">62006</span>:<span class="number">851520</span>] -[ViewController taskWithParam:]</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">38</span>:<span class="number">58.479350</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">62006</span>:<span class="number">851520</span>] &#123;</span><br><span class="line">    param = leejunhui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里我们如果把 <code>modes</code> 参数改为 <code>UITrackingRunLoopMode</code>，那么就只有在 <code>scrollView</code> 发生滚动的时候才会触发 timer</p></blockquote><p>我们再看一下 <code>GNUStep</code> 对应的实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) performSelector: (SEL)aSelector</span><br><span class="line">      withObject: (<span class="keyword">id</span>)argument</span><br><span class="line">      afterDelay: (<span class="built_in">NSTimeInterval</span>)seconds</span><br><span class="line"> inModes: (<span class="built_in">NSArray</span>*)modes</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span>count = [modes count];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">NSRunLoop</span>*loop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">      <span class="built_in">NSString</span>*marray[count];</span><br><span class="line">      GSTimedPerformer*item;</span><br><span class="line">      <span class="keyword">unsigned</span>i;</span><br><span class="line"></span><br><span class="line">      item = [[GSTimedPerformer alloc] initWithSelector: aSelector</span><br><span class="line"> target: <span class="keyword">self</span></span><br><span class="line">       argument: argument</span><br><span class="line">  delay: seconds];</span><br><span class="line">      [[loop _timedPerformers] addObject: item];</span><br><span class="line">      RELEASE(item);</span><br><span class="line">      <span class="keyword">if</span> ([modes isProxy])</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      marray[i] = [modes objectAtIndex: i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">          [modes getObjects: marray];</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">&#123;</span><br><span class="line">  [loop addTimer: item-&gt;timer forMode: marray[i]];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>可以看到，相比于上一个方法的底层实现不同的是，这里会循环添加不同 <code>mode</code> 的 <code>timer</code> 对象到 <code>runloop</code> 中。</p><h3 id="2-1-3-cancelPreviousPerformRequestsWithTarget-和-cancelPreviousPerformRequestsWithTarget-selector-object"><a href="#2-1-3-cancelPreviousPerformRequestsWithTarget-和-cancelPreviousPerformRequestsWithTarget-selector-object" class="headerlink" title="2.1.3 cancelPreviousPerformRequestsWithTarget: 和 cancelPreviousPerformRequestsWithTarget:selector:object:"></a>2.1.3 <code>cancelPreviousPerformRequestsWithTarget:</code> 和 <code>cancelPreviousPerformRequestsWithTarget:selector:object:</code></h3><p><code>cancelPreviousPerformRequestsWithTarget:</code> 方法和 <code>cancelPreviousPerformRequestsWithTarget:selector:object:</code> 方法是两个类方法，它们的作用是取消执行之前通过 <code>performSelector:WithObject:afterDelay:</code> 方法注册的任务。使用起来如下所示:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)jh_performSelectorwithObjectafterDelayInModes</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 只有当 scrollView 发生滚动时，才会触发timer</span></span><br><span class="line"><span class="comment">//    [self performSelector:@selector(taskWithParam:) withObject:@&#123;@"param": @"leejunhui"&#125; afterDelay:1.f inModes:@[UITrackingRunLoopMode]];</span></span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(taskWithParam:) withObject:@&#123;<span class="string">@"param"</span>: <span class="string">@"leejunhui"</span>&#125; afterDelay:<span class="number">5.</span>f inModes:@[<span class="built_in">NSRunLoopCommonModes</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)cancelTask &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    [ViewController cancelPreviousPerformRequestsWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(taskWithParam:) object:@&#123;<span class="string">@"param"</span>: <span class="string">@"leejunhui"</span>&#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [ViewController cancelPreviousPerformRequestsWithTarget:self];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">52</span>:<span class="number">33.549213</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">62172</span>:<span class="number">865289</span>] -[ViewController cancelTask]</span><br></pre></td></tr></table></figure><p>这里有一个区别，就是 <code>cancelPreviousPerformRequestsWithTarget:</code> 类方法会取消掉 <code>target</code> 上所有的通过 <code>performSelector:WithObject:afterDelay:</code> 实例方法注册的定时任务，而 <code>cancelPreviousPerformRequestsWithTarget:selector:object:</code> 只会通过传入的 <code>SEL</code> 取消匹配到的定时任务</p><p>在 <code>GNUStep</code> 中 <code>cancelPreviousPerformRequestsWithTarget:</code> 方法底层实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Cancels any perform operations set up for the specified target</span></span><br><span class="line"><span class="comment"> * in the current run loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>) cancelPreviousPerformRequestsWithTarget: (<span class="keyword">id</span>)target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span>*perf = [[<span class="built_in">NSRunLoop</span> currentRunLoop] _timedPerformers];</span><br><span class="line">    <span class="keyword">unsigned</span>count = [perf count];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GSTimedPerformer*array[count];</span><br><span class="line">        </span><br><span class="line">        IF_NO_GC(RETAIN(target));</span><br><span class="line">        [perf getObjects: array];</span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GSTimedPerformer*p = array[count];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (p-&gt;target == target)</span><br><span class="line">            &#123;</span><br><span class="line">                [p invalidate];</span><br><span class="line">                [perf removeObjectAtIndex: count];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RELEASE(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GSTimedPerformer 实例方法</span></span><br><span class="line">- (<span class="keyword">void</span>) invalidate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer != <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        [timer invalidate];</span><br><span class="line">        DESTROY(timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑其实很清晰：</p><ul><li>取出当前 runloop 对象的成员变量 <code>_timedPerformers</code></li><li>判断定时任务数组是否为空，不为空才会继续往下走</li><li>初始化一个局部的空的任务数组，然后通过 <code>getObjects</code> 从成员变量中取出任务</li><li>通过 while 循环遍历所有的任务，如果匹配到了对应的 <code>target</code>，则调用任务的 invalidate 方法，在这个方法内部会把定时器停掉然后销毁。接着还需要把成员变量 <code>_timedPerformers</code> 中对应的任务移除掉</li></ul><p>另一个取消任务的方法底层实现如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Cancels any perform operations set up for the specified target</span></span><br><span class="line"><span class="comment"> * in the current loop, but only if the value of aSelector and argument</span></span><br><span class="line"><span class="comment"> * with which the performs were set up match those supplied.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * Matching of the argument may be either by pointer equality or by</span></span><br><span class="line"><span class="comment"> * use of the [NSObject-isEqual:] method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>) cancelPreviousPerformRequestsWithTarget: (<span class="keyword">id</span>)target</span><br><span class="line">                                        selector: (SEL)aSelector</span><br><span class="line">                                          object: (<span class="keyword">id</span>)arg</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span>*perf = [[<span class="built_in">NSRunLoop</span> currentRunLoop] _timedPerformers];</span><br><span class="line">    <span class="keyword">unsigned</span>count = [perf count];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GSTimedPerformer*array[count];</span><br><span class="line">        </span><br><span class="line">        IF_NO_GC(RETAIN(target));</span><br><span class="line">        IF_NO_GC(RETAIN(arg));</span><br><span class="line">        [perf getObjects: array];</span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GSTimedPerformer*p = array[count];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (p-&gt;target == target &amp;&amp; sel_isEqual(p-&gt;selector, aSelector)</span><br><span class="line">                &amp;&amp; (p-&gt;argument == arg || [p-&gt;argument isEqual: arg]))</span><br><span class="line">            &#123;</span><br><span class="line">                [p invalidate];</span><br><span class="line">                [perf removeObjectAtIndex: count];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RELEASE(arg);</span><br><span class="line">        RELEASE(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的实现不一样的地方就是除了判断 <code>target</code> 是否匹配外，还会判断 <code>SEL</code> 是否匹配，以及参数是否匹配。</p><h3 id="2-1-4-小结"><a href="#2-1-4-小结" class="headerlink" title="2.1.4 小结"></a>2.1.4 小结</h3><ul><li><code>performSelector:WithObject:afterDelay:</code><ul><li>在该方法所在线程的 runloop 处于 default mode 时，根据给定的时间触发给定的任务。底层原理是把一个 timer 对象以 <strong>default mode</strong> 加入到 runloop 对象中，等待唤醒。</li></ul></li><li><code>performSelector:WithObject:afterDelay:inModes:</code><ul><li>在该方法所在线程的 runloop 处于给定的任一 mode 时，根据给定的时间触发给定的任务。底层原理是循环把一个 timer 对象以给定的 mode 加入到 runloop 对象中，等待唤醒。</li></ul></li><li><code>cancelPreviousPerformRequestsWithTarget:</code><ul><li>取消 <code>target</code> 对象通过 <code>performSelector:WithObject:afterDelay:</code>  方法或 <code>performSelector:WithObject:afterDelay:inModes:</code> 方法注册的<strong>所有定时任务</strong></li></ul></li><li><code>cancelPreviousPerformRequestsWithTarget:selector:object:</code><ul><li>取消 <code>target</code> 对象通过 <code>performSelector:WithObject:afterDelay:</code>  方法或 <code>performSelector:WithObject:afterDelay:inModes:</code> 方法注册的<strong>指定的定时任务</strong></li></ul></li></ul><p>这四个方法是作为 <code>NSObject</code> 的 <code>NSDelayedPerforming</code> 分类存在于 <code>NSRunLoop</code> 源代码中，所以我们在使用的时候要注意一个细节，那就是执行这些方法的线程是否是主线程，如果是主线程，那么执行起来是没有问题的，但是，<strong>如果是在子线程中执行这些方法，则需要开启子线程对应的 runloop 才能保证执行成功</strong>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)jh_performSelectorwithObjectafterDelay</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(taskWithParam:) withObject:@&#123;<span class="string">@"param"</span>: <span class="string">@"leejunhui"</span>&#125; afterDelay:<span class="number">1.</span>f];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    [self performSelector:@selector(taskWithParam:) withObject:@&#123;@"param": @"leejunhui"&#125; afterDelay:1.f];</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">- (<span class="keyword">void</span>)taskWithParam:(<span class="built_in">NSDictionary</span> *)param</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, param);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有输出</span></span><br></pre></td></tr></table></figure><p>如上所示的代码，通过 <code>GCD</code> 的异步执行函数在全局并发队列上执行任务，并没有任何打印输出，我们加入 runloop 的启动代码后结果将完全不一样：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200312163806.jpg" alt></p><p>对于 <code>performSelector:WithObject:afterDelay:inModes</code> 方法，如果遇到这样的情况，也是一样的解决方案。</p><h2 id="2-2-NSRunLoop-的分类-NSOrderedPerform"><a href="#2-2-NSRunLoop-的分类-NSOrderedPerform" class="headerlink" title="2.2 NSRunLoop 的分类 NSOrderedPerform"></a>2.2 NSRunLoop 的分类 NSOrderedPerform</h2><h3 id="2-2-1-performSelector-target-argument-order-modes"><a href="#2-2-1-performSelector-target-argument-order-modes" class="headerlink" title="2.2.1 performSelector:target:argument:order:modes:"></a>2.2.1 performSelector:target:argument:order:modes:</h3><p><code>performSelector:target:argument:order:modes:</code> 方法的调用者是 <code>NSRunLoop</code> 实例，然后需要传入要执行的 <code>SEL</code>，以及 <code>SEL</code> 对应的 <code>target</code>，和 <code>SEL</code> 要接收的参数 <code>argument</code>，最后是此次任务的优先级 <code>order</code>，以及一个 <strong>运行模式集合</strong> <code>modes</code>，目的是当 <code>runloop</code> 的 <code>currentMode</code> 处于这个运行模式集合中的其中任意一个 mode 时，就会按照优先级 <code>order</code> 来触发 <code>SEL</code> 的执行。具体使用如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)jh_performSelectorTargetArgumentOrderModes</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSRunLoop</span> *runloop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    [runloop performSelector:<span class="keyword">@selector</span>(runloopTask5) target:<span class="keyword">self</span> argument:<span class="literal">nil</span> order:<span class="number">5</span> modes:@[<span class="built_in">NSRunLoopCommonModes</span>]];</span><br><span class="line">    [runloop performSelector:<span class="keyword">@selector</span>(runloopTask1) target:<span class="keyword">self</span> argument:<span class="literal">nil</span> order:<span class="number">1</span> modes:@[<span class="built_in">NSRunLoopCommonModes</span>]];</span><br><span class="line">    [runloop performSelector:<span class="keyword">@selector</span>(runloopTask3) target:<span class="keyword">self</span> argument:<span class="literal">nil</span> order:<span class="number">3</span> modes:@[<span class="built_in">NSRunLoopCommonModes</span>]];</span><br><span class="line">    [runloop performSelector:<span class="keyword">@selector</span>(runloopTask2) target:<span class="keyword">self</span> argument:<span class="literal">nil</span> order:<span class="number">2</span> modes:@[<span class="built_in">NSRunLoopCommonModes</span>]];</span><br><span class="line">    [runloop performSelector:<span class="keyword">@selector</span>(runloopTask4) target:<span class="keyword">self</span> argument:<span class="literal">nil</span> order:<span class="number">4</span> modes:@[<span class="built_in">NSRunLoopCommonModes</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)runloopTask1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"runloop 任务1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)runloopTask2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"runloop 任务2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)runloopTask3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"runloop 任务3"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)runloopTask4</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"runloop 任务4"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)runloopTask5</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"runloop 任务5"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">27.088636</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">62976</span>:<span class="number">972980</span>] runloop 任务<span class="number">1</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">27.088760</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">62976</span>:<span class="number">972980</span>] runloop 任务<span class="number">2</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">27.088868</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">62976</span>:<span class="number">972980</span>] runloop 任务<span class="number">3</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">27.088964</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">62976</span>:<span class="number">972980</span>] runloop 任务<span class="number">4</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">27.089048</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">62976</span>:<span class="number">972980</span>] runloop 任务<span class="number">5</span></span><br></pre></td></tr></table></figure><p>可以看到输出结果就是按照我们传入的 <code>order</code> 参数作为任务执行的顺序。</p><p><code>GUNStep</code> 中这个底层的底层实现如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) performSelector: (SEL)aSelector</span><br><span class="line">                  target: (<span class="keyword">id</span>)target</span><br><span class="line">                argument: (<span class="keyword">id</span>)argument</span><br><span class="line">                   order: (<span class="built_in">NSUInteger</span>)order</span><br><span class="line">                   modes: (<span class="built_in">NSArray</span>*)modes</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span>count = [modes count];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSString</span>*array[count];</span><br><span class="line">        GSRunLoopPerformer*item;</span><br><span class="line">        </span><br><span class="line">        item = [[GSRunLoopPerformer alloc] initWithSelector: aSelector</span><br><span class="line">                                                     target: target</span><br><span class="line">                                                   argument: argument</span><br><span class="line">                                                      order: order];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ([modes isProxy])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span>i;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                array[i] = [modes objectAtIndex: i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            [modes getObjects: array];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSString</span>*mode = array[count];</span><br><span class="line">            <span class="keyword">unsigned</span>end;</span><br><span class="line">            <span class="keyword">unsigned</span>i;</span><br><span class="line">            GSRunLoopCtxt*context;</span><br><span class="line">            GSIArrayperformers;</span><br><span class="line">            </span><br><span class="line">            context = <span class="built_in">NSMapGet</span>(_contextMap, mode);</span><br><span class="line">            <span class="keyword">if</span> (context == <span class="literal">nil</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                context = [[GSRunLoopCtxt alloc] initWithMode: mode</span><br><span class="line">                                                        extra: _extra];</span><br><span class="line">                <span class="built_in">NSMapInsert</span>(_contextMap, context-&gt;mode, context);</span><br><span class="line">                RELEASE(context);</span><br><span class="line">            &#125;</span><br><span class="line">            performers = context-&gt;performers;</span><br><span class="line">            </span><br><span class="line">            end = GSIArrayCount(performers);</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; end; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                GSRunLoopPerformer*p;</span><br><span class="line">                </span><br><span class="line">                p = GSIArrayItemAtIndex(performers, i).obj;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;order &gt; order)</span><br><span class="line">                &#123;</span><br><span class="line">                    GSIArrayInsertItem(performers, (GSIArrayItem)((<span class="keyword">id</span>)item), i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == end)</span><br><span class="line">            &#123;</span><br><span class="line">                GSIArrayInsertItem(performers, (GSIArrayItem)((<span class="keyword">id</span>)item), i);</span><br><span class="line">            &#125;</span><br><span class="line">            i = GSIArrayCount(performers);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span> &amp;&amp; i &gt; context-&gt;maxPerformers)</span><br><span class="line">            &#123;</span><br><span class="line">                context-&gt;maxPerformers = i;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"WARNING ... there are %u performers scheduled"</span></span><br><span class="line">                      <span class="string">@" in mode %@ of %@\n(Latest: [%@ %@])"</span>,</span><br><span class="line">                      i, mode, <span class="keyword">self</span>, <span class="built_in">NSStringFromClass</span>([target <span class="keyword">class</span>]),</span><br><span class="line">                      <span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RELEASE(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GSRunLoopPerformer</span>: <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">    SELselector;</span><br><span class="line">    <span class="keyword">id</span>target;</span><br><span class="line">    <span class="keyword">id</span>argument;</span><br><span class="line">    <span class="keyword">unsigned</span>order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经知道了 <code>performSelector:WithObject:afterDelay:</code> 方法底层实现使用一个包裹 timer 对象的数据结构的方式，而这里是使用了一个包裹了 <code>selector</code>、<code>target</code>、<code>argument</code> 以及优先级 <code>order</code> 的数据结构的方式来实现。同时在 context 上下文的成员变量 <code>performers</code> 中存储了要执行的任务队列，所以这里实际上就是一个简单的插入排序的过程。</p><h3 id="2-2-2-cancelPerformSelector-target-argument-和-cancelPerformSelectorsWithTarget"><a href="#2-2-2-cancelPerformSelector-target-argument-和-cancelPerformSelectorsWithTarget" class="headerlink" title="2.2.2 cancelPerformSelector:target:argument: 和 cancelPerformSelectorsWithTarget:"></a>2.2.2 <code>cancelPerformSelector:target:argument:</code> 和 <code>cancelPerformSelectorsWithTarget:</code></h3><p><code>cancelPerformSelector:target:argument:</code> 和 <code>cancelPerformSelectorsWithTarget:</code> 使用起来比较简单，一个需要传入 <code>selector</code>、<code>target</code> 和 <code>argument</code>，另一个只需要传入 <code>target</code>。它们的作用分别是根据给定的三个参数或 <code>target</code> 去 runloop 底层的 <code>performers</code> 任务队列中查找任务，找到了就从队列中移除掉。</p><p>而底层具体实现具体如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cancels any perform operations set up for the specified target</span></span><br><span class="line"><span class="comment"> * in the receiver.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) cancelPerformSelectorsWithTarget: (<span class="keyword">id</span>) target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMapEnumerator</span>enumerator;</span><br><span class="line">    GSRunLoopCtxt*context;</span><br><span class="line">    <span class="keyword">void</span>*mode;</span><br><span class="line">    </span><br><span class="line">    enumerator = <span class="built_in">NSEnumerateMapTable</span>(_contextMap);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">NSNextMapEnumeratorPair</span>(&amp;enumerator, &amp;mode, (<span class="keyword">void</span>**)&amp;context))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="literal">nil</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GSIArrayperformers = context-&gt;performers;</span><br><span class="line">            <span class="keyword">unsigned</span>count = GSIArrayCount(performers);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (count--)</span><br><span class="line">            &#123;</span><br><span class="line">                GSRunLoopPerformer*p;</span><br><span class="line">                </span><br><span class="line">                p = GSIArrayItemAtIndex(performers, count).obj;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;target == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    GSIArrayRemoveItemAtIndex(performers, count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSEndMapTableEnumeration</span>(&amp;enumerator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cancels any perform operations set up for the specified target</span></span><br><span class="line"><span class="comment"> * in the receiver, but only if the value of aSelector and argument</span></span><br><span class="line"><span class="comment"> * with which the performs were set up match those supplied.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * Matching of the argument may be either by pointer equality or by</span></span><br><span class="line"><span class="comment"> * use of the [NSObject-isEqual:] method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) cancelPerformSelector: (SEL)aSelector</span><br><span class="line">                        target: (<span class="keyword">id</span>) target</span><br><span class="line">                      argument: (<span class="keyword">id</span>) argument</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMapEnumerator</span>enumerator;</span><br><span class="line">    GSRunLoopCtxt*context;</span><br><span class="line">    <span class="keyword">void</span>*mode;</span><br><span class="line">    </span><br><span class="line">    enumerator = <span class="built_in">NSEnumerateMapTable</span>(_contextMap);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">NSNextMapEnumeratorPair</span>(&amp;enumerator, &amp;mode, (<span class="keyword">void</span>**)&amp;context))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="literal">nil</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GSIArrayperformers = context-&gt;performers;</span><br><span class="line">            <span class="keyword">unsigned</span>count = GSIArrayCount(performers);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (count--)</span><br><span class="line">            &#123;</span><br><span class="line">                GSRunLoopPerformer*p;</span><br><span class="line">                </span><br><span class="line">                p = GSIArrayItemAtIndex(performers, count).obj;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;target == target &amp;&amp; sel_isEqual(p-&gt;selector, aSelector)</span><br><span class="line">                    &amp;&amp; (p-&gt;argument == argument || [p-&gt;argument isEqual: argument]))</span><br><span class="line">                &#123;</span><br><span class="line">                    GSIArrayRemoveItemAtIndex(performers, count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSEndMapTableEnumeration</span>(&amp;enumerator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-小结"><a href="#2-2-3-小结" class="headerlink" title="2.2.3 小结"></a>2.2.3 小结</h3><ul><li><code>performSelector:target:argument:order:modes:</code> <ul><li>在该方法所在线程的 runloop 处于给定的任一 mode 时，且处于下一次 runloop 消息循环的开头的时候触发给定的任务。底层原理是循环把一个类似于 timer 的对象加入到 runloop 的上下文的任务队列中，等待唤醒</li></ul></li><li><code>cancelPerformSelector:target:argument:</code><ul><li>取消 target 对象通过 <code>performSelector:target:argument:order:modes:</code> 方法方法注册的<strong>指定的任务</strong></li></ul></li><li><code>cancelPerformSelectorsWithTarget:</code><ul><li>取消 target 对象通过 <code>performSelector:target:argument:order:modes:</code> 方法方法注册的<strong>所有任务</strong></li></ul></li></ul><p>这里同样的也需要注意，<strong>如果是在子线程中执行这些方法，则需要开启子线程对应的 runloop 才能保证执行成功</strong>。</p><h1 id="三、Thread-相关的-performSelector"><a href="#三、Thread-相关的-performSelector" class="headerlink" title="三、Thread 相关的 performSelector"></a>三、Thread 相关的 <code>performSelector</code></h1><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200312163811.jpg" alt></p><p>如上图所示，在 <code>NSThread</code> 中定义了 <code>NSObject</code> 的分类 <code>NSThreadPerformAdditions</code>，其中定义了 5 个 <code>performSelector</code> 的方法。</p><h2 id="3-1-performSelector-onThread-withObject-waitUntilDone-和-performSelector-onThread-withObject-waitUntilDone-modes"><a href="#3-1-performSelector-onThread-withObject-waitUntilDone-和-performSelector-onThread-withObject-waitUntilDone-modes" class="headerlink" title="3.1 performSelector:onThread:withObject:waitUntilDone: 和 performSelector:onThread:withObject:waitUntilDone:modes:"></a>3.1 <code>performSelector:onThread:withObject:waitUntilDone:</code> 和 <code>performSelector:onThread:withObject:waitUntilDone:modes:</code></h2><p>根据官方文档的解释，第一个方法相当于调用了第二个方法，然后 mode 传入的是 <code>kCFRunLoopCommonModes</code>。我们这里只研究第一个方法。</p><p>这个方法需要相比于 <code>performSeletor:withObject:</code> 多了两个参数，分别是要哪个线程执行任务以及是否阻塞当前线程。但是使用这个方法一定要小心，如下图所示是一个常见的错误用法：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/15839893768175.jpg" alt></p><p>这里报的错是 <code>target thread exited while waiting for the perform</code>，就是说已经退出的线程无法执行定时任务。<br>熟悉 <code>iOS</code> 多线程的同学都知道 <code>NSThread</code> 实例化之后的线程对象在 <code>start</code> 之后就会被系统回收，而之后调用的 <code>performSelector:onThread:withObject:waitUntilDone:</code> 方法又在一个<strong>已经回收的线程</strong>上执行任务，显然就会崩溃。这里的解决方案就是给这个子线程对应的 runloop 启动起来，让线程具有 『有事来就干活，没事干就睡觉』 的功能，具体代码如下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/15839895561944.jpg" alt></p><p>对于 <code>waitUntilDone</code> 参数，如果我们设置为 <code>YES</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/15839897039699.jpg" alt></p><p>如果设置为 <code>NO</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/15839898047089.jpg" alt></p><p>所以这里的 <code>waitUntilDone</code> 可以简单的理解为控制同步或异步执行。</p><p>在探索 <code>GNUStep</code> 对应实现之前，我们先熟悉一下 <code>GSRunLoopThreadInfo</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Used to handle events performed in one thread from another.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span>      <span class="title">GSRunLoopThreadInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">@public</span></span><br><span class="line">  <span class="built_in">NSRunLoop</span>             *loop;</span><br><span class="line">  <span class="built_in">NSLock</span>                *lock;</span><br><span class="line">  <span class="built_in">NSMutableArray</span>        *performers;</span><br><span class="line"><span class="meta">#ifdef _WIN32</span></span><br><span class="line">  HANDLE        event;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">  <span class="keyword">int</span>                   inputFd;</span><br><span class="line">  <span class="keyword">int</span>                   outputFd;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GSRunLoopThreadInfo</code> 是每个线程特有的一个属性，存储了线程和 runloop 之间的一些信息，可以通过下面的方式获取:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GSRunLoopThreadInfo *</span><br><span class="line">GSRunLoopInfoForThread(<span class="built_in">NSThread</span> *aThread)</span><br><span class="line">&#123;</span><br><span class="line">    GSRunLoopThreadInfo   *info;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (aThread == <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        aThread = GSCurrentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (aThread-&gt;_runLoopInfo == <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        [gnustep_global_lock lock];</span><br><span class="line">        <span class="keyword">if</span> (aThread-&gt;_runLoopInfo == <span class="literal">nil</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            aThread-&gt;_runLoopInfo = [GSRunLoopThreadInfo new];</span><br><span class="line">        &#125;</span><br><span class="line">        [gnustep_global_lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">    info = aThread-&gt;_runLoopInfo;</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是另一个 <code>GSPerformHolder</code>: </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class performs a dual function ...</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *   As a class, it is responsible for handling incoming events from</span></span><br><span class="line"><span class="comment"> *   the main runloop on a special inputFd.  This consumes any bytes</span></span><br><span class="line"><span class="comment"> *   written to wake the main runloop.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> *   During initialisation, the default runloop is set up to watch</span></span><br><span class="line"><span class="comment"> *   for data arriving on inputFd.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *   As instances, each  instance retains perform receiver and argument</span></span><br><span class="line"><span class="comment"> *   values as long as they are needed, and handles locking to support</span></span><br><span class="line"><span class="comment"> *   methods which want to block until an action has been performed.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *   The initialize method of this class is called before any new threads</span></span><br><span class="line"><span class="comment"> *   run.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GSPerformHolder</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span>receiver;</span><br><span class="line">    <span class="keyword">id</span>argument;</span><br><span class="line">    SELselector;</span><br><span class="line">    <span class="built_in">NSConditionLock</span>*lock;<span class="comment">// Not retained.</span></span><br><span class="line">    <span class="built_in">NSArray</span>*modes;</span><br><span class="line">    <span class="built_in">BOOL</span>                  invalidated;</span><br><span class="line"><span class="keyword">@public</span></span><br><span class="line">    <span class="built_in">NSException</span>           *exception;</span><br><span class="line">&#125;</span><br><span class="line">+ (GSPerformHolder*) newForReceiver: (<span class="keyword">id</span>)r</span><br><span class="line">                           argument: (<span class="keyword">id</span>)a</span><br><span class="line">                           selector: (SEL)s</span><br><span class="line">                              modes: (<span class="built_in">NSArray</span>*)m</span><br><span class="line">                               lock: (<span class="built_in">NSConditionLock</span>*)l;</span><br><span class="line">- (<span class="keyword">void</span>) fire;</span><br><span class="line">- (<span class="keyword">void</span>) invalidate;</span><br><span class="line">- (<span class="built_in">BOOL</span>) isInvalidated;</span><br><span class="line">- (<span class="built_in">NSArray</span>*) modes;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>GSPerformHolder</code> 封装了任务的细节(<code>receiver</code>, <code>argument</code>, <code>selector</code>)以及运行模式(<code>mode</code>)和一把条件锁( <code>NSConditionLock</code> )。</p><p>接着我们目光聚焦到源码 <code>performSelector:onThread:withObject:waitUntilDone:modes:</code> 具体实现上:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) performSelector: (SEL)aSelector</span><br><span class="line">                onThread: (<span class="built_in">NSThread</span>*)aThread</span><br><span class="line">              withObject: (<span class="keyword">id</span>)anObject</span><br><span class="line">           waitUntilDone: (<span class="built_in">BOOL</span>)aFlag</span><br><span class="line">                   modes: (<span class="built_in">NSArray</span>*)anArray</span><br><span class="line">&#123;</span><br><span class="line">    GSRunLoopThreadInfo   *info;</span><br><span class="line">    <span class="built_in">NSThread</span>        *t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([anArray count] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    t = GSCurrentThread();</span><br><span class="line">    <span class="keyword">if</span> (aThread == <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        aThread = t;</span><br><span class="line">    &#125;</span><br><span class="line">    info = GSRunLoopInfoForThread(aThread);</span><br><span class="line">    <span class="keyword">if</span> (t == aThread)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Perform in current thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (aFlag == <span class="literal">YES</span> || info-&gt;loop == <span class="literal">nil</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Wait until done or no run loop.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            [<span class="keyword">self</span> performSelector: aSelector withObject: anObject];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Don't wait ... schedule operation in run loop.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            [info-&gt;loop performSelector: aSelector</span><br><span class="line">                                 target: <span class="keyword">self</span></span><br><span class="line">                               argument: anObject</span><br><span class="line">                                  order: <span class="number">0</span></span><br><span class="line">                                  modes: anArray];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        GSPerformHolder   *h;</span><br><span class="line">        <span class="built_in">NSConditionLock</span>*l = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ([aThread isFinished] == <span class="literal">YES</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">                        format: <span class="string">@"perform [%@-%@] attempted on finished thread (%@)"</span>,</span><br><span class="line">             <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]),</span><br><span class="line">             <span class="built_in">NSStringFromSelector</span>(aSelector),</span><br><span class="line">             aThread];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (aFlag == <span class="literal">YES</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            l = [[<span class="built_in">NSConditionLock</span> alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        h = [GSPerformHolder newForReceiver: <span class="keyword">self</span></span><br><span class="line">                                   argument: anObject</span><br><span class="line">                                   selector: aSelector</span><br><span class="line">                                      modes: anArray</span><br><span class="line">                                       lock: l];</span><br><span class="line">        [info addPerformer: h];</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">nil</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            [l lockWhenCondition: <span class="number">1</span>];</span><br><span class="line">            [l unlock];</span><br><span class="line">            RELEASE(l);</span><br><span class="line">            <span class="keyword">if</span> ([h isInvalidated] == <span class="literal">NO</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* If we have an exception passed back from the remote thread,</span></span><br><span class="line"><span class="comment">                 * re-raise it.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">nil</span> != h-&gt;exception)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">NSException</span>       *e = AUTORELEASE(RETAIN(h-&gt;exception));</span><br><span class="line">                    </span><br><span class="line">                    RELEASE(h);</span><br><span class="line">                    [e raise];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RELEASE(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明一个<code>GSRunLoopThreadInfo</code> 对象和一条 <code>NSThread</code> 线程</li><li>判断运行模式数组参数是否为空</li><li>获取当前线程，将结果赋值于第一步声明的局部线程变量</li><li>判断如果传入的要执行任务的线程 aThread 如果为空，那么就把当前线程赋值于到 aThread 上</li><li>确保 aThread 不为空之后获取该线程对应的 <code>GSRunLoopThreadInfo</code> 对象并赋值于第一步声明的局部 info 变量</li><li>确保 info 有值后，判断是否是在当前线程上执行任务</li><li>如果是在当前线程上执行任务，接着判断是否要阻塞当前线程，或当前线程的 runloop 为空。<ul><li>如果是的话，则直接调用 <code>performSelector:withObject</code> 来执行任务</li><li>如果不是的话，则通过线程对应的 runloop 对象调用 <code>performSelector:target:argument:order:modes:</code> 来执行任务</li></ul></li><li>如果不是在当前线程上执行任务，声明一个 <code>GSPerformHolder</code> 局部变量，声明一把空的条件锁 <code>NSConditionLock</code><ul><li>判断要执行任务的线程是否已经被回收，如果已被回收，则抛出异常</li><li>如果未被回收<ul><li>判断是否要阻塞当前线程，如果传入的参数需要阻塞，则初始化条件锁</li><li>根据传入的参数及条件锁初始化  <code>GSPerformHolder</code> 实例</li><li>然后在 info 中加入 <code>GSPerformHolder</code> 实例</li><li>然后判断条件锁如果不为空，赋予条件锁何时加锁的条件，然后解锁条件锁，然后释放条件锁</li><li>判断 <code>GSPerformHolder</code> 局部变量是否已经被释放，如果没有被释放，抛出异常</li></ul></li></ul></li></ul><h2 id="3-2-performSelectorOnMainThread-withObject-waitUntilDone-和-performSelectorOnMainThread-withObject-waitUntilDone-modes"><a href="#3-2-performSelectorOnMainThread-withObject-waitUntilDone-和-performSelectorOnMainThread-withObject-waitUntilDone-modes" class="headerlink" title="3.2 performSelectorOnMainThread:withObject:waitUntilDone: 和 performSelectorOnMainThread:withObject:waitUntilDone:modes:"></a>3.2 <code>performSelectorOnMainThread:withObject:waitUntilDone:</code> 和 <code>performSelectorOnMainThread:withObject:waitUntilDone:modes:</code></h2><p>顾名思义，这两个方法其实就是在主线程上执行任务，根据传入的参数决定是否阻塞主线程，以及在哪些运行模式下执行任务。使用方法如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)jh_performSelectorOnMainThreadwithObjectwaitUntilDone</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(threadTask:) withObject:@&#123;<span class="string">@"param"</span>: <span class="string">@"leejunhui"</span>&#125; waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line"><span class="comment">//    [self performSelectorOnMainThread:@selector(threadTask:) withObject:@&#123;@"param": @"leejunhui"&#125; waitUntilDone:NO modes:@[NSRunLoopCommonModes]];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)threadTask:(<span class="built_in">NSDictionary</span> *)param</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">31.783962</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">63614</span>:<span class="number">1057033</span>] -[ViewController threadTask:]</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">31.784126</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">63614</span>:<span class="number">1057033</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002e76dc0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure><p>因为是在主线程上执行，所以并不需要手动开启 runloop。我们来看下这两个方法在 <code>GNUStep</code> 中底层实现:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) performSelectorOnMainThread: (SEL)aSelector</span><br><span class="line">                          withObject: (<span class="keyword">id</span>)anObject</span><br><span class="line">                       waitUntilDone: (<span class="built_in">BOOL</span>)aFlag</span><br><span class="line">                               modes: (<span class="built_in">NSArray</span>*)anArray</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* It's possible that this method could be called before the NSThread</span></span><br><span class="line"><span class="comment">     * class is initialised, so we check and make sure it's initiailised</span></span><br><span class="line"><span class="comment">     * if necessary.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (defaultThread == <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> performSelector: aSelector</span><br><span class="line">                 onThread: defaultThread</span><br><span class="line">               withObject: anObject</span><br><span class="line">            waitUntilDone: aFlag</span><br><span class="line">                    modes: anArray];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) performSelectorOnMainThread: (SEL)aSelector</span><br><span class="line">                          withObject: (<span class="keyword">id</span>)anObject</span><br><span class="line">                       waitUntilDone: (<span class="built_in">BOOL</span>)aFlag</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelectorOnMainThread: aSelector</span><br><span class="line">                           withObject: anObject</span><br><span class="line">                        waitUntilDone: aFlag</span><br><span class="line">                                modes: commonModes()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，这里其实就是调用的 <code>performSelector:onThread:withObject:waitUntilDone:modes</code> 方法，但是有一个细节需要注意，就是有可能在 <code>NSThread</code> 类被初始化之前，就调用了 <code>performSelectorOnMainThread</code> 方法，所以需要手动调用一下 <code>[NSThread currentThread]</code>。</p><h2 id="3-3-performSelectorInBackground-withObject"><a href="#3-3-performSelectorInBackground-withObject" class="headerlink" title="3.3 performSelectorInBackground:withObject:"></a>3.3 <code>performSelectorInBackground:withObject:</code></h2><p>最后要探索的是 <code>performSelectorInBackground:withObject:</code> 方法，这个方法用法如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)jh_performSelectorOnBackground</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(threadTask:) withObject:@&#123;<span class="string">@"param"</span>: <span class="string">@"leejunhui"</span>&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)threadTask:(<span class="built_in">NSDictionary</span> *)param</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">36.751675</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">63660</span>:<span class="number">1061569</span>] -[ViewController threadTask:]</span><br><span class="line"><span class="number">2020</span><span class="number">-03</span><span class="number">-12</span> <span class="number">16</span>:<span class="number">19</span>:<span class="number">36.751990</span>+<span class="number">0800</span> PerformSelectorIndepth[<span class="number">63660</span>:<span class="number">1061569</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x6000027a0ac0</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><p>根据输出我们可知，这里显然是开了一条子线程来执行任务，我们看一下 <code>GNUStep</code> 的底层实现:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) performSelectorInBackground: (SEL)aSelector</span><br><span class="line">                          withObject: (<span class="keyword">id</span>)anObject</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector: aSelector</span><br><span class="line">                             toTarget: <span class="keyword">self</span></span><br><span class="line">                           withObject: anObject];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在底层其实是调用的 <code>NSThread</code> 的类方法来执行传入的任务。关于 <code>NSThread</code> 细节我们后面会进行探索。</p><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h2><ul><li><code>performSelector:onThread:withObject:waitUntilDone:</code> 和 <code>performSelector:onThread:withObject:waitUntilDone:modes:</code><ul><li>在该方法所在线程的 runloop 处于给定的任一 mode 时，判断是否阻塞当前线程，并且处于下一次 runloop 消息循环的开头的时候触发给定的任务。</li></ul></li><li><code>performSelectorOnMainThread:withObject:waitUntilDone:</code> 和 <code>performSelectorOnMainThread:withObject:waitUntilDone:modes:</code><ul><li>当主线程的 runloop 处于给定的任一 mode 时，判断是否阻塞主线程，并且处于下一次 runloop 消息循环的开头的时候触发给定的任务。</li></ul></li><li><code>performSelectorInBackground:withObject:</code><ul><li>在子线程上执行给定的任务。底层是通过 <code>NSThread</code> 的 <code>detachNewThread</code> 实现。</li></ul></li></ul><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/performSelector.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS-查漏补缺-PerformSelector&quot;&gt;&lt;a href=&quot;#iOS-查漏补缺-PerformSelector&quot; class=&quot;headerlink&quot; title=&quot;iOS 查漏补缺 - PerformSelector&quot;&gt;&lt;/a&gt;iOS 查漏补缺 - PerformSelector&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;performSelector&lt;/code&gt; 系列的函数我们都不陌生，但是对于它不同的变种以及底层原理在很多时候还是容易分不清楚，所以笔者希望通过 &lt;code&gt;runtime&lt;/code&gt; 源码以及 &lt;code&gt;GUNStep&lt;/code&gt; 源码来一个个抽丝剥茧，把不同变种的 &lt;code&gt;performSelector&lt;/code&gt; 理顺，并搞清楚每个方法的底层实现，如有错误，欢迎指正。&lt;/p&gt;
&lt;p&gt;本文的代码已放在 &lt;a href=&quot;https://github.com/LeeJunhui/PerformSelectorIndepth&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt; ，欢迎自取&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 查漏补缺" scheme="http://leejunhui.com/categories/iOS-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - KVO</title>
    <link href="http://leejunhui.com/2020/02/19/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVO/"/>
    <id>http://leejunhui.com/2020/02/19/iOS-底层探索-KVO/</id>
    <published>2020-02-19T07:38:09.000Z</published>
    <updated>2020-02-19T07:40:40.308Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 <code>Objective-C</code> 和 <code>Cocoa</code> 中，有许多事件之间进行通信的方式，并且每个都有不同程度的形式和耦合:<br><code>NSNotification</code> &amp; <code>NSNotificationCenter</code> 提供了一个中央枢纽，一个应用的任何部分都可能通知或者被通知应用的其他部分的变化。唯一需要做的是要知道在寻找什么，主要是通知的名字。例如，<code>UIApplicationDidReceiveMemoryWarningNotification</code> 是给应用发了一个内存不足的信号。<br><code>Key-Value Observing</code> 键值观察通过侦听特定键路径上的更改，可以在特定对象实例之间进行特殊的事件自省。例如：一个 <code>ProgressView</code> 可以观察 网络请求的 <code>numberOfBytesRead</code> 来更新它自己的 <code>progress</code> 属性。<br><code>Delegate</code> 是一个流行的传递事件的设计模式，通过定义一系列的方法来传递给指定的处理对象。例如：<code>UIScrollView</code> 每次它的 <code>scroll offset</code> 改变的时候都会发送 <code>scrollViewDidScroll:</code> 到它的代理<br><code>Callbacks</code> 不管是像 <code>NSOperation</code> 里的 <code>completionBlock</code>（当 <code>isFinished==YES</code> 的时候会触发），还是 <code>C</code> 里边的函数指针，传递一个函数钩子比如 <code>SCNetworkReachabilitySetCallback(3)</code>。</p></blockquote><a id="more"></a><h1 id="一、KVO-初探"><a href="#一、KVO-初探" class="headerlink" title="一、KVO 初探"></a>一、KVO 初探</h1><p>根据苹果官方文档的定义，<code>KVO</code> (Key Value Observing) 键值观察是建立在 <code>KVC</code> 基础之上的，所以如果对 <code>KVC</code> 不是很了解的读者可以查看上一篇 <code>KVC</code> 底层探索的文章。</p><p>我相信大多数开发者应该对于 <code>KVO</code> 都能熟练掌握，不过我们还是回顾一下官网对于 <code>KVO</code> 的解释吧。</p><h2 id="1-1-什么是-KVO"><a href="#1-1-什么是-KVO" class="headerlink" title="1.1 什么是 KVO?"></a>1.1 什么是 <code>KVO</code>?</h2><p><code>KVO</code> 提供了一种当其他对象的属性发生变化就会通知观察者对象的机制。根据官网的定义，属性的分类可以分为下列三种：</p><ul><li><strong>Attributes</strong>: 简单属性，比如基本数据类型，字符串和布尔值，而诸如 <code>NSNumber</code> 和其它一些不可变类型比如 <code>NSColor</code> 也可以被认为是简单属性</li><li><strong>To-one relationships</strong>: 这些是具有自己属性的可变对象属性。即对象的属性可以更改，而无需更改对象本身。例如，一个 <code>Account</code> 对象可能具有一个 <code>owner</code> 属性，该属性是 <code>Person</code> 对象的实例，而 <code>Person</code> 对象本身具有 <code>address</code> 属性。<code>owner</code> 的地址可以更改，但却而无需更改 <code>Account</code> 持有的 <code>owner</code> 属性。也就是说 <code>Account</code> 的 <code>owner</code> 属性未被更改，只是 <code>address</code> 被更改了。</li><li><strong>To-many relationships</strong>: 这些是集合对象属性。尽管也可以使用自定义集合类，但是通常使用 <code>NSArray</code> 或 <code>NSSet</code> 的实例来持有此集合。</li></ul><p>而 <code>KVO</code> 对于这三种属性都能适用。下面举一个例子：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151907.jpg" alt></p><p>如上所示，<code>Person</code> 对象有一个 <code>Account</code> 属性，而 <code>Account</code> 对象又有 <code>balance</code> 和 <code>interestRate</code> 两个属性。并且这两个属性对于 <code>Person</code> 对象来说都是可读写的。如果想实现一个功能：当余额或利率变化的时候需要通知到用户。一般来说可以使用轮询的方式，<code>Person</code> 对象定期从 <code>Account</code> 属性中取出 <code>balance</code> 和 <code>interestRate</code>。但这种方式是效率低下且不切实际的，更好的方式是使用 <code>KVO</code>，类似于余额或利率变动时， <code>Person</code> 对象收到了通知一样。</p><p>要实现 <code>KVO</code> 的前提是要确保被观察对象是符合 <code>KVO</code> 机制的。一般来说，继承于 <code>NSObject</code> 根类的对象及其属性都自动符合 <code>KVO</code> 这一机制。当然也可以自己去实现 <code>KVO</code> 符合。也就是说实际上 <code>KVO</code> 机制分为<strong>自动符合</strong>和<strong>手动符合</strong>。</p><p>一旦确定了对象和属性是 <code>KVO</code> 符合的话，就需要历经三个步骤：</p><ul><li>观察者注册</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151909.jpg" alt></p><p><code>Person</code> 对象需要将自己注册到 <code>Account</code> 的某一个具体属性上。这个过程是通过<br><code>addObserver:forKeyPath:options:context:</code> 实现的，这个方法需要指定监听者(<code>observer</code>)、监听谁(<code>keypath</code>)、监听策略(<code>options</code>)、监听上下文(<code>context</code>)</p><ul><li>被观察者触发回调</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151913.jpg" alt></p><p><code>Person</code> 对象要接收 <code>Account</code> 被监听属性改动后发出的通知，需要自身实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法来接收通知。</p><ul><li>观察者取消注册</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151911.jpg" alt></p><p>在观察者不需要再监听或自身生命周期结束的时候，需要取消注册。具体实现是通过向被观察对象发出 <code>removeObserver:forKeyPath:</code> 消息。</p><p><code>KVO</code> 机制的最大好处你不需要自己去实现一个机制来获取对象属性何时改变以及改变后的结果。</p><h2 id="1-2-KVO-三大流程解析"><a href="#1-2-KVO-三大流程解析" class="headerlink" title="1.2 KVO 三大流程解析"></a>1.2 <code>KVO</code> 三大流程解析</h2><h3 id="1-2-1-观察者注册"><a href="#1-2-1-观察者注册" class="headerlink" title="1.2.1 观察者注册"></a>1.2.1 观察者注册</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer</span><br><span class="line">         forKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">            options:(<span class="built_in">NSKeyValueObservingOptions</span>)options</span><br><span class="line">            context:(<span class="keyword">void</span> *)context</span><br></pre></td></tr></table></figure><blockquote><p><strong>observer</strong>:注册 <code>KVO</code> 通知的对象。观察者必须实现 <code>key-value observing</code> 方法 <code>observeValueForKeyPath:ofObject:change:context:</code>。<br><strong>keyPath</strong>:被观察者的属性的 <code>keypath</code>，相对于接受者，值不能是 <code>nil</code>。<br><strong>options</strong>: <code>NSKeyValueObservingOptions</code> 的组合，它指定了观察通知中包含了什么<br><strong>context</strong>:在 <code>observeValueForKeyPath:ofObject:change:context:</code> 传给 <code>observer</code> 参数的上下文</p></blockquote><p>前两个参数很好理解，而 <code>options</code> 和 <code>context</code> 参数则需要额外注意。</p><p><code>options</code> 代表 <code>NSKeyValueObservingOptions</code> 的位掩码，需要注意 <code>NSKeyValueObservingOptionNew &amp; NSKeyValueObservingOptionOld</code>，因为这些是你经常要用到的，可以跳过 <code>NSKeyValueObservingOptionInitial &amp; NSKeyValueObservingOptionPrior:</code>。</p><blockquote><p><code>NSKeyValueObservingOptionNew</code>: 表明通知中的更改字典应该提供<strong>新的属性值</strong>，如何可以的话。<br><code>NSKeyValueObservingOptionOld</code>: 表明通知中的更改字典应该包含<strong>旧的属性值</strong>，如何可以的话。<br><code>NSKeyValueObservingOptionInitial</code>: 这个枚举值比较特殊，如果指定了这个枚举值，<br>在属性发生变化后立即通知观察者，这个过程甚至早于观察者注册。如果在注册的时候配置了 <code>NSKeyValueObservingOptionNew</code>，那么在通知的更改字典中也会包含 <code>NSKeyValueChangeNewKey</code>，但是不会包括 <code>NSKeyValueChangeOldKey</code>。（在初始通知中，观察到的属性值可能是旧的，但是对于观察者来说是<strong>新的</strong>）其实简单来说就是这个枚举值会在属性变化前先触发一次 <code>observeValueForKeyPath</code> 回调。<br><code>NSKeyValueObservingOptionPrior</code>: 这个枚举值会先后连续出发两次 <code>observeValueForKeyPath</code> 回调。同时在回调中的可变字典中会有一个布尔值的 <code>key</code> - <code>notificationIsPrior</code> 来标识属性值是变化前还是变化后的。如果是变化后的回调，那么可变字典中就只有 <code>new</code> 的值了，如果同时制定了 <code>NSKeyValueObservingOptionNew</code> 的话。如果你需要启动手动 <code>KVO</code> 的话，你可以指定这个枚举值然后通过 <code>willChange</code> 实例方法来观察属性值。在出发 <code>observeValueForKeyPath</code> 回调后再去调用 <code>willChange</code> 可能就太晚了。</p></blockquote><blockquote><p>这些选项允许一个对象在发生变化的前后获取值。在实践中，这不是必须的，因为从当前属性值获取的新值一般是可用的 也就是说 <code>NSKeyValueObservingOptionInitial</code> 对于在反馈 <code>KVO</code> 事件的时候减少代码路径是很有好处的。比如，如果你有一个方法，它能够动态的使一个基于 <code>text</code> 值的按钮有效，传 <code>NSKeyValueObservingOptionInitial</code> 可以使事件随着它的初始化状态触发一旦观察者被添加进去的话。</p></blockquote><blockquote><p>如何设置一个好的 <code>context</code> 值呢？这里有个建议：</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * XXContext = &amp;XXContext;</span><br></pre></td></tr></table></figure><p>就是这么简单：一个静态变量存着它自己的指针。这意味着它自己什么也没有，使 <code>&lt;NSKeyValueObserving&gt;</code> 更完美。</p><p>我们简单测试一下在注册观察者时指定不同的枚举值会有怎么样的结果：</p><ul><li>只指定 <code>NSKeyValueObservingOptionNew</code></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219151916.jpg" alt></p><ul><li>只指定 <code>NSKeyValueObservingOptionOld</code></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152116.jpg" alt></p><ul><li>指定 <code>NSKeyValueObservingOptionInitial</code></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152126.jpg" alt></p><p>可以看到，只指定了 <code>NSKeyValueObservingOptionInitial</code> 后触发了两个回调，并且一次是在属性值变化前，一次是在属性值变化后。同时并且没有新值和旧值返回，我们加一个 <code>NSKeyValueObservingOptionNew</code> 和 <code>NSKeyValueObservingOptionOld</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152131.jpg" alt></p><p>在我们加上新值和旧值的枚举之后，新值在两次回调后被返回，<strong>但是第一次的新值其实是最开始的属性值</strong>，第二次才是改变之后的属性值，而旧值在第二次真正属性值被改变后返回。</p><ul><li>指定 <code>NSKeyValueObservingOptionPrior</code></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152121.jpg" alt></p><p>可以看到，<code>NSKeyValueObservingOptionPrior</code> 枚举值是在属性值发生变化后触发了两次回调，同时也没有新值和旧值的返回，我们加一个 <code>NSKeyValueObservingOptionNew</code> 和 <code>NSKeyValueObservingOptionOld</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152142.jpg" alt></p><p>可以看到，在第一次回调里没有新值，第二次才有，而旧值在两次回调里面都有。</p><hr><ul><li>keyPath 字符串问题</li></ul><p>我们在注册观察者的时候，要求传入的 <code>keyPath</code> 是字符串类型，如果我们拼写错误的话，编译器是不能帮我们检查出来的，所有最佳实践应该是使用 <code>NSStringFromSelector(SEL aSelector)</code>，比如我们要观察 <code>tableView</code> 的 <code>contentSize</code> 属性，我们可以这样使用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(contentSize))</span><br></pre></td></tr></table></figure><h3 id="1-2-2-观察者接收通知"><a href="#1-2-2-观察者接收通知" class="headerlink" title="1.2.2 观察者接收通知"></a>1.2.2 观察者接收通知</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">                       context:(<span class="keyword">void</span> *)context</span><br></pre></td></tr></table></figure><p>这个方法就是观察者接收通知的地方，除了 <code>change</code> 参数之外，其他三个参数都与观察者注册的时候传入的三个参数一一对应。</p><ul><li>不同对象监听相同的 <code>keypath</code></li></ul><p>默认情况下，我们在 <code>addObserver:forKeyPath:options:context:</code> 方法的最后一个参数传入的是 <code>NULL</code>，因为这个方法签名中最后一个参数 <code>context</code> 是 <code>void *</code>，所以需要传入一个空指针，而根据下图我们可知，<code>nil</code> 只是一个对象的字面零值，这里需要的是一个指针，所以需要传 <code>NULL</code>。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152032.jpg" alt></p><p>但是如果是不同的对象都监听同一属性，我们就需要给 <code>context</code> 传入一个可以区分不同对象的字符串指针：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *StudentNameContext = &amp;StudentNameContext;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *PersonNameContext = &amp;PersonNameContext;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>) context:PersonNameContext];</span><br><span class="line">[<span class="keyword">self</span>.student addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>) context:StudentNameContext];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (context == PersonNameContext) &#123;</span><br><span class="line">  </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context == StudentNameContext) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要自己处理 <code>superclass</code> 的 <code>observe</code> 事务</li></ul><blockquote><p>对于 <code>Objective-C</code>，很多时候 <code>Runtime</code> 系统都会自动帮助处理 <code>superclass</code> 的方法。譬如对于 <code>dealloc</code>，假设类 <code>Father</code> 继承自 <code>NSObject</code>，而类 <code>Son</code> 继承自<code>Father</code>，创建一个 <code>Son</code> 的实例 <code>aSon</code>，在 <code>aSon</code> 被释放的时候，<code>Runtime</code> 会先调用 <code>Son#dealloc</code>，之后会自动调用 <code>Father#dealloc</code>，而无需在 <code>Son#dealloc</code> 中显式执行 <code>[super dealloc]</code>;。但 <code>KVO</code> 不会这样，所以为了保证父类（父类可能也会自己 <code>observe</code> 事务要处理）的 <code>observe</code> 事务也能被处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; - (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">&gt;                      ofObject:(id)object</span><br><span class="line">&gt;                        change:(NSDictionary *)change</span><br><span class="line">&gt;                       context:(void *)context &#123;</span><br><span class="line">&gt;    </span><br><span class="line">&gt;    if (object == _tableView &amp;&amp; [keyPath &gt;isEqualToString:@&quot;contentSize&quot;]) &#123;</span><br><span class="line">&gt;        [self configureView];</span><br><span class="line">&gt;    &#125; else &#123;</span><br><span class="line">&gt;        [super observeValueForKeyPath:keyPath ofObject:object &gt;change:change context:context];</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="1-2-3-取消注册"><a href="#1-2-3-取消注册" class="headerlink" title="1.2.3 取消注册"></a>1.2.3 取消注册</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">void</span> *)context;</span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure><p>取消注册有两个方法，不过建议还是跟注册和通知两个流程统一，选用带有 <code>context</code> 参数的方法。</p><ul><li>取消注册与注册是一对一的关系</li></ul><p>一旦对某个对象上的属性注册了键值观察，可以选择在收到属性值变化后取消注册，也可以在观察者声明周期结束之前(比如：<code>dealloc</code> 方法) 取消注册，如果忘记调用取消注册方法，那么一旦观察者被销毁后，<code>KVO</code> 机制会给一个不存在的对象发送变化回调消息导致<strong>野指针</strong>错误。</p><ul><li>不能重复取消注册</li></ul><p>取消注册也不能对同一个观察者重复多次，为了避免 <code>crash</code>，可以把取消注册的代码包裹在 <code>try&amp;catch</code> 代码块中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * ContentSizeContext = &amp;ContentSizeContext;</span><br><span class="line">    </span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. subscribe</span></span><br><span class="line">    [_tableView addObserver:<span class="keyword">self</span></span><br><span class="line">                 forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(contentSize))</span><br><span class="line">                    options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                    context:ContentSizeContext];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2. responding</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">                       context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == ContentSizeContext) &#123;</span><br><span class="line">        <span class="comment">// configure view</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="comment">// 3. unsubscribe</span></span><br><span class="line">        [_tableView removeObserver:<span class="keyword">self</span></span><br><span class="line">                        forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(contentSize))</span><br><span class="line">                           context:ContentSizeContext];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-“自动挡”-和-“手动挡”"><a href="#1-3-“自动挡”-和-“手动挡”" class="headerlink" title="1.3 “自动挡” 和 “手动挡”"></a>1.3 “自动挡” 和 “手动挡”</h2><p>默认情况下，我们只需要按照前面说的 <code>三步曲</code> 的方式来实现对属性的键值观察，不过这属于是 「自动挡」，什么意思呢？就是说属性值变化完全是由系统控制，我们只需要告诉系统监听什么属性，然后就直接等系统告诉我们就完事了。而实际上，<code>KVO</code> 还支持「手动挡」。</p><p>要让系统知道我们想开启手动挡，需要修改类方法 <code>automaticallyNotifiesObserversForKey:</code> 的返回值，这个方法如果返回 <code>YES</code> 就是自动挡，返回 <code>NO</code> 就是手动挡。同时该类方法还能精准实策，让我们选择对哪些属性是自动，哪些属性是手动。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)theKey &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">BOOL</span> automatic = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> ([theKey isEqualToString:<span class="string">@"balance"</span>]) &#123;</span><br><span class="line">        automatic = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        automatic = [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:theKey];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> automatic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，如上代码所示，我们使用 <code>automaticallyNotifiesObserversForKey</code> 的最佳实践仍然需要把我们需要手动或自动的代码排除后去调用下父类的方法来确保不会有问题出现。</p><ul><li>自动 <code>KVO</code> 触发方式</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call the accessor method.</span></span><br><span class="line">[account setName:<span class="string">@"Savings"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Use setValue:forKey:.</span></span><br><span class="line">[account setValue:<span class="string">@"Savings"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Use a key path, where 'account' is a kvc-compliant property of 'document'.</span></span><br><span class="line">[document setValue:<span class="string">@"Savings"</span> forKeyPath:<span class="string">@"account.name"</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Use mutableArrayValueForKey: to retrieve a relationship proxy object.</span></span><br><span class="line">Transaction *newTransaction = &lt;<span class="meta">#Create a new transaction for the account#&gt;;</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *transactions = [account mutableArrayValueForKey:<span class="string">@"transactions"</span>];</span><br><span class="line">[transactions addObject:newTransaction];</span><br></pre></td></tr></table></figure><p>如上代码所示是自动 <code>KVO</code> 的触发方式</p><ul><li>手动 <code>KVO</code> 触发方式</li></ul><p>其实手动 <code>KVO</code> 可以帮助我们将多个属性值的更改合并成一个，这样在回调的时候就有一次了，同时也能最大程度地减少处于应用程序特定原因而导致的通知发生。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">    _balance = theBalance;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，最朴素的手动 <code>KVO</code> 使用方法就是在属性值改变前对观察者发送 <code>willChangeValueForKey</code> 实例方法，在属性值改变之后对观察者发送 <code>didChangeValueForKey</code> 实例方法，参数都是所观察的键。<br>当然，上面这种方式不是最佳的，为了性能最佳，可以在属性的 <code>setter</code> 中判断是否要执行 <code>will</code> + <code>did</code>:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    <span class="keyword">if</span> (theBalance != _balance) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">        _balance = theBalance;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果对一个属性的改变会影响到多个键的话，则需要如下的操作：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"itemChanged"</span>];</span><br><span class="line">    _balance = theBalance;</span><br><span class="line">    _itemChanged = _itemChanged+<span class="number">1</span>;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"itemChanged"</span>];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"balance"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于有序的一对多关系属性，不仅必须指定已更改的键，还必须指定更改的类型和所涉及对象的索引。 更改的类型是 <code>NSKeyValueChange</code>，它指定 <code>NSKeyValueChangeInsertion</code>，<code>NSKeyValueChangeRemoval</code> 或 <code>NSKeyValueChangeReplacement</code>，受影响的对象的索引作为 <code>NSIndexSet</code> 对象传递:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeTransactionsAtIndexes:(NSIndexSet *)indexes &#123;</span><br><span class="line">    [self willChange:NSKeyValueChangeRemoval</span><br><span class="line">        valuesAtIndexes:indexes forKey:@&quot;transactions&quot;];</span><br><span class="line"> </span><br><span class="line">    // Remove the transaction objects at the specified indexes.</span><br><span class="line"> </span><br><span class="line">    [self didChange:NSKeyValueChangeRemoval</span><br><span class="line">        valuesAtIndexes:indexes forKey:@&quot;transactions&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-注册从属关系的-KVO"><a href="#1-4-注册从属关系的-KVO" class="headerlink" title="1.4 注册从属关系的 KVO"></a>1.4 注册从属关系的 <code>KVO</code></h2><p>所谓从属关系，指的是一个对象的某个属性的值取决于另一个对象的一个或多个属性。对于不同类型的属性，有不同的方式来实现。</p><ul><li>一对一关系</li></ul><p>要触发 <strong>一对一</strong> 类型属性的自动 <code>KVO</code>，有两种方式。一种是重写 <code>keyPathsForValuesAffectingValueForKey</code> 方法，一种是实现一个合适的方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)fullName &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %@"</span>,firstName, lastName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面的代码，<code>fullName</code> 由 <code>firstName</code> 和 <code>lastName</code> 组成，所以重写 <code>fullName</code> 属性的 <code>getter</code> 方法。这样，不论是 <code>firstName</code> 还是 <code>lastName</code> 发生了改变，监听 <code>fullName</code> 属性的观察者都会收到通知。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"fullName"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *affectingKeys = @[<span class="string">@"lastName"</span>, <span class="string">@"firstName"</span>];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，通过实现类方法 <code>keyPathsForValuesAffectingValueForKey</code> 来返回一个集合。值得注意的是，这里需要先对父类发送 <code>keyPathsForValuesAffectingValueForKey</code> 消息，以免干扰父类中对此方法的重写。</p><p>实际上还有一个便利的方法，就是 <code>keyPathsForValuesAffecting&lt;Key&gt;</code>，<code>Key</code> 是属性的名称（需要首字母大写）。这个方法的效果和 <code>keyPathsForValuesAffectingValueForKey</code> 是一样的，但针对的某个具体属性。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingFullName &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"lastName"</span>, <span class="string">@"firstName"</span>, <span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对来说，在分类中去使用 <code>keyPathsForValuesAffectingFullName</code> 更合理，因为分类中是不允许重载方法的，所以 <code>keyPathsForValuesAffectingValueForKey</code> 方法肯定是不能在分类中使用的。</p><hr><ul><li>一对多关系</li></ul><p><code>keyPathsForValuesAffectingValueForKey</code>：方法不支持包含一对多关系的 <code>Key Path</code>。例如，假设你有一个 <code>Department</code>对象，该对象与 <code>Employee</code> 有一对多关系（即 <code>employees</code> 属性），而 <code>Employee</code> 具有 <code>salary</code> 属性。 如果需要在 <code>Department</code> 对象上增加<code>totalSalary</code> 属性，而该属性取决于关系中所有 <code>Employees</code> 的薪水。例如，您不能使用 <code>keyPathsForValuesAffectingTotalSalary</code> 和返回 <code>employees.salary</code> 作为键来执行此操作。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (context == totalSalaryContext) &#123;</span><br><span class="line">        [<span class="keyword">self</span> updateTotalSalary];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// deal with other observations and/or invoke super...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)updateTotalSalary &#123;</span><br><span class="line">    [<span class="keyword">self</span> setTotalSalary:[<span class="keyword">self</span> valueForKeyPath:<span class="string">@"employees.@sum.salary"</span>]];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)setTotalSalary:(<span class="built_in">NSNumber</span> *)newTotalSalary &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (totalSalary != newTotalSalary) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"totalSalary"</span>];</span><br><span class="line">        _totalSalary = newTotalSalary;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"totalSalary"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="built_in">NSNumber</span> *)totalSalary &#123;</span><br><span class="line">    <span class="keyword">return</span> _totalSalary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，将 <code>Department</code> 实例对象注册为观察者，然后观察对象为 <code>totalSalary</code> 属性，但是在通知回调中会手动调用 <code>totalSalary</code> 属性的 <code>setter</code> 方法，并且传入值是通过 <code>KVC</code> 的集合运算符的方式取出 <code>employees</code> 属性所对应的集合中所有 <code>sum</code> 值之和。然后在 <code>totalSalary</code> 属性的 <code>setter</code> 方法中，会相应的调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 方法。</p><p>如果使用的是 <code>Core Data</code>，你还可以把 <code>Department</code> 注册到 <code>NSNotificationCenter</code> 中来作为托管对象上下文的观察者。<code>Department</code> 应以类似于观察键值的方式响应 <code>Employee</code> 发布的相关变更通知。</p><h1 id="二、KVO-原理探究"><a href="#二、KVO-原理探究" class="headerlink" title="二、KVO 原理探究"></a>二、KVO 原理探究</h1><blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling.<br>【译】自动的键值观察的实现基于 <code>isa-swizzling</code>。</p><p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.<br>【译】<code>isa</code> 指针，顾名思义，指向的是对象所属的类，这个类维护了一个哈希表。这个哈希表基本上存储的是方法的 <code>SEL</code> 和 <code>IMP</code> 的键值对。 </p><p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p><p>【译】当一个观察者注册了对一个对象的某个属性键值观察之后，被观察对象的 <code>isa</code> 指针所指向的内容发生了变化，指向了一个<strong>中间类</strong>而不是真正的类。这也导致 <code>isa</code> 指针并不一定是指向实例所属的真正的类。</p></blockquote><p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p><blockquote><p>【译】你永远不应依靠 <code>isa</code> 指针来确定类成员身份。相反，你应该使用 <code>class</code> 方法来确定对象实例所属的类。</p></blockquote><h2 id="2-1-中间类"><a href="#2-1-中间类" class="headerlink" title="2.1 中间类"></a>2.1 中间类</h2><p>根据官网文档的内容，我们初步判断，在 <code>KVO</code> 底层实现中，会有一个所谓的中间类生成。而这个中间类会让对象的 <code>isa</code> 指针发生变化。我们不妨测试一下：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152136.jpg" alt></p><p>如上图所示，<code>person</code> 对象和 <code>personForTest</code> 对象都是属于 <code>JHPerson</code> 类的，而 <code>person</code> 对象又实现了 <code>KVO</code>，但是在控制台打印结果里面可以看到它们二者的类都是 <code>JHPerson</code> 类。不是说会有一个中间类生成吗？难道是这个中间类生成又被干掉了？我们直接<code>LLDB</code> 大法测试一下：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152148.jpg" alt></p><p>Bingo~，所谓的中间类 <code>NSKVONotifying_JHPerson</code> 被我们找出来了。那么其实这里显然，系统是重写了中间类 <code>NSKVONotifying_JHPerson</code> 的 <code>class</code> 方法，让我们以为对象的 <code>isa</code> 指针一直指向的都是 <code>JHPerson</code> 类。那么这个中间类和原来的类是什么关系呢?我们可以测试一下：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152151.jpg" alt></p><p>其中 <code>printClasses</code> 实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printClasses:(Class)cls&#123;</span><br><span class="line">    <span class="keyword">int</span> count = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mArray = [<span class="built_in">NSMutableArray</span> arrayWithObject:cls];</span><br><span class="line">    Class* classes = (Class*)malloc(<span class="keyword">sizeof</span>(Class)*count);</span><br><span class="line">    objc_getClassList(classes, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cls == class_getSuperclass(classes[i])) &#123;</span><br><span class="line">            [mArray addObject:classes[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(classes);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"classes = %@"</span>, mArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">classes = (</span><br><span class="line">    JHPerson</span><br><span class="line">)</span><br><span class="line">classes = (</span><br><span class="line">    JHPerson,</span><br><span class="line">    <span class="string">"NSKVONotifying_JHPerson"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>结果很清晰，中间类 <code>NSKVONotifying_JHPerson</code> 是作为原始真正的类 <code>JHPerson</code> 的子类的角色。</p><h2 id="2-2-KVO-观察的是什么？"><a href="#2-2-KVO-观察的是什么？" class="headerlink" title="2.2 KVO 观察的是什么？"></a>2.2 <code>KVO</code> 观察的是什么？</h2><p><code>KVO</code> 所关注的是属性值的变化，而属性值本质上是成员变量+<code>getter</code>+<code>setter</code>，<code>getter</code> 是用来获取值的，而显然只有 <code>setter</code> 和成员变量赋值两种方式可以改变属性值。我们测试一下这两种方式：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JHPerson.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JHPerson</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="built_in">NSString</span> *_nickName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152154.jpg" alt></p><p>如上图所示，<code>setter</code> 方法对属性 <code>name</code> 做了修改被 <code>KVO</code> 监听到了，而成员变量 <code>_nickName</code> 的修改并没有被监听到，说明 <code>KVO</code> 底层其实观察的是 <code>setter</code> 方法。</p><h2 id="2-3-中间类重写了哪些方法？"><a href="#2-3-中间类重写了哪些方法？" class="headerlink" title="2.3 中间类重写了哪些方法？"></a>2.3 中间类重写了哪些方法？</h2><p>我们可以通过打印原始类和中间类的方法列表来验证：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152159.jpg" alt></p><p><code>printClassAllMethod</code> 方法实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printClassAllMethod:(Class)cls&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"*********************"</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        SEL sel = method_getName(method);</span><br><span class="line">        IMP imp = class_getMethodImplementation(cls, sel);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@-%p"</span>,<span class="built_in">NSStringFromSelector</span>(sel),imp);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如上图所示，原始类和中间类都有 <code>setter</code> 方法。根据我们前面所探索的消息发送以及转发流程，这里的中间类应该是重写了 <code>setName:</code> 、<code>class</code>、 <code>dealloc</code> 和 <code>_isKVOA</code> 方法。</p><p>由我们上一小节的测试结果可知，中间类重写的 <code>class</code> 方法结果仍然是返回的是原始类，显然系统这样做的目的就是隐藏中间类的存在，让调用者调用 <code>class</code> 方法结果前后一致。</p><h2 id="2-4-KVO-中间类何时指回去？"><a href="#2-4-KVO-中间类何时指回去？" class="headerlink" title="2.4 KVO 中间类何时指回去？"></a>2.4 <code>KVO</code> 中间类何时指回去？</h2><p>我们推断 <code>KVO</code> 注册观察者到移除观察者这一个流程里面，被观察对象的 <code>isa</code> 指针才会指向中间类，我们用代码测试一下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152204.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152208.jpg" alt></p><p>由上图可知，观察者的 <code>dealloc</code> 方法中的移除观察者之后，对象的 <code>isa</code> 指针已经指回了原始的类。那么是不是此时中间类就被销毁了呢，我们不妨打印一下此时原始类的所有子类信息：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152208.jpg" alt></p><p>结果表明中间类仍然存在，也就是说移除观察者并不会导致中间类销毁，显然这样对于多次添加和移除观察者来说性能上更好。</p><h2 id="2-5-KVO-调用顺序"><a href="#2-5-KVO-调用顺序" class="headerlink" title="2.5 KVO 调用顺序"></a>2.5 <code>KVO</code> 调用顺序</h2><p>而我们前面说了，有一个中间类的存在，既然要生成中间类，肯定是有意义的，我们梳理一下整个 <code>KVO</code> 的流程，从注册观察者到观察者的回调通知，既然有回调通知，那么肯定是在某个地方发出回调的，而由于中间类是不能编译的，所以我们对中间类的父类也就是 <code>JHPerson</code> 类，我们重写一下相应的 <code>setter</code> 方法，我们不妨测试一下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JHPerson.m</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    [<span class="keyword">super</span> willChangeValueForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"willChangeValueForKey"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey - begin"</span>);</span><br><span class="line">    [<span class="keyword">super</span> didChangeValueForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey - end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152216.jpg" alt></p><p>也就是说 <code>KVO</code> 的调用顺序是:</p><ul><li>调用 <code>willChangeValueForKey:</code></li><li>调用原来的 <code>setter</code> 实现</li><li>调用 <code>didChangeValueForKey:</code></li></ul><p>也就是说 <code>didChangeValueForKey:</code> 内部必然是调用了 <code>observer</code> 的<code>observeValueForKeyPath:ofObject:change:context:</code>方法。</p><h1 id="三、自定义-KVO-如何实现"><a href="#三、自定义-KVO-如何实现" class="headerlink" title="三、自定义 KVO 如何实现"></a>三、自定义 KVO 如何实现</h1><p>我们已经初步了解了 <code>KVO</code> 底层原理，接下来我们尝试自己简单实现一下 <code>KVO</code>。<br>我们直接跳转到 <code>addObserver:forKeyPath:options:context:</code> 方法的声明处：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200219152219.jpg" alt></p><p>可以看到，跟 <code>KVC</code> 一样，<code>KVO</code> 在底层也是以分类的形式加载的，这个分类叫做 <code>NSKeyValueObserverRegistration</code>。我们不妨也以这种方式来自定义实现一下 <code>KVO</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSObject+JHKVO.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">JHKVO</span>)</span></span><br><span class="line"><span class="comment">// 观察者注册</span></span><br><span class="line">- (<span class="keyword">void</span>)jh_addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(JHKeyValueObservingOptions)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"><span class="comment">// 回调通知观察者</span></span><br><span class="line">- (<span class="keyword">void</span>)jh_observeValueForKeyPath:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object change:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>, <span class="keyword">id</span>&gt; *)change context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"><span class="comment">// 移除观察者</span></span><br><span class="line">- (<span class="keyword">void</span>)jh_removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这里为了避免与系统的方法冲突，所以添加了一个方法前缀。同时对于观察策略，为了简化实现，这里只声明了新值和旧值两种策略。</p><h2 id="3-1-自定义观察者注册"><a href="#3-1-自定义观察者注册" class="headerlink" title="3.1 自定义观察者注册"></a>3.1 自定义观察者注册</h2><p>在开始之前，我们回忆下自定义 <code>KVC</code> 的时候的第一个步骤就是判断 <code>key</code> 或者 <code>keyPath</code>，那么 <code>KVO</code> 是否也需要进行这样的判断呢?经过笔者实际测试，如果观察对象的一个不存在的属性的话，并不会报错，也不会来到 <code>KVO</code> 回调方法，由此可见，判断 <code>keyPath</code> 是否存在并没有必要。但是，我们回想一下上一节 <code>KVO</code> 底层原理，<code>KVO</code> 关注的是属性的 <code>setter</code> 方法，那其实判断对象所属的类是否有这样的 <code>setter</code> 就相当于同时判断了 <code>keyPath</code> 是否存在。接着我们就需要去动态的创建子类，创建子类的过程中包括了重写 <code>setter</code> 等一系列方法。然后就需要保存观察者和 <code>keyPath</code> 等信息，这里我们借助关联对象来实现，我们把传入的观察者对象、<code>keyPath</code>和观察策略封装成一个新的对象存储在关联对象中。因为同一个对象的属性可以被不同的观察者所观察，所以这里实质上是以对象数组的方式存储在关联对象里面。<br>话不多说，直接上代码:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JHKVOInfo.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, JHKeyValueObservingOptions) &#123;</span><br><span class="line">    JHKeyValueObservingOptionNew = <span class="number">0x01</span>,</span><br><span class="line">    JHKeyValueObservingOptionOld = <span class="number">0x02</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JHKVOInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSObject</span>  *observer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>  *keyPath;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) JHKeyValueObservingOptions options;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWitObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(JHKeyValueObservingOptions)options;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JHKVOInfo.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JHKVOInfo</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWitObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(JHKeyValueObservingOptions)options</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _observer = observer;</span><br><span class="line">        _keyPath = keyPath;</span><br><span class="line">        _options = options;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面的代码是自定义的 <code>JHKVOInfo</code> 对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kJHKVOPrefix = <span class="string">@"JHKVONotifying_"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kJHKVOAssiociateKey = <span class="string">@"kJHKVO_AssiociateKey"</span>;</span><br><span class="line">- (<span class="keyword">void</span>)jh_addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(JHKeyValueObservingOptions)options context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.判断 getter 是否存在</span></span><br><span class="line">    SEL setterSelector = <span class="built_in">NSSelectorFromString</span>(setterForGetter(keyPath));</span><br><span class="line">    Method setterMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], setterSelector);</span><br><span class="line">    <span class="keyword">if</span> (!setterMethod) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *reason = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"对象 %@ 的 key %@ 没有 setter 实现"</span>, <span class="keyword">self</span>, keyPath];</span><br><span class="line">        <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInvalidArgumentException</span></span><br><span class="line">                                       reason:reason</span><br><span class="line">                                     userInfo:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.动态创建中间子类</span></span><br><span class="line">    Class newClass = [<span class="keyword">self</span> createChildClassWithKeyPath:keyPath];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.将对象的isa指向为新的中间子类</span></span><br><span class="line">    object_setClass(<span class="keyword">self</span>, newClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.保存观察者</span></span><br><span class="line">    JHKVOInfo *info = [[JHKVOInfo alloc] initWitObserver:observer forKeyPath:keyPath options:options];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *observerArr = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!observerArr) &#123;</span><br><span class="line">        observerArr = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">1</span>];</span><br><span class="line">        [observerArr addObject:info];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey), observerArr, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是完整的添加观察者的流程：</p><ul><li>判断对象所属的类上是否有要观察的 <code>keyPath</code> 对应的 <code>setter</code> 方法</li></ul><blockquote><p>这里的 <code>setterForGetter</code> 实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">static</span> <span class="built_in">NSString</span> * setterForGetter(<span class="built_in">NSString</span> *<span class="keyword">getter</span>)</span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;    <span class="comment">// 判断 getter 是否为空字符串</span></span><br><span class="line">&gt;    <span class="keyword">if</span> (<span class="keyword">getter</span>.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">&gt;        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="comment">// 取出 getter 字符串的第一个字母并转大写 </span></span><br><span class="line">&gt;    <span class="built_in">NSString</span> *firstLetter = [[<span class="keyword">getter</span> substringToIndex:<span class="number">1</span>] uppercaseString];</span><br><span class="line">&gt;    <span class="comment">// 取出剩下的字符串内容</span></span><br><span class="line">&gt;    <span class="built_in">NSString</span> *remainingLetters = [<span class="keyword">getter</span> substringFromIndex:<span class="number">1</span>];</span><br><span class="line">&gt;    <span class="comment">// 将首字母大写的字母与剩下的字母拼接起来得到 `set&lt;KeyPath&gt;` 格式的字符串</span></span><br><span class="line">&gt;    <span class="built_in">NSString</span> *<span class="keyword">setter</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@%@:"</span>, firstLetter, remainingLetters];</span><br><span class="line">&gt;    <span class="keyword">return</span> <span class="keyword">setter</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li>如果存在相应的 <code>setter</code> 方法，那么就创建有对应前缀的中间子类</li></ul><blockquote><p>这里的 <code>createChildClassWithKeyPath</code> 实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; - (Class)createChildClassWithKeyPath:(<span class="built_in">NSString</span> *)keyPath&#123;</span><br><span class="line">&gt;     <span class="comment">// 获得原始类的类名</span></span><br><span class="line">&gt;     <span class="built_in">NSString</span> *oldClassName = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">&gt;     <span class="comment">// 在原始类名前添加中间子类的前缀来获得中间子类名</span></span><br><span class="line">&gt;     <span class="built_in">NSString</span> *newClassName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@"</span>,kJHKVOPrefix,oldClassName];</span><br><span class="line">&gt;     <span class="comment">// 通过中间子类名来判断是否创建过</span></span><br><span class="line">&gt;     Class newClass = <span class="built_in">NSClassFromString</span>(newClassName);</span><br><span class="line">&gt;     <span class="comment">// 如果创建过中间子类，直接返回</span></span><br><span class="line">&gt;     <span class="keyword">if</span> (newClass) <span class="keyword">return</span> newClass;</span><br><span class="line">&gt;     <span class="comment">// 如果没有创建过，则需要创建一下, objc_allocateClassPair 方法的三个参数分别为: 1.父类 2.新类的名字 3.创建新类所需额外的空间</span></span><br><span class="line">&gt;     newClass = objc_allocateClassPair([<span class="keyword">self</span> <span class="keyword">class</span>], newClassName.UTF8String, <span class="number">0</span>);</span><br><span class="line">&gt;     <span class="comment">// 注册中间子类</span></span><br><span class="line">&gt;     objc_registerClassPair(newClass);</span><br><span class="line">&gt;     <span class="comment">// 从父类上拿到 `class` 方法的 `SEL` 以及类型编码，然后在中间子类上添加一个新的子类实现 `jh_class`</span></span><br><span class="line">&gt;     SEL classSEL = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"class"</span>);</span><br><span class="line">&gt;     Method classMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], classSEL);</span><br><span class="line">&gt;     <span class="keyword">const</span> <span class="keyword">char</span> *classTypes = method_getTypeEncoding(classMethod);</span><br><span class="line">&gt;     class_addMethod(newClass, classSEL, (IMP)jh_class, classTypes);</span><br><span class="line">&gt;     <span class="comment">// 从父类上拿到 `getter` 方法的 `SEL` 以及类型编码，然后在中间子类上添加一个新的子类实现 `jh_setter`</span></span><br><span class="line">&gt;     SEL setterSEL = <span class="built_in">NSSelectorFromString</span>(setterForGetter(keyPath));</span><br><span class="line">&gt;     Method setterMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], setterSEL);</span><br><span class="line">&gt;     <span class="keyword">const</span> <span class="keyword">char</span> *setterTypes = method_getTypeEncoding(setterMethod);</span><br><span class="line">&gt;     class_addMethod(newClass, setterSEL, (IMP)jh_setter, setterTypes);</span><br><span class="line">&gt;     <span class="keyword">return</span> newClass;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>jh_class</code> 的实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; Class jh_class(<span class="keyword">id</span> <span class="keyword">self</span>,SEL _cmd) &#123;</span><br><span class="line">&gt;    <span class="comment">// 通过 class_getSuperclass 来返回父类的 `Class`，达到对调用者隐藏中间子类的效果</span></span><br><span class="line">&gt;    <span class="keyword">return</span> class_getSuperclass(object_getClass(<span class="keyword">self</span>));</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>jh_setter</code> 的实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">static</span> <span class="keyword">void</span> jh_setter(<span class="keyword">id</span> <span class="keyword">self</span>,SEL _cmd,<span class="keyword">id</span> newValue)&#123;</span><br><span class="line">&gt;     <span class="comment">// 因为 `_cmd` 作为方法的第二个参数其实就是 `setter` 的 `SEL`，这里反向获得对应 `getter` 字符串形式作为 `keyPath`，然后通过 `KVC` 来获取到旧的属性值</span></span><br><span class="line">&gt;     <span class="built_in">NSString</span> *keyPath = getterForSetter(<span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">&gt;     <span class="keyword">id</span> oldValue       = [<span class="keyword">self</span> valueForKey:keyPath];</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     <span class="comment">// 因为是重写父类的 `setter`，所以还需要通过消息发送的方式手动执行以下父类的 `setter` 方法</span></span><br><span class="line">&gt;     <span class="comment">// 通过强转的方式将 `objc_msgSendSuper` 转成 `jh_msgSendSuper` 函数指针，同时，由于 `objc_msgSendSuper` 要比我们常见的 `objc_msgSend` 多一个父类结构体参数，所以需要手动构建一下这个父类结构体，结构体有两个属性，分别是实例对象以及实例对象的类的父类</span></span><br><span class="line">&gt;     <span class="keyword">void</span> (*jh_msgSendSuper)(<span class="keyword">void</span> *, SEL, <span class="keyword">id</span>) = (<span class="keyword">void</span> *)objc_msgSendSuper;</span><br><span class="line">&gt;     <span class="comment">// void /* struct objc_super *super, SEL op, ... */</span></span><br><span class="line">&gt;     <span class="keyword">struct</span> objc_super superStruct = &#123;</span><br><span class="line">&gt;         .receiver = <span class="keyword">self</span>,</span><br><span class="line">&gt;         .super_class = class_getSuperclass(object_getClass(<span class="keyword">self</span>)),</span><br><span class="line">&gt;     &#125;;</span><br><span class="line">&gt;     <span class="comment">// 准备工作完成后手动调用 `jh_msgSendSuper`，因为 `superStruct` 是结构体类型，而 `jh_msgSendSuper` 的第一个参数是空指针对象，所以这里需要加取地址符来把结构体地址赋值给指针对象</span></span><br><span class="line">&gt;     jh_msgSendSuper(&amp;superStruct, _cmd, newValue);</span><br><span class="line">&gt;     <span class="comment">// 调用完父类的 `setter` 之后，从关联对象中取出存储了自定义的对象数组</span></span><br><span class="line">&gt;     <span class="built_in">NSMutableArray</span> *observerArr = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey));</span><br><span class="line">&gt;     <span class="comment">// 循环遍历自定义的对象</span></span><br><span class="line">&gt;     <span class="keyword">for</span> (JHKVOInfo *info <span class="keyword">in</span> observerArr) &#123;</span><br><span class="line">&gt;     <span class="comment">// 如果 `keyPath` 匹配则进入下一步</span></span><br><span class="line">&gt;         <span class="keyword">if</span> ([info.keyPath isEqualToString:keyPath]) &#123;</span><br><span class="line">&gt;             <span class="comment">// 基于线程安全的考虑，使用 `GCD` 的全局队列异步执行下面的操作 </span></span><br><span class="line">&gt;             <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">&gt;                 <span class="comment">// 初始化一个通知字典</span></span><br><span class="line">&gt;                 <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *change = [<span class="built_in">NSMutableDictionary</span> dictionaryWithCapacity:<span class="number">1</span>];</span><br><span class="line">&gt;                 <span class="comment">// 判断存储的观察策略，如果是新值，则在通知字典中设置新值  </span></span><br><span class="line">&gt;                 <span class="keyword">if</span> (info.options &amp; JHKeyValueObservingOptionNew) &#123;</span><br><span class="line">&gt;                     [change setObject:newValue forKey:<span class="built_in">NSKeyValueChangeNewKey</span>];</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;                 <span class="comment">// 如果是旧值，在通知字典中设置旧值</span></span><br><span class="line">&gt;                 <span class="keyword">if</span> (info.options &amp; JHKeyValueObservingOptionOld) &#123;</span><br><span class="line">&gt;                     [change setObject:<span class="string">@""</span> forKey:<span class="built_in">NSKeyValueChangeOldKey</span>];</span><br><span class="line">&gt;                     <span class="keyword">if</span> (oldValue) &#123;</span><br><span class="line">&gt;                         [change setObject:oldValue forKey:<span class="built_in">NSKeyValueChangeOldKey</span>];</span><br><span class="line">&gt;                     &#125;</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;                 <span class="comment">// 取得通知观察者方法的 `SEL`</span></span><br><span class="line">&gt;                 SEL observerSEL = <span class="keyword">@selector</span>(jh_observeValueForKeyPath:ofObject:change:context:);</span><br><span class="line">&gt;                 <span class="comment">// 通过 `objc_msgSend` 手动发送消息，达到观察者收到回调的效果</span></span><br><span class="line">&gt;                 ((<span class="keyword">void</span>(*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>, <span class="keyword">id</span>, <span class="built_in">NSMutableDictionary</span> *, <span class="keyword">void</span> *))objc_msgSend)(info.observer, observerSEL, keyPath, <span class="keyword">self</span>, change, <span class="literal">NULL</span>);</span><br><span class="line">&gt;             &#125;);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>getterForSetter</code> 实现如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">static</span> <span class="built_in">NSString</span> *getterForSetter(<span class="built_in">NSString</span> *<span class="keyword">setter</span>)&#123;</span><br><span class="line">&gt;     <span class="comment">// 判断传入的 `setter` 字符串长度是否大于 0，以及是否有 `set` 的前缀和 `:` 的后缀</span></span><br><span class="line">&gt;     <span class="keyword">if</span> (<span class="keyword">setter</span>.length &lt;= <span class="number">0</span> || ![<span class="keyword">setter</span> hasPrefix:<span class="string">@"set"</span>] || ![<span class="keyword">setter</span> hasSuffix:<span class="string">@":"</span>]) &#123; <span class="keyword">return</span> <span class="literal">nil</span>;&#125;</span><br><span class="line">&gt;     <span class="comment">// 排除掉 `setter` 字符串中的 `set:` 部分以取得 getter 字符串</span></span><br><span class="line">&gt;     <span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(<span class="number">3</span>, <span class="keyword">setter</span>.length<span class="number">-4</span>);</span><br><span class="line">&gt;     <span class="built_in">NSString</span> *<span class="keyword">getter</span> = [<span class="keyword">setter</span> substringWithRange:range];</span><br><span class="line">&gt;     <span class="comment">// 对 getter 字符串首字母小写处理</span></span><br><span class="line">&gt;     <span class="built_in">NSString</span> *firstString = [[<span class="keyword">getter</span> substringToIndex:<span class="number">1</span>] lowercaseString];</span><br><span class="line">&gt;     <span class="keyword">return</span>  [<span class="keyword">getter</span> stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>) withString:firstString];</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><h2 id="3-2-自定义移除观察者"><a href="#3-2-自定义移除观察者" class="headerlink" title="3.2 自定义移除观察者"></a>3.2 自定义移除观察者</h2><p>我们接着开始自定义移除观察者，首先，我们需要把 <code>isa</code> 指回原来的类，然后需要对关联对象中存储的自定义对象数组对应的观察者移除掉。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)jh_removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从关联对象中取出数组</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *observerArr = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey));</span><br><span class="line">    <span class="comment">// 如果数组中没有内容，说明没有添加过观察者，那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (observerArr.count&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历取出的所有自定义对象</span></span><br><span class="line">    <span class="keyword">for</span> (JHKVOInfo *info <span class="keyword">in</span> observerArr) &#123;</span><br><span class="line">        <span class="comment">// 如果 `keyPath` 匹配上了 则从数组中移除响应对象，然后存储最新的数组到关联对象上</span></span><br><span class="line">        <span class="keyword">if</span> ([info.keyPath isEqualToString:keyPath]) &#123;</span><br><span class="line">            [observerArr removeObject:info];</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey), observerArr, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 要将 `isa` 指回原来的类的前提条件是，被观察属性的对象已经没有任何观察者在观察了，那么就需要指回去</span></span><br><span class="line">    <span class="keyword">if</span> (observerArr.count&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        Class superClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        object_setClass(<span class="keyword">self</span>, superClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-实现自动移除观察者"><a href="#3-3-实现自动移除观察者" class="headerlink" title="3.3 实现自动移除观察者"></a>3.3 实现自动移除观察者</h2><p>现在我们自定义的 <code>KVO</code> 已经可以实现简单的通知观察者新值和旧值的变化了，但其实对于 <code>api</code> 的使用者来说，还是要严格的执行 <code>addObserver</code> 和 <code>removeObserver</code> 的配套操作，难免有些繁琐。虽然一般来说为了方便起见，都是在观察者的 <code>dealloc</code> 方法中去手动调用 <code>removeObserver</code> 方法，但还是太麻烦了。因此，我们可以借助 <code>methodSwizzling</code> 的技术来替换默认 <code>dealloc</code> 方法的实现，直接上代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)jh_hookOrigInstanceMenthod:(SEL)oriSEL newInstanceMenthod:(SEL)swizzledSEL &#123;</span><br><span class="line">    <span class="comment">// 获取 Class 对象</span></span><br><span class="line">    Class cls = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 通过 `SEL` 获取原始方法</span></span><br><span class="line">    Method oriMethod = class_getInstanceMethod(cls, oriSEL);</span><br><span class="line">    <span class="comment">// 通过 `SEL` 获取要替换的方法</span></span><br><span class="line">    Method swiMethod = class_getInstanceMethod(cls, swizzledSEL);</span><br><span class="line">    <span class="comment">// 如果要替换的方法不存在，返回 NO</span></span><br><span class="line">    <span class="keyword">if</span> (!swiMethod) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果原始方法不存在，那么就直接在 Class 上添加要替换的方法，注意，添加的方法实现为要替换的方法，但是方法 `SEL` 还是原始方法的 `SEL`</span></span><br><span class="line">    <span class="keyword">if</span> (!oriMethod) &#123;</span><br><span class="line">        class_addMethod(cls, oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(swiMethod));</span><br><span class="line">        method_setImplementation(swiMethod, imp_implementationWithBlock(^(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)&#123; &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否添加成功</span></span><br><span class="line">    <span class="built_in">BOOL</span> didAddMethod = class_addMethod(cls, oriSEL, method_getImplementation(swiMethod), method_getTypeEncoding(swiMethod));</span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">    <span class="comment">// 如果成功，说明 Class 上已经存在了要替换的方法的实现，那么就把原始方法实现替换掉 `swizzledSEL` 对应的方法实现</span></span><br><span class="line">        class_replaceMethod(cls, swizzledSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 如果不成功，说明原始方法已经存在，则直接交换方法实现</span></span><br><span class="line">        method_exchangeImplementations(oriMethod, swiMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> jh_hookOrigInstanceMenthod:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"dealloc"</span>) newInstanceMenthod:<span class="keyword">@selector</span>(myDealloc)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)myDealloc&#123;</span><br><span class="line">    Class superClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">    object_setClass(<span class="keyword">self</span>, superClass);</span><br><span class="line">    <span class="comment">// 这里并不会造成循环引用的递归，因为 `myDealloc` 的方法实现是真正的原始 `dealloc`</span></span><br><span class="line">    [<span class="keyword">self</span> myDealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现自动移除观察者，<code>api</code> 的使用者可以完全放心的只使用 <code>addObserver</code> 来添加观察者以及 <code>observeValueForKeyPath</code> 来接收回调。</p><h2 id="3-4-函数式编程思想重构"><a href="#3-4-函数式编程思想重构" class="headerlink" title="3.4 函数式编程思想重构"></a>3.4 函数式编程思想重构</h2><p>我们虽然已经实现了自动的移除观察者，但是从函数式编程思想来看，现在的设计还不是很完美，对同一个属性的观察的代码散落在不同的地方，如果业务一旦增多，对于可读性和可维护性都有很大的影响。所以，我们可以把现在这种回调的形式重构为 <code>Block</code> 的方式。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSObject+JHBlockKVO.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^JHKVOBlock)(<span class="keyword">id</span> observer,<span class="built_in">NSString</span> *keyPath,<span class="keyword">id</span> oldValue,<span class="keyword">id</span> newValue);</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">JHBlockKVO</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)jh_addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath block:(JHKVOBlock)block;</span><br><span class="line">- (<span class="keyword">void</span>)jh_removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSObject+JHBlockKVO.m</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JHBlockKVOInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSObject</span>   *observer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>   *keyPath;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) JHKVOBlock  handleBlock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JHBlockKVOInfo</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWitObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath handleBlock:(JHKVOBlock)block&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>=[<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _observer = observer;</span><br><span class="line">        _keyPath  = keyPath;</span><br><span class="line">        _handleBlock = block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">JHBlockKVO</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)jh_addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath block:(JHKVOBlock)block&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.判断 getter 是否存在</span></span><br><span class="line">    SEL setterSelector = <span class="built_in">NSSelectorFromString</span>(setterForGetter(keyPath));</span><br><span class="line">    Method setterMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], setterSelector);</span><br><span class="line">    <span class="keyword">if</span> (!setterMethod) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *reason = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"对象 %@ 的 key %@ 没有 setter 实现"</span>, <span class="keyword">self</span>, keyPath];</span><br><span class="line">        <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="built_in">NSInvalidArgumentException</span></span><br><span class="line">                                       reason:reason</span><br><span class="line">                                     userInfo:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.动态创建中间子类</span></span><br><span class="line">    Class newClass = [<span class="keyword">self</span> createChildClassWithKeyPath:keyPath];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.将对象的isa指向为新的中间子类</span></span><br><span class="line">    object_setClass(<span class="keyword">self</span>, newClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.保存观察者</span></span><br><span class="line">    JHBlockKVOInfo *info = [[JHBlockKVOInfo alloc] initWitObserver:observer forKeyPath:keyPath handleBlock:block];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mArray = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey));</span><br><span class="line">    <span class="keyword">if</span> (!mArray) &#123;</span><br><span class="line">        mArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">1</span>];</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey), mArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    [mArray addObject:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们直接通过传入分类一个 <code>block</code>，然后存储在对应的自定义观察对象中，然后我们还需要在重写 <code>setter</code> 方法中做出修改，原来是直接通过发送消息来实现回调，现在需要改成 <code>block</code> 回调</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> jh_setter(<span class="keyword">id</span> <span class="keyword">self</span>,SEL _cmd,<span class="keyword">id</span> newValue)&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *keyPath = getterForSetter(<span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">    <span class="keyword">id</span> oldValue = [<span class="keyword">self</span> valueForKey:keyPath];</span><br><span class="line">    <span class="keyword">void</span> (*jh_msgSendSuper)(<span class="keyword">void</span> *,SEL , <span class="keyword">id</span>) = (<span class="keyword">void</span> *)objc_msgSendSuper;</span><br><span class="line">    <span class="keyword">struct</span> objc_super superStruct = &#123;</span><br><span class="line">        .receiver = <span class="keyword">self</span>,</span><br><span class="line">        .super_class = class_getSuperclass(object_getClass(<span class="keyword">self</span>)),</span><br><span class="line">    &#125;;</span><br><span class="line">    jh_msgSendSuper(&amp;superStruct,_cmd,newValue);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mArray = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJHKVOAssiociateKey));</span><br><span class="line">    <span class="keyword">for</span> (JHBlockKVOInfo *info <span class="keyword">in</span> mArray) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([info.keyPath isEqualToString:keyPath] &amp;&amp; info.handleBlock) &#123;</span><br><span class="line">            info.handleBlock(info.observer, keyPath, oldValue, newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>经过探索 <code>KVC</code> 和 <code>KVO</code> 的底层，我们可以看到 <code>KVO</code> 是建立在 <code>KVC</code> 基础之上的。<code>KVO</code> 作为观察者设计模式在 <code>iOS</code> 中的具体落地，其原理到实现我们都探索完了。其实我们可以看出来在早期设计 <code>api</code> 的时候，原生的 <code>KVO</code> 其实并不好用，所以诸如 <code>FaceBook</code> 的库 <a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">KVOController</a> 会大受欢迎。当然本文的自定义 <code>KVO</code> 实现并不严谨，感兴趣的读者可以查看这两个代码库：</p><ul><li>根据原生的 <code>KVC</code> 和 <code>KVO</code> 反汇编而成 <a href="https://github.com/renjinkui2719/DIS_KVC_KVO" target="_blank" rel="noopener">DIS_KVC_KVO</a></li><li>开源的 <code>GNUStep</code> 的 <code>libs-base</code> <a href="https://github.com/gnustep/libs-base" target="_blank" rel="noopener">gnustep/libs-base</a></li></ul><p>我们的 <code>iOS</code> 底层探索系列接下来将会进入多线程篇章，敬请期待~</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA" target="_blank" rel="noopener">Key-Value Observing Programming Guide - Apple 官方文档 </a></p><p><a href="https://nshipster.cn/nil/" target="_blank" rel="noopener">nil/Nil/Null/NSNull - NSHipster</a></p><p><a href="https://nshipster.cn/key-value-observing/" target="_blank" rel="noopener">Key-Value Observing - NSHipster</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 &lt;code&gt;Objective-C&lt;/code&gt; 和 &lt;code&gt;Cocoa&lt;/code&gt; 中，有许多事件之间进行通信的方式，并且每个都有不同程度的形式和耦合:&lt;br&gt;&lt;code&gt;NSNotification&lt;/code&gt; &amp;amp; &lt;code&gt;NSNotificationCenter&lt;/code&gt; 提供了一个中央枢纽，一个应用的任何部分都可能通知或者被通知应用的其他部分的变化。唯一需要做的是要知道在寻找什么，主要是通知的名字。例如，&lt;code&gt;UIApplicationDidReceiveMemoryWarningNotification&lt;/code&gt; 是给应用发了一个内存不足的信号。&lt;br&gt;&lt;code&gt;Key-Value Observing&lt;/code&gt; 键值观察通过侦听特定键路径上的更改，可以在特定对象实例之间进行特殊的事件自省。例如：一个 &lt;code&gt;ProgressView&lt;/code&gt; 可以观察 网络请求的 &lt;code&gt;numberOfBytesRead&lt;/code&gt; 来更新它自己的 &lt;code&gt;progress&lt;/code&gt; 属性。&lt;br&gt;&lt;code&gt;Delegate&lt;/code&gt; 是一个流行的传递事件的设计模式，通过定义一系列的方法来传递给指定的处理对象。例如：&lt;code&gt;UIScrollView&lt;/code&gt; 每次它的 &lt;code&gt;scroll offset&lt;/code&gt; 改变的时候都会发送 &lt;code&gt;scrollViewDidScroll:&lt;/code&gt; 到它的代理&lt;br&gt;&lt;code&gt;Callbacks&lt;/code&gt; 不管是像 &lt;code&gt;NSOperation&lt;/code&gt; 里的 &lt;code&gt;completionBlock&lt;/code&gt;（当 &lt;code&gt;isFinished==YES&lt;/code&gt; 的时候会触发），还是 &lt;code&gt;C&lt;/code&gt; 里边的函数指针，传递一个函数钩子比如 &lt;code&gt;SCNetworkReachabilitySetCallback(3)&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
      <category term="KVO" scheme="http://leejunhui.com/tags/KVO/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - KVC</title>
    <link href="http://leejunhui.com/2020/02/15/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-KVC/"/>
    <id>http://leejunhui.com/2020/02/15/iOS-底层探索-KVC/</id>
    <published>2020-02-14T18:34:44.000Z</published>
    <updated>2020-02-14T18:37:00.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、KVC-初探"><a href="#一、KVC-初探" class="headerlink" title="一、KVC 初探"></a>一、KVC 初探</h1><p><code>Key Value Coding</code> 也即 <code>KVC</code> 是 <code>iOS</code> 开发中一个很重要的概念，中文翻译过来是 <code>键值编码</code> ，关于这个概念的具体定义可以在 <code>Apple</code> 的<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="noopener">官方文档</a>处找到。</p><blockquote><p>Key-value coding is a mechanism enabled by the NSKeyValueCoding informal protocol that objects adopt to provide indirect access to their properties.<br>【译】<code>KVC</code> 是通过 <code>NSKeyValueCoding</code> 这个非正式协议启用的一种机制，而遵循了这个协议的对象就提供了对其属性的间接访问。</p></blockquote><a id="more"></a><p>我们通常使用访问器方法来访问对象的属性，即使用 <code>getter</code> 来获取属性值，使用 <code>setter</code> 来设置属性值。而在 <code>Objective-C</code> 中，我们还可以直接通过实例变量的方式来获取属性值和设置属性值。如下面的代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// JHPerson.h</span><br><span class="line">@interface JHPerson : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">    NSString *myName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// ViewController.m</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    JHPerson *person = [[JHPerson alloc] init];</span><br><span class="line">    person.name      = @&quot;leejunhui&quot;;</span><br><span class="line">    person.age       = 20;</span><br><span class="line">    person-&gt;myName   = @&quot;leejunhui&quot;;</span><br><span class="line">    NSLog(@&quot;%@ - %ld - %@&quot;,person.name, person.age,person-&gt;myName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式我们再熟悉不过了，关于属性会由编译器自动生成 <code>getter</code> 和 <code>setter</code> 以及对应的实例变量前面我们已经探索过了，我们可以在 <code>ro</code> 中来找到它们的踪影，感兴趣的读者可以翻阅前面的文章。</p><blockquote><p>这里再明确下实例变量、成员变量、属性之间的区别：<br>在 @interface 括号里面声明的变量统称为 <strong>成员变量</strong><br>而成员变量实际上由两部分组成：<strong>实例变量</strong> + <strong>基本数据类型变量</strong><br>而<strong>属性</strong> = <strong>成员变量</strong> + <strong>getter方法</strong> + <strong>setter方法</strong></p></blockquote><p>那其实这里分两种情况，自己实现和编译器帮我们实现。</p><h2 id="1-1-自己实现-getter-和-setter"><a href="#1-1-自己实现-getter-和-setter" class="headerlink" title="1.1 自己实现 getter 和 setter"></a>1.1 自己实现 <code>getter</code> 和 <code>setter</code></h2><p>这里我们以 <code>JHPerson</code> 类的 <code>name</code> 属性为例，我们分别重写 <code>name</code> 的 <code>getter</code> 和 <code>setter</code> 方法，这里还有个注意点，我们需要在 <code>@interface</code> 中声明一下实例变量 <code>_name</code>，具体代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// JHPerson.h</span><br><span class="line">@interface JHPerson : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">    NSString *myName;</span><br><span class="line">    NSString *_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// JHPerson.m</span><br><span class="line">@implementation JHPerson</span><br><span class="line"></span><br><span class="line">- (NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    return _name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>接着，我们在 <code>main.m</code> 中使用点语法对 <code>name</code> 进行赋值，然后打印 <code>name</code> 的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;JHPerson.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        JHPerson *person = [[JHPerson alloc] init];</span><br><span class="line">        person.name      = @&quot;leejunhui&quot;;</span><br><span class="line">        NSLog(@&quot;person 姓名为：%@&quot;, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-[JHPerson setName:] - leejunhui</span><br><span class="line">-[JHPerson name] - leejunhui</span><br><span class="line">person 姓名为：leejunhui</span><br></pre></td></tr></table></figure><p>显然，这里的结果就表明了 <code>person.name      = @&quot;leejunhui&quot;;</code> 其实是调用了 <code>JHPerson</code> 类的 <code>setName</code> 方法，而 <code>NSLog(@&quot;person 姓名为：%@&quot;, person.name);</code> 则是调用了 <code>name</code> 方法。</p><p>这块的逻辑我相信读者应该都比较熟悉了，接下来我们再分析编译器自动生成 <code>getter</code> 和 <code>setter</code> 的场景。</p><h2 id="1-2-编译器自动实现-getter-和-setter"><a href="#1-2-编译器自动实现-getter-和-setter" class="headerlink" title="1.2 编译器自动实现 getter 和 setter"></a>1.2 编译器自动实现 <code>getter</code> 和 <code>setter</code></h2><p>我们探索前先思考一个问题，按照我们现在的认知，如果我们不去重写属性的 <code>getter</code> 和 <code>setter</code> 方法以及声明对应的实例变量，那么编译器就会帮我们做这件事，那么是不是说有多少个属性，就会生成多少个对应的 <code>getter</code> 和 <code>setter</code> 呢？显然，编译器不会这么傻，这样做不论是从性能上还是设计上都十分笨拙，我们在 <code>libObjc</code> 源码中可以找到这么一个源文件：<code>objc-accessors.mm</code>，这个文件中有许多从字面意思上看起来像是设置属性的方法，如下图所示：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014508.jpg" alt="img"></p><p>我们聚焦这个方法: <code>objc_setProperty_nonatomic_copy</code>，为什么呢？因为 <code>name</code> 属性声明为 <code>@property (nonatomic, copy) NSString *name;</code>，二者都包含 <code>nonatomic</code> 和 <code>copy</code> 关键字，我们不妨在 <code>objc_setProperty_nonatomic_copy</code> 方法处打上断点，注意，此时我们需要注释掉我们刚才自己添加的 <code>getter</code> 和 <code>setter</code> 方法。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014453.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014503.jpg" alt="img"></p><p>Bingo~，<code>objc_setProperty_nonatomic_copy</code> 方法果然被调用了，并且我们赋的值也是对的，我们来到这个方法内部实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setProperty_nonatomic_copy</span><span class="params">(id self, SEL _cmd, id newValue, <span class="keyword">ptrdiff_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reallySetProperty(self, _cmd, newValue, offset, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里又包裹了一层，真正的实现为 <code>reallySetProperty</code>：</p><p>这个方法不是很复杂，我们简单过一下这个方法的参数。</p><blockquote><p>1.首先是这个方法的 <code>offset</code> 参数，前面我们已经探索过关于<em>内存偏移</em>的内容，这里不再赘述。我们知道，对象的 <code>isa</code> 指针占 <code>8</code> 个字节，还寄的我们的 <code>JHPerson</code> 类的声明中有一个实例变量 <code>myName</code> 吗，这是一个字符串类型的实例变量，也占用 <code>8</code> 个字节，所以这里的 <code>offset</code> 为 <code>16</code>，意思就是偏移 <code>16</code> 个字节来设置属性 <code>name</code>。<br><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014457.jpg" alt="img"></p></blockquote><blockquote><p>2.然后是 <code>atomic</code> 参数，这个参数取决于属性声明时是 <code>atomic</code> 还是 <code>nonatomic</code>，这个关键字表示是操作的原子性，而网上很多资料都说 <code>atomic</code> 是来保证对象的多线程安全，其实不然，它只是能保证你访问的时候给你返回一个完好无损的 <code>Value</code> 而已，<a href="https://link.jianshu.com/?t=https://realm.io/news/tmi-objective-c-property-attributes/" target="_blank" rel="noopener">Realm官方对此相关的解释</a>，举个例子：</p><blockquote><p>如果线程 A 调了 getter，与此同时线程 B 、线程 C 都调了 setter——那最后线程 A get 到的值，有3种可能：可能是 B、C set 之前原始的值，也可能是 B set 的值，也可能是 C set 的值。同时，最终这个属性的值，可能是 B set 的值，也有可能是 C set 的值。所以 <code>atomic</code> 并不能保证对象的线程安全。也就是说 <code>atomic</code> 所说的线程安全只是保证了<code>getter</code> 和 <code>setter</code> 存取方法的线程安全，并不能保证整个对象是线程安全的。</p></blockquote><p><code>nonatomic</code> 关键字就没有这个保证了，<code>nonatomic</code> 返回你的对象可能就不是完整的<code>value</code> 。因此，在多线程的环境下原子操作是非常必要的，否则有可能会引起错误的结果。但仅仅使用 <code>atomic</code> 并不会使得对象线程安全，我们还要为对象线程添加 <code>lock</code> 来确保线程的安全。</p><p><strong><code>nonatomic</code> 对象 <code>setter</code> 和 <code>getter</code> 方法的实现</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; - (void)setCurrentImage:(UIImage *)currentImage</span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;    if (_currentImage != currentImage) &#123;</span><br><span class="line">&gt;        [_currentImage release];</span><br><span class="line">&gt;        _currentImage = [currentImage retain];</span><br><span class="line">&gt;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;- (UIImage *)currentImage</span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;    return _currentImage;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong><code>atomic</code> 对象 <code>setter</code> 和 <code>getter</code> 方法的实现</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; - (void)setCurrentImage:(UIImage *)currentImage</span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;    @synchronized(self) &#123;</span><br><span class="line">&gt;        if (_currentImage != currentImage) &#123;</span><br><span class="line">&gt;            [_currentImage release];</span><br><span class="line">&gt;            _currentImage = [currentImage retain];</span><br><span class="line">&gt;</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;- (UIImage *)currentImage</span><br><span class="line">&gt;&#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        return _currentImage;</span><br><span class="line">    &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>3.最后是 <code>copy</code> 和 <code>mutableCopy</code> 参数，说到 <code>copy</code> 关键字不妨来复习下 <code>iOS</code> 中的属性标识符以及相应的变量标识符。</p></blockquote><hr><p>在 <code>ARC</code> 中与内存管理有关的变量标识符，有下面几种：</p><ul><li><code>__strong</code></li><li><code>__weak</code></li><li><code>__unsafe_unretained</code></li><li><code>__autoreleasing</code></li></ul><table><thead><tr><th>变量标识符</th><th>作用</th></tr></thead><tbody><tr><td><code>__strong</code></td><td>默认使用的标识符。只有还有一个强指针指向某个对象，这个对象就会一直存活</td></tr><tr><td><code>__weak</code></td><td>声明这个引用<strong>不会保持</strong>被引用对象的存活，如果对象没有强引用了，弱引用会被<strong>置为 <code>nil</code></strong></td></tr><tr><td><code>__unsafe_unretained</code></td><td>声明这个引用<strong>不会保持</strong>被引用对象的存活，如果对象没有强引用了，它不<strong>会被置为 nil</strong>。如果它引用的对象被回收掉了，该指针就变成了<strong>野指针</strong></td></tr><tr><td><code>__autoreleasing</code></td><td>用于标示使用引用传值的参数（id *），在函数返回时会被自动释放掉</td></tr></tbody></table><p>变量标识符的用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number* __strong num = [[Number alloc] init];</span><br></pre></td></tr></table></figure><p>注意 <code>__strong</code> 的位置应该放到 <code>*</code> 和变量名中间，放到其他的位置严格意义上说是不正确的，只不过编译器不会报错。</p><hr><p><strong>属性标识符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic/nonatomic/assign/retain/strong/weak/unsafe_unretained/copy) Number* num</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性标识符</th><th>作用</th></tr></thead><tbody><tr><td><code>atomic</code></td><td>表明该属性的读写操作是原子性的，但不保证对象的多线程安全</td></tr><tr><td><code>nonatomic</code></td><td>表明该属性的读写操作是非原子性的，性能强于<code>atomic</code>，因为没有锁的开销</td></tr><tr><td><code>assign</code></td><td>表明 <code>setter</code> 仅仅是一个<strong>简单的赋值操作</strong>，通常用于<strong>基本的数值类型</strong>，例如 <code>CGFloat</code> 和 <code>NSInteger</code></td></tr><tr><td><code>strong</code></td><td>表明属性定义一个<strong>拥有者关系</strong>。当给属性设定一个新值的时候，首先这个值进行 <code>retain</code> ，旧值进行 <code>release</code>，然后进行赋值操作</td></tr><tr><td><code>weak</code></td><td>表明属性定义了一个<strong>非拥有者关系</strong>。当给属性设定一个新值的时候，这个值不会进行 <code>retain</code>，旧值也不会进行 <code>release</code>， 而是进行类似 <code>assign</code> 的操作。不过当属性指向的对象被销毁时，该属性会被<strong>置为nil</strong>。</td></tr><tr><td><code>unsafe_unretained</code></td><td>语义和 <code>assign</code> 类似，不过是<strong>用于对象类型</strong>的，表示一个非拥有(<code>unretained</code>)的，同时也不会在对象被销毁时置为 <code>nil</code> 的(<code>unsafe</code>)关系。</td></tr><tr><td><code>copy</code></td><td>类似于 <code>strong</code>，不过在赋值时进行 <code>copy</code> 操作而不是 <code>retain</code> 操作。通常在需要保留某个不可变对象（ <code>NSString</code> 最常见），并且<strong>防止它被意外改变</strong>时使用。</td></tr></tbody></table><blockquote><p><strong>错误使用属性标识符的后果</strong><br>如果我们给一个原始类型设置 <code>strong\weak\copy</code> ，编译器会直接报错：</p><blockquote><p>Property with ‘retain (or strong)’ attribute must be of object type</p></blockquote><p>设置为 <code>unsafe_unretained</code> 倒是可以通过编译，只是用起来跟 <code>assign</code> 也没有什么区别。<br>反过来，我们给一个 <code>NSObject</code> 属性设置为 assign，编译器会报警：</p><blockquote><p>Assigning retained object to unsafe property; object will be released after assignment</p></blockquote><p>正如警告所说的，对象在赋值之后被立即释放，对应的属性也就成了野指针，运行时跑到属性有关操作会直接崩溃掉。和设置成 <code>unsafe_unretained</code> 是一样的效果（设置成 <code>weak</code> 不会崩溃）。</p><p><strong><code>unsafe_unretained</code> 的用处</strong><br><code>unsafe_unretained</code> 差不多是实际使用最少的一个标识符了，在使用中它的用处主要有下面几点：<br>1.兼容性考虑。<code>iOS4</code> 以及之前还没有引入 <code>weak</code>，这种情况想表达弱引用的语义只能使用 <code>unsafe_unretained</code>。这种情况现在已经很少见了。<br>2.性能考虑。使用 <code>weak</code> 对性能有一些影响，因此对性能要求高的地方可以考虑使用 <code>unsafe_unretained</code> 替换 <code>weak</code>。一个例子是 <a href="https://github.com/ibireme/YYModel/blob/master/YYModel/NSObject%2BYYModel.m" target="_blank" rel="noopener">YYModel 的实现</a>，为了追求更高的性能，其中大量使用 <code>unsafe_unretained</code> 作为变量标识符。</p></blockquote><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reallySetProperty</span><span class="params">(id self, SEL _cmd, id newValue, <span class="keyword">ptrdiff_t</span> offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> copy, <span class="keyword">bool</span> mutableCopy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot = (id*) ((<span class="keyword">char</span>*)self + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>我们把目光转移到 <code>reallySetProperty</code> 中来，这里先判断的 <code>offset</code> 是否为 <code>0</code>。</p><ul><li>如果为 <code>0</code>，直接调用方法 <code>object_setClass</code> 设置当前对象的 <code>class</code>，显然就是设置对象的 <code>isa</code> 指针。</li></ul></li><li><p>声明一个临时变量 <code>oldValue</code>。</p></li><li><p>将 <code>self</code> 先强转为字符串指针，然后进行内存平移得到要设置的属性的内存偏移值，然后将其强转为 <code>id*</code> 类型。</p></li><li><p>判断要设置的属性的标识符是否需要进行 <code>copy</code> 操作</p><ul><li>如果需要，则对传进来的 <code>newValue</code> 也就是要设置的属性值发送 <code>copyWithZone</code> 消息，<strong>这一步的目的是拿到 <code>newValue</code> 的副本，然后覆写 <code>newValue</code>，使得传入的 <code>newValue</code> 之后再发生了改变都不会影响到属性值</strong>。</li></ul></li><li><p>判断要设置的属性的标识符是否需要进行 <code>mutableCopy</code> 操作</p><ul><li>如果需要，则对传进来的 <code>newValue</code> 也就是要设置的属性值发送 <code>mutableCopyWithZone</code> 消息</li></ul></li><li><p>如果要设置的属性既不执行 <code>copy</code> 也不执行 <code>mutableCopy</code>，那么就先判断要设置的值是否相等</p><ul><li>如果相等，说明新值和旧值相等，直接返回</li><li>如果不等，则对新值发送 <code>objc_retain</code> 消息进行 <code>retain</code> 操作，然后将返回值覆写到 <code>newValue</code> 上</li></ul></li><li><p>接着判断属性赋值操作是否是原子操作</p><ul><li>如果不是原子操作，则将属性赋值给临时变量 <code>oldValue</code>，然后将新值赋上去</li><li>如果是原子操作，则对赋值操作进行加锁操作保证数据完整性，防止赋值过程中数据发生变化，这也就印证了 <code>atomic</code> 是保证属性的读写操作线程安全</li><li><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014511.jpg" alt="img"></li></ul></li><li><p>最后对 <code>oldValue</code> 也就是旧值进行内存的释放</p></li></ul><blockquote><p>PS: <strong>并不是所有属性的自动 <code>setter</code> 都会来到 <code>objc_setProperty</code></strong><br><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014515.jpg" alt="img"><br>那么，具体是哪些情况下的属性才会来到这里呢？我们不妨做一下简单的测试</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// JHTest.h</span><br><span class="line">@interface JHTest</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *arrayNonatomicAndStrong;</span><br><span class="line">@property (nonatomic, copy)   NSMutableArray *arrayNonatomicAndCopy;</span><br><span class="line">@property (nonatomic, strong) NSString *stringNonatomicAndStrong;</span><br><span class="line">@property (nonatomic, copy)   NSString *stringNonatomicAndCopy;</span><br><span class="line">@property (nonatomic, assign) int ageNonatomicAndAssign;</span><br><span class="line">@property (nonatomic, weak) NSString *stringNonatomicAndWeak;</span><br><span class="line">@property (nonatomic, retain) NSString *stringNonatomicAndRetain;</span><br><span class="line"></span><br><span class="line">@property (atomic, strong) NSMutableArray *arrayAtomicAndStrong;</span><br><span class="line">@property (atomic, copy)   NSMutableArray *arrayAtomicAndCopy;</span><br><span class="line">@property (atomic, strong) NSString *stringAtomicAndStrong;</span><br><span class="line">@property (atomic, copy)   NSString *stringAtomicAndCopy;</span><br><span class="line">@property (atomic, assign) int ageAtomicAndAssign;</span><br><span class="line">@property (atomic, weak) NSString *stringAtomicAndWeak;</span><br><span class="line">@property (atomic, retain) NSString *stringAtomicAndRetain;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// main.m</span><br><span class="line">JHTest *test = [[JHTest alloc] init];</span><br><span class="line">NSMutableArray *testMutableArray = @[].mutableCopy;</span><br><span class="line">        </span><br><span class="line">test.arrayNonatomicAndStrong = testMutableArray;</span><br><span class="line">test.arrayNonatomicAndCopy = testMutableArray;</span><br><span class="line">test.stringNonatomicAndStrong = @&quot;呵呵哒&quot;;</span><br><span class="line">test.stringNonatomicAndCopy = @&quot;呵呵哒&quot;;</span><br><span class="line">test.ageNonatomicAndAssign = 18;</span><br><span class="line">test.stringNonatomicAndWeak = @&quot;呵呵哒&quot;;  </span><br><span class="line">test.stringNonatomicAndRetain = @&quot;呵呵哒&quot;; </span><br><span class="line"></span><br><span class="line">test.arrayAtomicAndStrong = testMutableArray;</span><br><span class="line">test.arrayAtomicAndCopy = testMutableArray;</span><br><span class="line">test.stringAtomicAndStrong = @&quot;呵呵哒&quot;;</span><br><span class="line">test.stringAtomicAndCopy = @&quot;呵呵哒&quot;;</span><br><span class="line">test.ageAtomicAndAssign = 18; </span><br><span class="line">test.stringAtomicAndWeak = @&quot;呵呵哒&quot;;  </span><br><span class="line">test.stringAtomicAndRetain = @&quot;呵呵哒&quot;;</span><br></pre></td></tr></table></figure><p>我们通过断点调试，每执行到一个属性的时候，看断点是否会来到 <code>reallySetProperty</code>，测试结果如下:</p><table><thead><tr><th>属性</th><th>是否进入<code>reallySetProperty</code></th></tr></thead><tbody><tr><td>arrayNonatomicAndStrong</td><td>否</td></tr><tr><td>arrayNonatomicAndCopy</td><td>是</td></tr><tr><td>stringNonatomicAndStrong</td><td>否</td></tr><tr><td>stringNonatomicAndCopy</td><td>是</td></tr><tr><td>ageNonatomicAndAssign</td><td>否</td></tr><tr><td>stringNonatomicAndWeak</td><td>否</td></tr><tr><td>stringNonatomicAndRetain</td><td>否</td></tr></tbody></table><table><thead><tr><th>属性</th><th>是否进入<code>reallySetProperty</code></th></tr></thead><tbody><tr><td>arrayAtomicAndStrong</td><td>是</td></tr><tr><td>arrayAtomicAndCopy</td><td>是</td></tr><tr><td>stringAtomicAndStrong</td><td>是</td></tr><tr><td>stringAtomicAndCopy</td><td>是</td></tr><tr><td>ageAtomicAndAssign</td><td>否</td></tr><tr><td>stringAtomicAndWeak</td><td>否</td></tr><tr><td>stringAtomicAndRetain</td><td>是</td></tr></tbody></table><p>从这两组测试结果不难看出，因为 <code>reallySetProperty</code> 内部实际上进行了原子性的写操作以及 <code>copy</code> 或 <code>mutableCopy</code> 的操作和 <code>retain</code> 操作，而对于属性标识符为 <code>nonatomic</code> 并且非 <code>copy</code> 的属性来说，其实并不需要进行原子操作以及 <code>copy</code> 或 <code>mutableCopy</code> 操作。<br>我们前面所展示的属性标识符对应作用的内容在这里也印证了只有当属性需要进行 <code>copy</code> 或 <code>mutableCopy</code> 操作或原子操作时或 <code>retain</code> 操作才会被编译器优化来到 <code>objc_setProperty_xxx =&gt; reallySetProperty</code> 的流程。换句话说，在 <code>Clang</code> 编译的时候，编译器肯定会对属性进行判断，对有需要的属性才触发这一流程。</p><p>我们用一个表格来总结：</p><table><thead><tr><th>底层方法</th><th>对应属性标识符</th></tr></thead><tbody><tr><td>objc_setProperty_nonatomic_copy</td><td>nonatomic + copy</td></tr><tr><td>objc_setProperty_atomic_copy</td><td>atomic + copy</td></tr><tr><td>objc_setProperty_atomic</td><td>atomic + retain/strong</td></tr></tbody></table><hr><p>我们分析完 <code>reallySetProperty</code> 后不禁有一个疑问，那就是系统是在哪一步调用了 <code>objc_setProperty_xxx</code> 之类的方法呢？答案就是 <code>LLVM</code>。我们可以在 <code>LLVM</code> 的源码中进行搜索关键字 <code>objc_setProperty</code>：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014519.jpg" alt="img"></p><p>我们可以看到在 <code>clang</code> 编译器前端的 <code>RewriteModernObjC</code> 命名空间下的 <code>RewritePropertyImplDecl</code> 方法中：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014523.jpg" alt="img"></p><p>然后我们在 <code>CodeGen</code> 目录下的匿名命名空间下的 <code>ObjcCommonTypesHelper</code> 的 <code>getOptimizedSetPropertyFn</code> 处可以看到以下代码：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014527.jpg" alt="img"></p><p>我们接着以 <code>getOptimizedSetPropertyFn</code> 为关键字来搜索：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">llvm::<span class="function">FunctionCallee <span class="title">GetOptimizedPropertySetFunction</span><span class="params">(<span class="keyword">bool</span> atomic,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">bool</span> copy)</span> override </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ObjCTypes.getOptimizedSetPropertyFn(atomic, copy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们搜索 <code>GetOptimizedPropertySetFunction</code>：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014536.jpg" alt="img"></p><p>关于 <code>LLVM</code> 这块我们先探索到这里，接下来让我们回顾一下 <code>KVC</code> 常用的几种使用场景。</p><h1 id="二、深入-KVC"><a href="#二、深入-KVC" class="headerlink" title="二、深入 KVC"></a>二、深入 KVC</h1><h2 id="2-1-访问对象属性"><a href="#2-1-访问对象属性" class="headerlink" title="2.1 访问对象属性"></a>2.1 访问对象属性</h2><ol><li>通过 <code>valueForKey:</code> 和 <code>setValue:ForKey:</code> 来<strong>间接的</strong>获取和设置属性值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JHPerson *person = [[JHPerson alloc] init];</span><br><span class="line">[person setValue:@&quot;leejunhui&quot; forKey:@&quot;name&quot;];</span><br><span class="line">NSLog(@&quot;person 的姓名为: %@&quot;, [person valueForKey:@&quot;name&quot;]);</span><br><span class="line"></span><br><span class="line">// 打印如下</span><br><span class="line">person 的姓名为: leejunhui</span><br></pre></td></tr></table></figure><blockquote><ul><li><p><code>valueForKey</code>: - Returns the value of a property named by the key parameter. If the property named by the key cannot be found according to the rules described in <strong>Accessor Search Patterns</strong>, then the object sends itself a valueForUndefinedKey: message. The default implementation of valueForUndefinedKey: raises an NSUndefinedKeyException, but subclasses may override this behavior and handle the situation more gracefully.<br>【译】<code>valueForKey</code>: 返回由 <code>key</code> 参数命名的属性的值。如果根据<strong>访问者搜索模式</strong>中描述的规则找不到由 <code>key</code> 命名的属性，则该对象将向自身发送 <code>valueForUndefinedKey:</code> 消息。<code>valueForUndefinedKey:</code>的默认实现会抛出 <code>NSUndefinedKeyException</code> 异常，但是子类可以重写此行为并更优雅地处理这种情况。</p></li><li><p><code>setValue:forKey:</code>: Sets the value of the specified key relative to the object receiving the message to the given value. The default implementation of setValue:forKey: automatically unwraps NSNumber and NSValue objects that represent scalars and structs and assigns them to the property. See Representing Non-Object Values for details on the wrapping and unwrapping semantics.<br>If the specified key corresponds to a property that the object receiving the setter call does not have, the object sends itself a setValue:forUndefinedKey: message. The default implementation of setValue:forUndefinedKey: raises an NSUndefinedKeyException. However, subclasses may override this method to handle the request in a custom manner.<br>【译】<code>setValue:forKey:</code>: 将该消息接收者的指定 <code>key</code> 的值设置为给定值。默认实现会自动把表示标量和结构体的 <code>NSNumber</code> 和 <code>NSValue</code> 对象解包然后赋值给属性。如果指定 <code>key</code> 所对应的属性没有对应的 <code>setter</code> 实现，则该对象将向自身发送 <code>setValue:forUndefinedKey:</code> 消息，而该消息的默认实现会抛出一个 <code>NSUndefinedKeyException</code> 的异常。但是子类可以重写此方法以自定义方式处理请求。</p></li></ul></blockquote><p>2.<code>valueForKeyPath:</code> 和 <code>setValue:ForKeyPath:</code><br><strong>Storyboard 或 xib 中使用 KVC</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014545.jpg" alt="img"></p><p>如上图所示，<code>Storyboard</code> 中的一个视图的属性菜单可以设置该视图的 <code>Key Path</code> ，这就引出了基于<strong>路由</strong>的另外一种 <code>KVC</code> 方式，那就是 <code>valueForKeyPath:</code> 和 <code>setValue:ForKeyPath:</code></p><blockquote><p>A key path is a string of dot-separated keys used to specify a sequence of object properties to traverse. The property of the first key in the sequence is relative to the receiver, and each subsequent key is evaluated relative to the value of the previous property. Key paths are useful for drilling down into a hierarchy of objects with a single method call.<br>【译】<code>keypath</code> 是一个以点分隔开来的字符串，表示了要遍历的对象属性序列。序列中第一个 <code>key</code> 相对于接受者，而后续的每个 <code>key</code> 都与前一级 <code>key</code> 相关联。<code>keypath</code> 对于单个方法调用来深入对象内部结构来说很有用。</p></blockquote><p>通过 <code>layer.cornerRadius</code> 这个 <code>Key Path</code>，实现了对左侧 <code>View</code> 的 <code>layer</code> 属性的 <code>cornerRadius</code> 属性的访问。</p><blockquote><ul><li><code>valueForKeyPath:</code> - Returns the value for the specified key path relative to the receiver. Any object in the key path sequence that is not key-value coding compliant for a particular key—that is, for which the default implementation of valueForKey: cannot find an accessor method—receives a valueForUndefinedKey: message.</li></ul><p>【译】<code>valueForKeyPath:</code> : 返回相对于接受者的指定 <code>key path</code> 上的值。<code>key path</code> 路径序列中不符合特定键的键值编码的任何对象（即 <code>valueForKey:</code> 的默认实现无法找到访问器方法的对象）都会接收到 <code>valueForUndefinedKey:</code> 消息。</p><ul><li><code>setValue:forKeyPath:</code> - Sets the given value at the specified key path relative to the receiver. Any object in the key path sequence that is not key-value coding compliant for a particular key receives a setValue:forUndefinedKey: message.</li></ul><p>【译】<code>setValue:forKeyPath:</code>: 将该消息接收者的指定 <code>key path</code> 的值设置为给定值。<code>key path</code> 路径序列中不符合特定键的键值编码的任何对象都将收到<code>setValue:forUndefinedKey:</code> 消息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// JHPerson.h</span><br><span class="line">@property (nonatomic, strong) JHAccount *account;</span><br><span class="line"></span><br><span class="line">// JHAccount.h</span><br><span class="line">@property (nonatomic, copy) NSString *balance;</span><br><span class="line"></span><br><span class="line">// main.m</span><br><span class="line">person.account = [[JHAccount alloc] init];</span><br><span class="line">[person setValue:@&quot;666&quot; forKeyPath:@&quot;account.balance&quot;];</span><br><span class="line">NSLog(@&quot;person 的账户余额为: %@&quot;, [person valueForKeyPath:@&quot;account.balance&quot;]);</span><br><span class="line"></span><br><span class="line">// 打印输出</span><br><span class="line">person 的账户余额为: 666</span><br></pre></td></tr></table></figure><p>3.<code>dictionaryWithValuesForKeys:</code> 和 <code>setValuesForKeysWithDictionary:</code></p><blockquote><ul><li><code>dictionaryWithValuesForKeys:</code> - Returns the values for an array of keys relative to the receiver. The method calls valueForKey: for each key in the array. The returned NSDictionary contains values for all the keys in the array.</li></ul><p>【译】返回相对于接收者的 <code>key</code> 数组的值。该方法会为数组中的每个 <code>key</code> 调用<code>valueForKey:</code>。 返回的 <code>NSDictionary</code> 包含数组中所有键的值。</p><ul><li><code>setValuesForKeysWithDictionary:</code> - Sets the properties of the receiver with the values in the specified dictionary, using the dictionary keys to identify the properties. The default implementation invokes setValue:forKey: for each key-value pair, substituting nil for NSNull objects as required.</li></ul><p>【译】使用字典键标识属性，然后使用字典中的对应值来设置该消息接收者的属性值。默认实现会对每一个键值对调用 <code>setValue:forKey:</code>。设置时需要将 <code>nil</code> 替换成 <code>NSNull</code>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[person setValuesForKeysWithDictionary:@&#123;@&quot;name&quot;: @&quot;junhui&quot;, @&quot;age&quot;: @(18)&#125;];</span><br><span class="line">NSLog(@&quot;%@&quot;, [person dictionaryWithValuesForKeys:@[@&quot;name&quot;, @&quot;age&quot;]]);       </span><br><span class="line">        </span><br><span class="line"> // 打印输出</span><br><span class="line">&#123;</span><br><span class="line">    age = 18;</span><br><span class="line">    name = junhui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Collection objects, such as NSArray, NSSet, and NSDictionary, can’t contain nil as a value. Instead, you represent nil values using the NSNull object. NSNull provides a single instance that represents the nil value for object properties. The default implementations of dictionaryWithValuesForKeys: and the related setValuesForKeysWithDictionary: translate between NSNull (in the dictionary parameter) and nil (in the stored property) automatically.<br>集合对象（例如 <code>NSArray</code>，<code>NSSet</code> 和 <code>NSDictionary</code>）不能包含 <code>nil</code> 作为值。 而是使用 <code>NSNull</code> 对象表示 <code>nil</code> 值。<code>NSNull</code> 提供了单个实例表示对象属性的nil值。<code>dictionaryWithValuesForKeys:</code> 和 <code>setValuesForKeysWithDictionary:</code> 的默认实现会自动在 <code>NSNull</code>（在 <code>dictionary</code> 参数中）和 <code>nil</code>（在存储的属性中）之间转换。<br><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215014549.jpg" alt="img"></p></blockquote><h2 id="2-2-访问集合属性"><a href="#2-2-访问集合属性" class="headerlink" title="2.2 访问集合属性"></a>2.2 访问集合属性</h2><p>我们先看下面这样的一份代码，首先给 <code>JHPerson</code> 类增加一个属性 <code>array</code>，类型为不可变数组，然后修改这个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// JHPerson.h</span><br><span class="line">@property (nonatomic, strong) NSArray *array;</span><br><span class="line"></span><br><span class="line">// main.m</span><br><span class="line">person.array = @[@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;];</span><br><span class="line">NSArray *tempArray = @[@&quot;0&quot;, @&quot;1&quot;, @&quot;2&quot;];</span><br><span class="line">[person setValue:tempArray forKey:@&quot;array&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;, [person valueForKeyPath:@&quot;array&quot;]);        </span><br><span class="line"></span><br><span class="line">// 打印输出</span><br><span class="line">(</span><br><span class="line">    0,</span><br><span class="line">    1,</span><br><span class="line">    2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>虽然这种方式能达到效果，但其实还有一种更好的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// main.m</span><br><span class="line">NSMutableArray *mutableArray = [person mutableArrayValueForKey:@&quot;array&quot;];</span><br><span class="line">mutableArray[0] = @&quot;-1&quot;;</span><br><span class="line">NSLog(@&quot;%@&quot;, [person valueForKeyPath:@&quot;array&quot;]);</span><br><span class="line"></span><br><span class="line">// 打印输出</span><br><span class="line"> (</span><br><span class="line">    &quot;-1&quot;,</span><br><span class="line">    1,</span><br><span class="line">    2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里我们用到了一个叫做 <code>mutableArrayValueForKey:</code> 的实例方法，这个方法会通过传入的 <code>key</code> 返回对应属性的一个可变数组的代理对象。</p><p>其实对集合对象来说，我们使用上一节的各种读取和设置方法都可以，但是对于操作集合对象内部的元素来说，更高效的方式是使用 <code>KVC</code> 提供的<strong>可变代理方法</strong>。<code>KVC</code> 为我们提供了三种不同的可变代理方法：</p><ul><li><code>mutableArrayValueForKey:</code> 和 <code>mutableArrayValueForKeyPath:</code><ul><li>These return a proxy object that behaves like an NSMutableArray object.</li><li>【译】返回的代理对象表现为一个 <code>NSMutableArray</code> 对象</li></ul></li><li><code>mutableSetValueForKey:</code> 和 <code>mutableSetValueForKeyPath:</code><ul><li>These return a proxy object that behaves like an NSMutableSet object.</li><li>【译】返回的代理对象表现为一个 <code>NSMutableSet</code> 对象</li></ul></li><li><code>mutableOrderedSetValueForKey:</code> and <code>mutableOrderedSetValueForKeyPath:</code><ul><li>These return a proxy object that behaves like an NSMutableOrderedSet object.</li><li>【译】返回的代理对象表现为一个 <code>NSMutableOrderedSet</code> 对象</li></ul></li></ul><h2 id="2-3-集合运算符"><a href="#2-3-集合运算符" class="headerlink" title="2.3 集合运算符"></a>2.3 集合运算符</h2><p>在使用 <code>valueForKeyPath:</code> 的时候，可以使用集合运算符来实现一些高效的运算操作。</p><blockquote><p>A collection operator is one of a small list of keywords preceded by an at sign (@) that specifies an operation that the getter should perform to manipulate the data in some way before returning it.<br>【译】一个集合运算符是一小部分关键字其后带有一个at符号（@），该符号指定 <code>getter</code> 在返回数据之前以某种方式处理数据应执行的操作。</p></blockquote><p>集合运算符的结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015436.jpg" alt="img"></p><p>简单解释一下:</p><ul><li>left key path: 指向的要进行运算的集合，如果是直接给集合发送的 <code>valueForKeyPath:</code> 消息，<code>left key path</code> 可以省略</li><li>right key path: 表示的是对集合中具体哪个属性进行运算操作，除了 <code>@count</code> 运算符外，所有的集合运算符的 <code>right key path</code> 都不能省略</li></ul><p>而集合运算符可以分为三大类：</p><ul><li>聚合操作符<ul><li><code>@avg</code>: 返回操作对象指定属性的<strong>平均值</strong></li><li><code>@count</code>: 返回操作对象指定<strong>属性的个数</strong></li><li><code>@max</code>: 返回操作对象指定属性的<strong>最大值</strong></li><li><code>@min</code>: 返回操作对象指定属性的<strong>最小值</strong></li><li><code>@sum</code>: 返回操作对象指定<strong>属性值之和</strong></li></ul></li><li>数组操作符<ul><li><code>@distinctUnionOfObjects</code>: 返回操作对象<strong>指定属性的集合–去重</strong> </li><li><code>@unionOfObjects</code>: 返回操作对象<strong>指定属性的集合</strong></li></ul></li><li>嵌套操作符<ul><li><code>@distinctUnionOfArrays</code>: 返回操作对象(嵌套集合)<strong>指定属性的集合–去重</strong>，返回的是 <code>NSArray</code></li><li><code>@unionOfArrays</code>: 返回操作对象(集合)<strong>指定属性的集合</strong></li><li><code>@distinctUnionOfSets</code>: 返回操作对象(嵌套集合)<strong>指定属性的集合–去重</strong>，返回的是 <code>NSSet</code></li></ul></li></ul><h2 id="2-4-访问非对象属性"><a href="#2-4-访问非对象属性" class="headerlink" title="2.4 访问非对象属性"></a>2.4 访问非对象属性</h2><p>非对象属性分为两类，一类是基本数据类型也就是所谓的<strong>标量</strong>(scalar)，一类是结构体(struct)。</p><h3 id="2-4-1-访问标量属性"><a href="#2-4-1-访问标量属性" class="headerlink" title="2.4.1 访问标量属性"></a>2.4.1 访问标量属性</h3><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015453.jpg" alt="img"></p><p>如图所示，常用的基本数据类型需要在设置属性的时候包装成 <code>NSNumber</code> 类型，然后在读取值的时候使用各自对应的读取方法，如 <code>double</code> 类型的标量读取的时候使用 <code>doubleValue</code></p><h3 id="2-4-2-访问结构体"><a href="#2-4-2-访问结构体" class="headerlink" title="2.4.2 访问结构体"></a>2.4.2 访问结构体</h3><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015441.jpg" alt="img"></p><p>结构体的话就需要转换成 <code>NSValue</code> 类型，如上图所示。<br>除了 <code>NSPoint</code>, <code>NSRange</code>, <code>NSRect</code>, 和 <code>NSSize</code>，对于自定义的结构体，也需要进行 <code>NSValue</code> 的转换操作，举个🌰:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    float x, y, z;</span><br><span class="line">&#125; ThreeFloats;</span><br><span class="line"> </span><br><span class="line">@interface MyClass</span><br><span class="line">@property (nonatomic) ThreeFloats threeFloats;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 获取结构体属性</span><br><span class="line">NSValue* result = [myClass valueForKey:@&quot;threeFloats&quot;];</span><br><span class="line"></span><br><span class="line">// 设置结构体属性</span><br><span class="line">ThreeFloats floats = &#123;1., 2., 3.&#125;;</span><br><span class="line">NSValue* value = [NSValue valueWithBytes:&amp;floats objCType:@encode(ThreeFloats)];</span><br><span class="line">[myClass setValue:value forKey:@&quot;threeFloats&quot;];</span><br><span class="line"></span><br><span class="line">// 提取结构体属性</span><br><span class="line">ThreeFloats th;</span><br><span class="line">[reslut getValue:&amp;th];</span><br></pre></td></tr></table></figure><h2 id="2-5-属性验证"><a href="#2-5-属性验证" class="headerlink" title="2.5 属性验证"></a>2.5 属性验证</h2><p><code>KVC</code> 支持属性验证，而这一特性是通过<code>validateValue:forKey:error:</code> (或<code>validateValue:forKeyPath:error:</code>) 方法来实现的。这个验证方法的默认实现是去收到这个验证消息的对象(或<code>keyPath</code>中最后的对象)中根据 <code>key</code> 查找是否有对应的 <code>validate&lt;Key&gt;:error:</code> 方法实现，如果没有，验证默认成功，返回 <code>YES</code>。<br>而由于 <code>validate&lt;Key&gt;:error:</code> 方法通过引用接收值和错误参数，所以会有以下三种结果：</p><ul><li>验证成功，返回 <code>YES</code>，对属性值不做任何改动。</li><li>验证失败，返回 <code>NO</code>，但对属性值不做改动，如果调用者提供了 <code>NSError</code> 的话，就把错误引用设置为指示错误原因的NSError对象。</li><li>验证失败，返回 <code>YES</code>，创建一个新的，有效的属性值作为替代。在返回之前，该方法将值引用修改为指向新值对象。 进行修改时，即使值对象是可变的，该方法也总是创建一个新对象，而不是修改旧对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person* person = [[Person alloc] init];</span><br><span class="line">NSError* error;</span><br><span class="line">NSString* name = @&quot;John&quot;;</span><br><span class="line">if (![person validateValue:&amp;name forKey:@&quot;name&quot; error:&amp;error]) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么是否系统会自动进行属性验证呢？<br>通常，<code>KVC</code> 或其默认实现均未定义任何机制来自动的执行属性验证，也就是说需要在适合你的应用的时候自己提供属性验证方法。<br>某些其他 <code>Cocoa</code> 技术在某些情况下会自动执行验证。 例如，保存 <code>managed object context</code> 时，<code>Core Data</code>会自动执行验证。另外，在 <code>macOS</code> 中，<code>Cocoa Binding</code>允许你指定验证应自动进行。</p><h2 id="2-6-KVC-取值和设值原理"><a href="#2-6-KVC-取值和设值原理" class="headerlink" title="2.6 KVC 取值和设值原理"></a>2.6 <code>KVC</code> 取值和设值原理</h2><h3 id="2-6-1-基本-getter"><a href="#2-6-1-基本-getter" class="headerlink" title="2.6.1 基本 getter"></a>2.6.1 基本 <code>getter</code></h3><p><code>valueForKey:</code> 方法会在调用者传入 <code>key</code> 之后会在对象中按下列的步骤进行模式搜索：</p><ul><li>1.以 <code>get&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code> 以及 <code>_&lt;key&gt;</code> 的顺序查找对象中是否有对应的方法。<ul><li>如果找到了，将方法返回值带上跳转到第 5 步</li><li>如果没有找到，跳转到第 2 步</li></ul></li><li>2.查找是否有 <code>countOf&lt;Key&gt;</code> 和 <code>objectIn&lt;Key&gt;AtIndex:</code> 方法(对应于 <code>NSArray</code> 类定义的原始方法)以及 <code>&lt;key&gt;AtIndexes:</code> 方法(对应于 <code>NSArray</code> 方法 <code>objectsAtIndexes:</code>)<ul><li>如果找到其中的第一个(<code>countOf&lt;Key&gt;</code>)，再找到其他两个中的至少一个，则创建一个响应所有 <code>NSArray</code> 方法的代理集合对象，并返回该对象。(翻译过来就是要么是 <code>countOf&lt;Key&gt;</code> + <code>objectIn&lt;Key&gt;AtIndex:</code>，要么是 <code>countOf&lt;Key&gt;</code> + <code>&lt;key&gt;AtIndexes:</code>，要么是 <code>countOf&lt;Key&gt;</code> + <code>objectIn&lt;Key&gt;AtIndex:</code> + <code>&lt;key&gt;AtIndexes:</code>)</li><li>如果没有找到，跳转到第 3 步</li></ul></li><li>3.查找名为 <code>countOf&lt;Key&gt;</code>，<code>enumeratorOf&lt;Key&gt;</code> 和 <code>memberOf&lt;Key&gt;</code> 这三个方法(对应于NSSet类定义的原始方法）<ul><li>如果找到这三个方法，则创建一个响应所有 <code>NSSet</code> 方法的代理集合对象，并返回该对象</li><li>如果没有找到，跳转到第 4 步</li></ul></li><li>4.判断类方法 <code>accessInstanceVariablesDirectly</code> 结果<ul><li>如果返回 <code>YES</code>，则以 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code> 的顺序查找成员变量，如果找到了，将成员变量带上跳转到第 5 步，如果没有找到则跳转到第 6 步</li><li>如果返回 <code>NO</code>，跳转到第 6 步</li></ul></li><li>5.判断取出的属性值<ul><li>如果属性值是对象，直接返回</li><li>如果属性值不是对象，但是可以转化为 <code>NSNumber</code> 类型，则将属性值转化为 <code>NSNumber</code> 类型返回</li><li>如果属性值不是对象，也不能转化为 <code>NSNumber</code> 类型，则将属性值转化为 <code>NSValue</code> 类型返回</li></ul></li><li>6.调用 <code>valueForUndefinedKey:</code>。 默认情况下，这会引发一个异常，但是 <code>NSObject</code> 的子类可以提供特定于 <code>key</code> 的行为。</li></ul><p>这里可以用简单的流程图来表示</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015445.jpg" alt="img"></p><h3 id="2-6-2-基本-setter"><a href="#2-6-2-基本-setter" class="headerlink" title="2.6.2 基本 setter"></a>2.6.2 基本 <code>setter</code></h3><p><code>setValue:forKey:</code> 方法默认实现会在调用者传入 <code>key</code> 和 <code>value</code>(如果是非对象类型，则指的是解包之后的值) 之后会在对象中按下列的步骤进行模式搜索：</p><ul><li>1.以 <code>set&lt;Key&gt;:</code>, <code>_set&lt;Key&gt;</code> 的顺序在对象中查找是否有这样的方法，如果找到了，则把属性值传给方法来完成属性值的设置。</li><li>2.判断类方法 <code>accessInstanceVariablesDirectly</code> 结果<ul><li>如果返回 <code>YES</code>，则以 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code> 的顺序查找成员变量，如果找到了，则把属性值传给方法来完成属性值的设置。</li><li>如果返回 <code>NO</code>，跳转到第 3 步</li></ul></li><li>3.调用 <code>setValue：forUndefinedKey:</code>。 默认情况下，这会引发一个异常，但是<code>NSObject</code> 的子类可以提供特定于 <code>key</code> 的行为。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015449.jpg" alt="img"></p><h1 id="三、自定义-KVC"><a href="#三、自定义-KVC" class="headerlink" title="三、自定义 KVC"></a>三、自定义 <code>KVC</code></h1><p>了解了 <code>KVC</code> 底层原理之后，我们是否可以自己来实现一下 <code>KVC</code> 呢？这里我们要先明确一下 <code>iOS</code> 中对于属性的分类：</p><ul><li><strong>Attributes</strong>: 简单属性，比如基本数据类型，字符串和布尔值，而诸如 <code>NSNumber</code> 和其它一些不可变类型比如 <code>NSColor</code> 也可以被认为是简单属性</li><li><strong>To-one relationships</strong>: 这些是具有自己属性的可变对象属性。即对象的属性可以更改，而无需更改对象本身。例如，一个 <code>Account</code> 对象可能具有一个 <code>owner</code> 属性，该属性是 <code>Person</code> 对象的实例，而 <code>Person</code> 对象本身具有 <code>address</code> 属性。<code>owner</code> 的地址可以更改，但却而无需更改 <code>Account</code> 持有的 <code>owner</code> 属性。也就是说 <code>Account</code> 的 <code>owner</code> 属性未被更改，只是 <code>address</code> 被更改了。</li><li><strong>To-many relationships</strong>: 这些是集合对象属性。尽管也可以使用自定义集合类，但是通常使用 <code>NSArray</code> 或 <code>NSSet</code> 的实例来持有此集合。</li></ul><p>我们通过代码来演示上述三种类型的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Person.h</span><br><span class="line">@interface Person</span><br><span class="line">@property (nonatomic, copy) NSString *name; // Attributes </span><br><span class="line">@property (nonatomic, strong) Account *account; // To-one relationships</span><br><span class="line">@property (nonatomic, strong) NSArray *subjects; // To-many relationships</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Account.h</span><br><span class="line">@interface Account</span><br><span class="line">@property (nonatomic, assign) NSInteger balance; </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>我们实现聚焦于最常用的 <code>valueForKey:</code> 方法的声明，我们发现该方法是位于 <code>NSKeyValueCoding</code> 这个分类里面的，这种设计模式可以实现解耦的功能。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200215015438.jpg" alt="img"></p><p>打个比方，我们在实际开发中会在 <code>AppDelegate</code> 源文件里面去做各种诸如第三方组件的注册和初始化，时间久了，随着项目功能不断迭代，堆积在 <code>AppDelegate</code> 中的代码就会越来越多，导致难以维护。这个时候如果采取把这些初始化和注册逻辑放在不同的 <code>AppDelegate</code> 的分类中就可以大大减轻 <code>AppDelegate</code> 自身维护的成本，同时，也让整个业务流更加清晰。</p><h2 id="3-1-自定义设值"><a href="#3-1-自定义设值" class="headerlink" title="3.1 自定义设值"></a>3.1 自定义设值</h2><p>那么，我们如果要自定义 <code>KVC</code> 实现的话，也应该按照这种设计模式来操作。我们直接新建一个 <code>NSObject</code> 的分类，然后我们先着眼于 <code>setValue:ForKey:</code> 方法，为了避免与系统自带的 <code>KVC</code> 方法冲突，我们加一个前缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// NSObject+JHKVC.h</span><br><span class="line">@interface NSObject (JHKVC)</span><br><span class="line">- (void)jh_setValue:(nullable id)value forKey:(NSString *)key;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>然后要实现这个方法，根据我们前面探索的 <code>setValue:ForKey:</code> 流程，我们判断一下传入的 <code>key</code> 是否为空:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 1.判断 key</span><br><span class="line">if (key == nil  || key.length == 0) return;</span><br></pre></td></tr></table></figure><ul><li>如果 <code>key</code> 为 <code>nil</code> 或者 <code>key</code> 长度为 0 ，直接退出。</li></ul><p>接着我们要判断是否存在 <code>setKey</code>，<code>_setKey</code>，这里有个小插曲，因为苹果官方文档上只说了这两种方法，但其实，<code>iOS</code> 底层还处理了 <code>setIsKey</code>，这是因为 <code>key</code> 可以被重写成 <code>isKey</code> 的形式，所以这里我们就再加上对 <code>setIsKey</code> 的判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 2.判断 setKey,_setKey,setIsKey 是否存在，如果存在，直接调用相应的方法来设置属性值</span><br><span class="line">NSString *Key = key.capitalizedString;</span><br><span class="line">NSString *setKey = [NSString stringWithFormat:@&quot;set%@:&quot;,Key];</span><br><span class="line">NSString *_setKey = [NSString stringWithFormat:@&quot;_set%@:&quot;,Key];</span><br><span class="line">NSString *setIsKey = [NSString stringWithFormat:@&quot;setIs%@:&quot;,Key];</span><br><span class="line"></span><br><span class="line">if ([self jh_performSelectorWithMethodName:setKey value:value]) &#123;</span><br><span class="line">    NSLog(@&quot;*********%@**********&quot;,setKey);</span><br><span class="line">    return;</span><br><span class="line">&#125;else if ([self jh_performSelectorWithMethodName:_setKey value:value]) &#123;</span><br><span class="line">    NSLog(@&quot;*********%@**********&quot;,_setKey);</span><br><span class="line">    return;</span><br><span class="line">&#125;else if ([self jh_performSelectorWithMethodName:setIsKey value:value]) &#123;</span><br><span class="line">    NSLog(@&quot;*********%@**********&quot;,setIsKey);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里为了方便，先将 <code>key</code> 进行一下首字母大写化，然后拼接三个不同的 <code>set</code> 方法名，然后判断响应的方法能否实现，如果实现了就直接调用响应的方法来设置属性值</li></ul><blockquote><p>这里先通过 <code>respondsToSelector</code> 来判断当前对象是否能响应传入的方法，如果能响应，则执行方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; - (BOOL)jh_performSelectorWithMethodName:(NSString *)methodName value:(id)value&#123;</span><br><span class="line">&gt;  </span><br><span class="line">&gt;     if ([self respondsToSelector:NSSelectorFromString(methodName)]) &#123;</span><br><span class="line">&gt;         </span><br><span class="line">&gt; #pragma clang diagnostic push</span><br><span class="line">&gt; #pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">&gt;         [self performSelector:NSSelectorFromString(methodName) withObject:value];</span><br><span class="line">&gt; #pragma clang diagnostic pop</span><br><span class="line">&gt;         return YES;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     return NO;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这里如果按照系统的 <code>KVC</code> 设值流程，应该还有对 <code>NSArray</code>，<code>NSSet</code> 之类的处理，为了简化，就暂时忽略掉这些流程。我们直接往下面走，下一个流程应该就是判断类方法 <code>accessInstanceVariablesDirectly</code> 了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 3.判断是否能直接读取成员变量</span><br><span class="line">if (![self.class accessInstanceVariablesDirectly] ) &#123;</span><br><span class="line">    @throw [NSException exceptionWithName:@&quot;JHUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;,self] userInfo:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果可以读取成员变量，那么就需要我们按照 <code>_key</code>，<code>_isKey</code>, <code>key</code>, <code>isKey</code> 的顺序去查找了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 4.按照 _key,is_key,key,isKey 顺序查询实例变量</span><br><span class="line">NSMutableArray *mArray = [self getIvarListName];</span><br><span class="line">NSString *_key = [NSString stringWithFormat:@&quot;_%@&quot;,key];</span><br><span class="line">NSString *_isKey = [NSString stringWithFormat:@&quot;_is%@&quot;,Key];</span><br><span class="line">NSString *isKey = [NSString stringWithFormat:@&quot;is%@&quot;,Key];</span><br><span class="line">if ([mArray containsObject:_key]) &#123;</span><br><span class="line">    // 4.2 获取相应的 ivar</span><br><span class="line">   Ivar ivar = class_getInstanceVariable([self class], _key.UTF8String);</span><br><span class="line">    // 4.3 对相应的 ivar 设置值</span><br><span class="line">   object_setIvar(self , ivar, value);</span><br><span class="line">   return;</span><br><span class="line">&#125;else if ([mArray containsObject:_isKey]) &#123;</span><br><span class="line">   Ivar ivar = class_getInstanceVariable([self class], _isKey.UTF8String);</span><br><span class="line">   object_setIvar(self , ivar, value);</span><br><span class="line">   return;</span><br><span class="line">&#125;else if ([mArray containsObject:key]) &#123;</span><br><span class="line">   Ivar ivar = class_getInstanceVariable([self class], key.UTF8String);</span><br><span class="line">   object_setIvar(self , ivar, value);</span><br><span class="line">   return;</span><br><span class="line">&#125;else if ([mArray containsObject:isKey]) &#123;</span><br><span class="line">   Ivar ivar = class_getInstanceVariable([self class], isKey.UTF8String);</span><br><span class="line">   object_setIvar(self , ivar, value);</span><br><span class="line">   return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里要先读取到当前对象上所有的实例变量，然后匹配四种情况</li></ul><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; - (NSMutableArray *)getIvarListName&#123;</span><br><span class="line">&gt;     // 初始化数组容器</span><br><span class="line">&gt;     NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">&gt;     unsigned int count = 0;</span><br><span class="line">&gt;     // 获取到当前类的成员变量</span><br><span class="line">&gt;     Ivar *ivars = class_copyIvarList([self class], &amp;count);</span><br><span class="line">&gt;     // 遍历所有的成员变量</span><br><span class="line">&gt;     for (int i = 0; i&lt;count; i++) &#123;</span><br><span class="line">&gt;         Ivar ivar = ivars[i];</span><br><span class="line">&gt;         const char *ivarNameChar = ivar_getName(ivar);</span><br><span class="line">&gt;         // 将静态字符串指针转换为 NSString 类型  </span><br><span class="line">&gt;         NSString *ivarName = [NSString stringWithUTF8String:ivarNameChar];</span><br><span class="line">&gt;         NSLog(@&quot;ivarName == %@&quot;,ivarName);</span><br><span class="line">&gt;         [mArray addObject:ivarName];</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     // 释放掉成员变量指针数组</span><br><span class="line">&gt;     free(ivars);</span><br><span class="line">&gt;     return mArray;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>这里用到了 <code>Runtime</code> 的两个 <code>api</code>，<code>class_copyIvarList</code> 和 <code>ivar_getName</code></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; Ivar  _Nonnull * class_copyIvarList(Class cls, unsigned int *outCount);</span><br><span class="line">&gt; ``` </span><br><span class="line">&gt; 返回类结构中成员变量的指针数组，但是不包括父类中声明的成员变量。该数组包含 `*outCount`指针，后跟一个 `NULL` 终止符。使用完毕后您必须使用 `free()` 释放成员变量的指针数组。如果该类未声明任何实例变量，或者 `cls` 为Nil，则返回 `NULL`，并且 `*outCount` 为 0。</span><br><span class="line">&gt; </span><br><span class="line">&gt; ```Objective-C</span><br><span class="line">&gt; const char * ivar_getName(Ivar v);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>返回成员变量的名称</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 5.如果前面的流程都失败了，则抛出异常</span><br><span class="line">@throw [NSException exceptionWithName:@&quot;JHUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ %@]: setValue:forUndefinedKey:%@.****&quot;,self,NSStringFromSelector(_cmd),key] userInfo:nil];</span><br></pre></td></tr></table></figure><ul><li>最后抛出 <code>setValue:forUndefinedKey</code> 的异常</li></ul><p>至此，我们的 <code>setValue:forKey:</code> 流程就结束了，当然，整个内容和系统真正的 <code>KVC</code> 比起来还差得很远，包括线程安全、可变数组之类的都没涉及，不过这不是重点，我们只需要举一反三即可。</p><h2 id="3-2-自定义取值"><a href="#3-2-自定义取值" class="headerlink" title="3.2 自定义取值"></a>3.2 自定义取值</h2><p>接着我们需要自定义的是 <code>valueForKey:</code>，我们声明如下的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)jh_valueForKey:(NSString *)key;</span><br></pre></td></tr></table></figure><p>然后同样的，根据我们前面探索的 <code>valueForKey:</code> 底层流程，还是要先判断 <code>key</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1.判断 key</span><br><span class="line">if (key == nil  || key.length == 0) &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 <code>key</code> 为 <code>nil</code> 或者 <code>key</code> 长度为 0 ，直接退出。</li></ul><p>然后就是判断是否有相应的 <code>getter</code> 方法，查找顺序是按照 <code>getKey</code>, <code>key</code>, <code>isKey</code>, <code>_key</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    // 2.判断 getKey,key,isKey,_key 是否存在，如果存在，直接调用相应的方法来返回属性值</span><br><span class="line">    NSString *Key = key.capitalizedString;</span><br><span class="line">    NSString *getKey = [NSString stringWithFormat:@&quot;get%@:&quot;,Key];</span><br><span class="line">    NSString *isKey = [NSString stringWithFormat:@&quot;is%@:&quot;,Key];</span><br><span class="line">    NSString *_key = [NSString stringWithFormat:@&quot;_%@:&quot;,Key];</span><br><span class="line">    </span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">    if ([self respondsToSelector:NSSelectorFromString(getKey)]) &#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(getKey)];</span><br><span class="line">    &#125; else if ([self respondsToSelector:NSSelectorFromString(key)])&#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(key)];</span><br><span class="line">    &#125; else if ([self respondsToSelector:NSSelectorFromString(isKey)])&#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(isKey)];</span><br><span class="line">    &#125; else if ([self respondsToSelector:NSSelectorFromString(_key)])&#123;</span><br><span class="line">        return [self performSelector:NSSelectorFromString(_key)];</span><br><span class="line">    &#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure><p>如果这四种 <code>getter</code> 方法都没有找到，那么同样的就需要读取类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 3.判断是否能直接读取成员变量</span><br><span class="line">if (![self.class accessInstanceVariablesDirectly] ) &#123;</span><br><span class="line">    @throw [NSException exceptionWithName:@&quot;JHUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ valueForUndefinedKey:]: this class is not key value coding-compliant for the key name.****&quot;,self] userInfo:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果可以读取成员变量，那么就需要我们按照 <code>_key</code>，<code>_isKey</code>, <code>key</code>, <code>isKey</code> 的顺序去查找了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 4.按照 _key,_iskey,key,isKey 顺序查询实例变量</span><br><span class="line">NSMutableArray *mArray = [self getIvarListName];</span><br><span class="line">_key = [NSString stringWithFormat:@&quot;_%@&quot;,key];</span><br><span class="line">NSString *_isKey = [NSString stringWithFormat:@&quot;_is%@&quot;,Key];</span><br><span class="line">isKey = [NSString stringWithFormat:@&quot;is%@&quot;,Key];</span><br><span class="line">if ([mArray containsObject:_key]) &#123;</span><br><span class="line">    Ivar ivar = class_getInstanceVariable([self class], _key.UTF8String);</span><br><span class="line">    return object_getIvar(self, ivar);;</span><br><span class="line">&#125;else if ([mArray containsObject:_isKey]) &#123;</span><br><span class="line">    Ivar ivar = class_getInstanceVariable([self class], _isKey.UTF8String);</span><br><span class="line">    return object_getIvar(self, ivar);;</span><br><span class="line">&#125;else if ([mArray containsObject:key]) &#123;</span><br><span class="line">    Ivar ivar = class_getInstanceVariable([self class], key.UTF8String);</span><br><span class="line">    return object_getIvar(self, ivar);;</span><br><span class="line">&#125;else if ([mArray containsObject:isKey]) &#123;</span><br><span class="line">    Ivar ivar = class_getInstanceVariable([self class], isKey.UTF8String);</span><br><span class="line">    return object_getIvar(self, ivar);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 5.抛出异常</span><br><span class="line">@throw [NSException exceptionWithName:@&quot;JHUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ %@]: valueForUndefinedKey:%@.****&quot;,self,NSStringFromSelector(_cmd),key] userInfo:nil];</span><br></pre></td></tr></table></figure><ul><li>最后抛出 <code>valueForUndefinedKey:</code> 的异常</li></ul><p>取值过程的自定义也结束了，其实这里也有不严谨的地方，比如取得属性值返回的时候需要根据属性值类型来判断是否要转换成 <code>NSNumber</code> 或 <code>NSValue</code>，以及对 <code>NSArray</code> 和 <code>NSSet</code> 类型的判断。</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p><code>KVC</code> 探索完了，其实我们探索的大部分内容都是基于苹果的官方文档，我们在探索 <code>iOS</code> 底层的时候，文档思维十分重要，有时候说不定在文档的某个角落里就隐藏着追寻的答案。<code>KVC</code> 用起来不难，理解起来也不难，但是这不意味着我们可以轻视它。在 <code>iOS 13</code> 之前，我们可以通过 <code>KVC</code> 去获取和设置系统的私有属性，但从 <code>iOS 13</code> 之后，这种方式被禁用掉了。建议对 <code>KVC</code> 理解还不透彻的读者去多几遍官方文档，相信我，你会有新的收获。最后，我们简单总结一下本文的内容。</p><ul><li><code>KVC</code> 是一种 <code>NSKeyValueCoding</code> 隐式协议所提供的机制。</li><li><code>KVC</code> 通过 <code>valueForKey:</code> 和 <code>valueForKeyPath:</code> 来取值，不考虑集合类型的话具体的取值过程如下:<ul><li>以 <code>get&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code>, <code>_&lt;key&gt;</code> 的顺序查找方法</li><li>如果找不到方法，则通过类方法 <code>accessInstanceVariablesDirectly</code> 判断是否能读取成员变量来返回属性值</li><li>以 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code> 的顺序查找成员变量</li></ul></li><li><code>KVC</code> 通过 <code>setValueForKey:</code> 和 <code>setValueForKeyPath:</code> 来取值，不考虑集合类型的话具体的设置值过程如下:<ul><li>以 <code>set&lt;Key&gt;</code>, <code>_set&lt;Key&gt;</code>的顺序查找方法</li><li>如果找不到方法，则通过类方法 <code>accessInstanceVariablesDirectly</code> 判断是否能通过成员变量来返回设置值</li><li>以 <code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code> 的顺序查找成员变量</li></ul></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1" target="_blank" rel="noopener">Apple 开发者文档 - KVC</a></p><p><a href="https://www.jianshu.com/p/66b77270e363" target="_blank" rel="noopener">iOS atomic 和 nonatomic 的区别</a></p><p><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/MM.html" target="_blank" rel="noopener">Objective-C 内存管理</a></p><p><a href="https://juejin.im/post/5c2189dee51d454517589c8b#heading-13" target="_blank" rel="noopener">iOS底层原理总结篇 – 深入理解 KVC\KVO 实现机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、KVC-初探&quot;&gt;&lt;a href=&quot;#一、KVC-初探&quot; class=&quot;headerlink&quot; title=&quot;一、KVC 初探&quot;&gt;&lt;/a&gt;一、KVC 初探&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Key Value Coding&lt;/code&gt; 也即 &lt;code&gt;KVC&lt;/code&gt; 是 &lt;code&gt;iOS&lt;/code&gt; 开发中一个很重要的概念，中文翻译过来是 &lt;code&gt;键值编码&lt;/code&gt; ，关于这个概念的具体定义可以在 &lt;code&gt;Apple&lt;/code&gt; 的&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107-SW1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;处找到。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Key-value coding is a mechanism enabled by the NSKeyValueCoding informal protocol that objects adopt to provide indirect access to their properties.&lt;br&gt;【译】&lt;code&gt;KVC&lt;/code&gt; 是通过 &lt;code&gt;NSKeyValueCoding&lt;/code&gt; 这个非正式协议启用的一种机制，而遵循了这个协议的对象就提供了对其属性的间接访问。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
      <category term="KVC" scheme="http://leejunhui.com/tags/KVC/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - 类拓展和关联对象</title>
    <link href="http://leejunhui.com/2020/01/21/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E6%8B%93%E5%B1%95%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"/>
    <id>http://leejunhui.com/2020/01/21/iOS-底层探索-类拓展和关联对象/</id>
    <published>2020-01-21T06:27:27.000Z</published>
    <updated>2020-01-21T06:37:31.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020年1月13日-类拓展、关联对象"><a href="#2020年1月13日-类拓展、关联对象" class="headerlink" title="2020年1月13日 类拓展、关联对象"></a>2020年1月13日 类拓展、关联对象</h1><p>前面我们探索了 <code>iOS</code> 中类和分类的加载，关于类这一块的内容，我们还有一些坑没有填，比如类拓展和关联对象，今天让我们一起填下这块的坑。</p><h1 id="一、类拓展"><a href="#一、类拓展" class="headerlink" title="一、类拓展"></a>一、类拓展</h1><h2 id="1-1-什么是类拓展"><a href="#1-1-什么是类拓展" class="headerlink" title="1.1 什么是类拓展?"></a>1.1 什么是类拓展?</h2><p>关于类拓展的具体定义，大家可以直接参考 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="noopener">Apple 对于类拓展的说明</a>。</p><a id="more"></a><blockquote><p>A class extension bears some similarity to a category, but it can only be added to a class for which you have the source code at compile time (the class is compiled at the same time as the class extension).</p><p>类拓展和分类很相似，但是前提是你拥有原始类的源码，并且是在<strong>编译时</strong>被附加到类上的。（类和类扩展同时编译）</p></blockquote><p>类拓展的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface ClassName ()</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>Because no name is given in the parentheses, class extensions are often referred to as anonymous categories.<br>因为括号中没有填写任何内容，所以类扩展也被称为<strong>匿名的分类</strong>。</p></blockquote><p>我们在 <code>Xcode</code> 中创建 <code>Objective</code> 类型的文件的时候，可以选择空文件、分类、协议以及类扩展。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150028.jpg" alt></p><p>如果我们选择 <code>Extension</code> 选项，<code>Xcode</code> 会帮我们生成一个 <code>NSObject + 扩展名</code> 的头文件出来，也就是说类扩展的命名方式为 <code>类名_扩展名.h</code></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150038.jpg" alt></p><p>而这样的操作其实我们很少做，我们一般都是在 <code>.m</code> 文件中声明一下当前类的拓展，基本上我们都会在类扩展去声明一些<strong>私有</strong>的属性、方法。比如在 <code>.h</code> 文件中声明一个只读的属性，然后在 <code>.m</code> 文件的类拓展中去重写这个属性为可读可写。</p><p>我们不妨使用 <code>LLDB</code> 打印看一下类拓展究竟是不是在编译时就被附加到了类上面了呢？</p><h2 id="1-2-类拓展是编译时确定的吗？"><a href="#1-2-类拓展是编译时确定的吗？" class="headerlink" title="1.2 类拓展是编译时确定的吗？"></a>1.2 类拓展是编译时确定的吗？</h2><p>我们在 <code>objc-756</code> 源码中的 <code>objc-debug</code> 项目下新建一个类 <code>Person</code>，然后给这个类添加一个属性 <code>name</code>，然后在 <code>.m</code> 文件中的类拓展中添加一个属性 <code>mName</code> 和方法 <code>extM_method</code>，接着再创建一个 <code>Person</code> 的类拓展 <code>Person+Extension.h</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// Person.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br><span class="line"></span><br><span class="line">// Person.m</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &quot;Person+Extension.h&quot;</span><br><span class="line"></span><br><span class="line">@interface Person ()</span><br><span class="line">@property (nonatomic, copy) NSString *mName;</span><br><span class="line"></span><br><span class="line">- (void)extM_method;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)extM_method&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)extH_method&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Person+Extension.h</span><br><span class="line">#import &lt;AppKit/AppKit.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface Person ()</span><br><span class="line">@property (nonatomic, copy) NSString *ext_name;</span><br><span class="line">@property (nonatomic, copy) NSString *ext_subject;</span><br><span class="line"></span><br><span class="line">- (void)extH_method;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure><p>接着我们在 <code>main.m</code> 中来测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Person *p = [Person alloc];</span><br><span class="line">        NSLog(@&quot;%@ - %p&quot;, p, p);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 <code>Person</code> 实例化对象 <code>p</code> 这一行打上断点，然后运行项目。接着在控制台进行 <code>LLDB</code> 打印:</p><blockquote><p>因为对象的属性以及方法都存储在类对象上面，而由于类结构里面的 <code>ro</code> 是编译时就确定了其内容，所以我们只需要打印出类对象的 <code>ro</code> 结构中<br>是否有类拓展中的 <code>mName</code> 属性和 <code>extM_method</code> 方法<br>是否有类扩展中的 <code>ext_name</code> 和 <code>ext_subject</code> 属性以及 <code>extH_method</code> 方法</p></blockquote><h2 id="1-3-LLDB-验证"><a href="#1-3-LLDB-验证" class="headerlink" title="1.3 LLDB 验证"></a>1.3 LLDB 验证</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150035.jpg" alt></p><ul><li>通过 <code>x/4gx</code> 命令打印出 <code>LGPerson</code> 类对象的内存地址，以 16 进制方式打印，打印 4 段</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150031.jpg" alt></p><ul><li>因为类对象的内存地址起始为 <code>isa</code>，紧接着是 <code>superclass</code>，然后是 <code>cache_t</code>。我们前面已经分析过，在默认的 <code>arm64</code> 处理器架构下，<code>isa</code> 占 8 个字节，<code>superclass</code> 占 8 个字节，而 <code>cache_t</code> 的三个属性加起来是 8 + 4 + 4 = 16 个字节，所以要想拿到   <code>bits</code> 需要进行 8 + 8 + 16 = 32 字节的内存平移，但是这里是 16 进制，所以需要移动 0x20 个内存地址，也就是 <code>0x100002420 + 0x20 = 0x100002440</code></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150042.jpg" alt></p><ul><li>因为类对象的 <code>data()</code> 属性会返回 <code>bits.data()</code>，所以这里直接打印刚才取到的 <code>bits</code> 的 <code>data()</code> 属性，而 <code>bits</code> 的 <code>data()</code> 属性其实返回的是 <code>rw</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">class_rw_t</span>* data() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150044.jpg" alt></p><ul><li>接着打印 <code>rw</code> 的属性 <code>ro</code>，然后我们先尝试读取 <code>baseMethodList</code> 属性，该属性存储的是编译时确定的类的所有的方法。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150047.jpg" alt></p><ul><li>因为 <code>baseMethodList</code> 属性是一个 <code>List</code> 类型的容器，我们直接使用 <code>get(index)</code> 来获取其 <code>index</code> 处的值，结果我们所要寻找的 <code>extH_method</code> 和 <code>extM_method</code> 出现了，不过还没结束，我们还没验证类拓展中声明的两个属性，让我们打印一下 <code>ro</code> 的 <code>baseProperties</code></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150051.jpg" alt></p><ul><li>我们很清楚的看到，<code>mName</code>，<code>ext_name</code> 和 <code>ext_subject</code> 都被找到了，那么是不是就是说类拓展就是编译时确定的了呢？我们还漏掉了这三个属性的 <code>getter</code> 和 <code>setter</code> 了，让我们回过头再去 <code>baseMethodList</code> 中查找一下</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200120150055.jpg" alt></p><ul><li>Bingo! 我们类拓展定义的属性的 <code>getter</code> 和 <code>setter</code> 方法也生成了，至此，我们就完全确定了类拓展在编译时就会被加载到类的 <code>ro</code> 中。</li></ul><blockquote><p>这里有个注意点，就是如果我们没有在类的头文件或者源文件中引入单独的类拓展头文件，那么这个单独的类拓展的头文件里面的属性和方法将不会被加载到类上面来。</p></blockquote><h2 id="1-4-类拓展和分类的区别"><a href="#1-4-类拓展和分类的区别" class="headerlink" title="1.4 类拓展和分类的区别"></a>1.4 类拓展和分类的区别</h2><table><thead><tr><th>研究对象</th><th>加载时机</th><th>操作对象</th><th>能否通过@property声明属性生成 getter 和 setter</th></tr></thead><tbody><tr><td>分类(实现了load方法)</td><td>运行时</td><td>rw</td><td>不能，需要借助关联对象来实现</td></tr><tr><td>分类(没有实现load方法)</td><td>编译时</td><td>ro</td><td>不能，需要借助关联对象来实现</td></tr><tr><td>类拓展</td><td>编译时</td><td>ro</td><td>可以</td></tr></tbody></table><h1 id="二、关联对象"><a href="#二、关联对象" class="headerlink" title="二、关联对象"></a>二、关联对象</h1><p>上一节我们探索了类拓展以及类拓展与分类的区别，我们知道，类拓展中可以声明属性，编译器会帮助我们生成属性对应的 <code>getter</code> 和 <code>setter</code> 方法，但是分类通过 <code>@property</code> 的方式来声明属性却不能生成 <code>getter</code> 和 <code>setter</code> 方法。而其实 <code>iOS</code> 中有一种方式可以为分为增加具有 <code>getter</code> 和 <code>setter</code> 的属性，那就是 - 关联对象 <code>Associated Objects</code> 。</p><h2 id="2-1-关联对象定义"><a href="#2-1-关联对象定义" class="headerlink" title="2.1 关联对象定义"></a>2.1 关联对象定义</h2><p>关联对象的官方定义可以在 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocAssociativeReferences.html#//apple_ref/doc/uid/TP30001163-CH24" target="_blank" rel="noopener">苹果官方文档</a> 上找到。</p><blockquote><p>Associative references, available starting in OS X v10.6, simulate the addition of object instance variables to an existing class. Using associative references, you can add storage to an object without modifying the class declaration. This may be useful if you do not have access to the source code for the class, or if for binary-compatibility reasons you cannot alter the layout of the object.</p></blockquote><blockquote><p>关联引用，是从 <code>OS X 10.6</code> 开始启用的，模拟了将对象实例变量添加到已经存在的类中。通过使用关联引用，你可以在不修改类声明的前提下为对象添加内容。如果你无权访问该类的源代码，或者由于二进制兼容性原因而无法更改该对象的布局，则这可能很有用。</p></blockquote><blockquote><p>Associations are based on a key. For any object you can add as many associations as you want, each using a different key. An association can also ensure that the associated object remains valid for at least the lifetime of the source object.</p></blockquote><blockquote><p>关联引用机制基于 <code>key</code>。对于任何对象，你都可以根据需要添加任意数量的关联引用，每个关联都使用不同的 <code>key</code>。关联引用还可以确保关联的对象至少在源对象的声明周期内保持有效。</p></blockquote><p>而关于关联对象的最佳实践可以参考 <a href="https://nshipster.com/associated-objects/" target="_blank" rel="noopener">NSHipster - Associated Objects</a> 一文。</p><p>从苹果官方文档可以看到，关联引用其实不是只能在分类中使用，只不过对于我们日常开发来说，分类中使用关联引用还是更常用的场景。相信大多数开发者都知道怎么使用关联引用，的确，关联引用使用起来很简单，不外乎两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 设置关联对象</span><br><span class="line">objc_setAssociatedObject()</span><br><span class="line"></span><br><span class="line">// 获取关联对象</span><br><span class="line">objc_getAssociatedObject()</span><br></pre></td></tr></table></figure><p>我们如果要给一个分类中的属性设置关联对象，需要重写属性的 <code>setter</code> 方法，然后使用 <code>objc_setAssociatedObject</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setXXX:(关联值数据类型)关联值</span><br><span class="line">    objc_setAssociatedObject(self, 关联的key, 关联值, 关联对象内存管理策略);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后还需要重写 <code>getter</code> 方法，然后使用 <code>objc_getAssociatedObject</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (关联值数据类型)关联值&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, 关联的key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中的关联对象内存管理策略如下表所示：</p><table><thead><tr><th>关联策略</th><th>等同的 @property</th><th>描述</th></tr></thead><tbody><tr><td>OBJC_ASSOCIATION_ASSIGN</td><td>@property (assign) 或 @property (unsafe_unretained) <span class="Apple-tab-span" style="white-space:pre"></span> 指定一个关联对象的弱引用。</td><td>指定一个关联对象的弱引用。</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>@property (nonatomic, strong)</td><td>指定一个关联对象的强引用，不能被原子化使用。</td></tr><tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>@property (nonatomic, copy)</td><td>指定一个关联对象的copy引用，不能被原子化使用。</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN</td><td>@property (atomic, strong)</td><td>指定一个关联对象的强引用，能被原子化使用。</td></tr><tr><td>OBJC_ASSOCIATION_COPY</td><td>@property (atomic, copy)</td><td>指定一个关联对象的copy引用，能被原子化使用。</td></tr></tbody></table><h2 id="2-2-关联对象底层原理"><a href="#2-2-关联对象底层原理" class="headerlink" title="2.2 关联对象底层原理"></a>2.2 关联对象底层原理</h2><blockquote><p>关于关联对象的底层原理，这里有一篇灯塔 <code>draveness</code> 的博文 <a href="https://draveness.me/ao" target="_blank" rel="noopener">关联对象 AssociatedObject 完全解析</a> 十分值得一读。</p></blockquote><p>当然，如果也可以跟随笔者一起探索下关联对象的底层原理。我们不妨从最直观的 <code>objc_setAssociatedObject</code> 方法开始切入：</p><h2 id="2-3-objc-setAssociatedObject"><a href="#2-3-objc-setAssociatedObject" class="headerlink" title="2.3 objc_setAssociatedObject"></a>2.3 objc_setAssociatedObject</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// objc-runtime.mm</span><br><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">    _object_set_associative_reference(object, (void *)key, value, policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objc_setAssociatedObject</code> 方法的实现又包裹了一层，其实现为 <code>_object_set_associative_reference</code></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200121141312.jpg" alt></p><p>而 <code>_object_set_associative_reference</code> 方法的实现非常长，这里就分段来进行探索吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This code used to work when nil was passed for object and key. Some code</span></span><br><span class="line"><span class="comment">// probably relies on that to not crash. Check and handle it explicitly.</span></span><br><span class="line"><span class="comment">// rdar://problem/44094390</span></span><br><span class="line"><span class="keyword">if</span> (!object &amp;&amp; !value) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><blockquote><p>根据注释我们可以知道，当传入的 <code>object</code> 和 <code>key</code> 同时为 <code>nil</code> 的时候，直接返回。这样的处理是为了避免传入空值时而导致崩溃。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-references.mm</span></span><br><span class="line"><span class="keyword">if</span> (object-&gt;getIsa()-&gt;forbidsAssociatedObjects())</span><br><span class="line">        _objc_fatal(<span class="string">"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects"</span>, object, object_getClassName(object));</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-runtime-new.h        </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">forbidsAssociatedObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (data()-&gt;flags &amp; RW_FORBIDS_ASSOCIATED_OBJECTS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>判断要进行关联的对象是否禁用掉了关联引用，这里是通过对象的 <code>isa</code> 的 <code>rw</code> 的 <code>flags</code> 属性与上一个宏 <code>RW_FORBIDS_ASSOCIATED_OBJECTS</code>来判断的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line"><span class="function">ObjcAssociation <span class="title">old_association</span><span class="params">(<span class="number">0</span>, nil)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>初始化一个 <code>ObjcAssociation</code> 对象，用于持有原有的关联对象</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id new_value = value ? acquireValue(value, policy) : nil;</span><br></pre></td></tr></table></figure><blockquote><p>判断传入的关联对象值是否存在，如果存在就调用 <code>acquireValue</code> 方法来获取值，我们可以进入 <code>acquireValue</code> 方法看一下:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> id <span class="title">acquireValue</span><span class="params">(id value, <span class="keyword">uintptr_t</span> policy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (policy &amp; <span class="number">0xFF</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_RETAIN:</span><br><span class="line">        <span class="keyword">return</span> objc_retain(value);</span><br><span class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_COPY:</span><br><span class="line">        <span class="keyword">return</span> ((id(*)(id, SEL))objc_msgSend)(value, SEL_copy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到 <code>acquireValue</code> 会根据关联策略来进行 <code>retain</code> 或 <code>copy</code> 消息的发送</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AssociationsManager manager;</span><br><span class="line"><span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line"><span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br></pre></td></tr></table></figure><blockquote><p>初始化一个 <code>AssociationsManager</code> 对象，然后获取一个 <code>AssociationsHashMap</code> 哈希表，然后通过 <code>DISGUISE</code> 方法作为去哈希表查找的 <code>key</code>。这里的 <code>DISGUISE</code> 其实进行了按位取反的操作。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> disguised_ptr_t <span class="title">DISGUISE</span><span class="params">(id value)</span> </span>&#123; <span class="keyword">return</span> ~<span class="keyword">uintptr_t</span>(value); &#125;</span><br></pre></td></tr></table></figure><p>如果传入的关联对象值存在，说明是进行赋值操作；如果传入的关联对象值不存在，说明是进行置空操作。这里我们先看一下赋值操作的流程:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p>1.通过上一步按位取反之后的结果，在 <code>AssociationsHashMap</code> 哈希表中查询，这里是通过迭代器的方式进行查询，查询的结果是 <code>ObjcAssociation</code> 对象，这个结构也是一个哈希表，其内部存储的是 <code>_object_set_associative_reference</code> 方法传入的 <code>key</code> 为键，<code>ObjcAssociation</code> 对象为值的键值对<br>2.如果没有查询到，说明之前在当前类上<strong>没有设置过</strong>关联对象。则需要初始化一个 <code>ObjectAssociationMap</code> 出来，然后通过 <code>setHasAssociatedObjects</code> 设置当前对象的 <code>isa</code> 的 <code>has_assoc</code> 属性为 <code>true</code><br>3.如果查询到了，说明之前在当前类上<strong>设置过</strong>关联对象，接着需要看 <code>key</code> 是否存在，如果 <code>key</code> 存在，那么就需要更新原有的关联对象；如果 <code>key</code> 不存在，则需要新增一个关联对象</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line"><span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">    ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">    ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">    <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">        old_association = j-&gt;second;</span><br><span class="line">        refs-&gt;erase(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为来到这里的条件是 <code>new_value</code> 为 <code>nil</code>，也就代表着要删除关联对象，内部的逻辑和上面的流程大同小异，不过最后多了一步在 <code>ObjectAssociationMap</code> 擦除 <code>key</code> 对应的节点</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line"><span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</span><br></pre></td></tr></table></figure><blockquote><p>最后会判断 <code>old_association</code> 是否有值，如果有的话就释放掉，当然前提是旧的关联对象的策略是 <code>OBJC_ASSOCIATION_SETTER_RETAIN</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">ReleaseValue</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(ObjcAssociation &amp;association)</span> </span>&#123;</span><br><span class="line">        releaseValue(association.value(), association.policy());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseValue</span><span class="params">(id value, <span class="keyword">uintptr_t</span> policy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) &#123;</span><br><span class="line">        <span class="keyword">return</span> objc_release(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="2-4-objc-getAssociatedObject"><a href="#2-4-objc-getAssociatedObject" class="headerlink" title="2.4 objc_getAssociatedObject"></a>2.4 objc_getAssociatedObject</h2><p><code>objc_setAssociatedObject</code> 方法分析完了，我们接着看另外一个重要的方法 <code>objc_getAssociatedObject</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _object_get_associative_reference(object, (<span class="keyword">void</span> *)key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，跟 <code>objc_setAssociatedObject</code> 一样，<code>objc_getAssociatedObject</code> 这里又包裹了一层，其实现为 <code>_object_get_associative_reference</code>，而这个方法相比于上一节的 <code>_object_set_associative_reference</code> 要简单一些，我们就直接贴出完整的代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">id _object_get_associative_reference(id object, <span class="keyword">void</span> *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    <span class="keyword">uintptr_t</span> policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.value();</span><br><span class="line">                policy = entry.policy();</span><br><span class="line">                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;</span><br><span class="line">                    objc_retain(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        objc_autorelease(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1.先初始化一个空的 <code>value</code>，以及一个策略为 <code>OBJC_ASSOCIATION_ASSIGN</code> 的 <code>policy</code><br>2.初始化一个 <code>AssociationsManager</code> 关联对象管理类，接着拿到 <code>AssociationsHashMap</code> 对象，这个对象在 <code>AssociationsManager</code> 底层是静态的<br>3.然后以 <code>DISGUISE(object)</code> 按位取反之后的结果为键去查询 <code>AssociationsHashMap</code><br>4.如果在 <code>AssociationsHashMap</code> 中扎到了，接着以 <code>key</code> 为键去 <code>ObjectAssociationMap</code> 中查询 <code>ObjcAssociation</code><br>如果在 <code>ObjectAssociationMap</code> 中查询到了 <code>ObjcAssociation</code>，则把值和策略赋值给方法入口声明的两个临时变量，然后判断获取到的关联对象的策略是否为 <code>OBJC_ASSOCIATION_GETTER_RETAIN</code>，如果是的话，需要对关联值进行 <code>retain</code> 操作<br>5.最后判断如果关联值是否存在且策略为 <code>OBJC_ASSOCIATION_GETTER_AUTORELEASE</code>，是的话就需要调用 <code>objc_autorelease</code> 来释放关联值<br>6.最后返回关联值</p></blockquote><h2 id="2-5-objc-removeAssociatedObjects"><a href="#2-5-objc-removeAssociatedObjects" class="headerlink" title="2.5 objc_removeAssociatedObjects"></a>2.5 objc_removeAssociatedObjects</h2><p><code>objc_removeAssociatedObjects</code> 方法我们平时可能用的不多，从字面含义来看，这个方法应该是用来删除关联对象。我们来到它的定义处：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        _object_remove_assocations(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里会判断 <code>object</code> 存在且有关联对象才会进入真正的实现 <code>_object_remove_assocations</code>，该实现也不是很复杂，我们还是直接贴出代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_remove_assocations(id object) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the secondary table.</span></span><br><span class="line">            <span class="keyword">delete</span> refs;</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里会将对象包含的所有关联对象加入到一个 <code>vector</code> 中，然后对所有的 <code>ObjcAssociation</code> 对象调用 <code>ReleaseValue()</code> 方法，释放不再被需要的值。</p></blockquote><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><ul><li>类拓展是一种匿名的分类，加载时机为编译时</li><li>类拓展可以添加属性和方法以及实例变量，分类只能添加方法，属性，但是需要借助关联对象来生成 <code>getter</code> 和 <code>setter</code>，而且分类不能声明实例变量</li><li>关联对象在底层其实是 <code>ObjcAssociation</code> 对象的结构</li><li>全局有一个 <code>AssociationsManager</code> 管理类存储了一个静态的哈希表 <code>AssociationsHashMap</code>，这个哈希表存储的是以对象指针为键，以该对象所有的关联对象为值，而对象所有的关联对象又是以 <code>ObjectAssociationMap</code> 来存储的</li><li><code>ObjectAssociationMap</code> 存储结构为 <code>key</code> 为键，<code>ObjcAssociation</code> 为值</li><li>快速判断一个对象是否存在关联对象，可以直接取对象 <code>isa</code> 的 <code>has_assoc</code></li></ul><h1 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h1><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="noopener">Apple - 类拓展</a></p><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocAssociativeReferences.html#//apple_ref/doc/uid/TP30001163-CH24" target="_blank" rel="noopener">Apple - 关联对象</a> </p><p><a href="https://nshipster.com/associated-objects/" target="_blank" rel="noopener">NSHipster - Associated Objects</a> </p><p><a href="https://draveness.me/ao" target="_blank" rel="noopener">Draveness - 关联对象 AssociatedObject 完全解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2020年1月13日-类拓展、关联对象&quot;&gt;&lt;a href=&quot;#2020年1月13日-类拓展、关联对象&quot; class=&quot;headerlink&quot; title=&quot;2020年1月13日 类拓展、关联对象&quot;&gt;&lt;/a&gt;2020年1月13日 类拓展、关联对象&lt;/h1&gt;&lt;p&gt;前面我们探索了 &lt;code&gt;iOS&lt;/code&gt; 中类和分类的加载，关于类这一块的内容，我们还有一些坑没有填，比如类拓展和关联对象，今天让我们一起填下这块的坑。&lt;/p&gt;
&lt;h1 id=&quot;一、类拓展&quot;&gt;&lt;a href=&quot;#一、类拓展&quot; class=&quot;headerlink&quot; title=&quot;一、类拓展&quot;&gt;&lt;/a&gt;一、类拓展&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是类拓展&quot;&gt;&lt;a href=&quot;#1-1-什么是类拓展&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是类拓展?&quot;&gt;&lt;/a&gt;1.1 什么是类拓展?&lt;/h2&gt;&lt;p&gt;关于类拓展的具体定义，大家可以直接参考 &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apple 对于类拓展的说明&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - 分类的加载</title>
    <link href="http://leejunhui.com/2020/01/19/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
    <id>http://leejunhui.com/2020/01/19/iOS-底层探索-分类的加载/</id>
    <published>2020-01-19T03:59:18.000Z</published>
    <updated>2020-01-19T04:28:21.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、初探懒加载类"><a href="#一、初探懒加载类" class="headerlink" title="一、初探懒加载类"></a>一、初探懒加载类</h1><p>上一章我们探索了 <code>iOS</code> 中类的加载，让我们简单回顾一下大概的流程。</p><h2 id="1-1-类的加载回顾"><a href="#1-1-类的加载回顾" class="headerlink" title="1.1 类的加载回顾"></a>1.1 类的加载回顾</h2><ul><li><code>libObjc</code> 向 <code>dyld</code> 注册了回调 <code>_dyld_objc_notify_register</code>，当 <code>dyld</code> 把 <code>App</code> 以及 <code>App</code> 所依赖的一系列 <code>Mach-O</code> 镜像加载到当前 <code>App</code> 被分配的内存空间之后，<code>dyld</code> 会通过 <code>_dyld_objc_notify_mapped</code> 也就是 <code>map_images</code> 来通知 <code>libObjc</code> 来完成具体的加载工作，<code>map_images</code> 被调用之后会来到 <code>_read_images</code></li><li><code>_read_images</code><ul><li>主要会进行类的加载工作，会插入 <strong>所有的类</strong> 到 <code>gdb_objc_realized_classes</code> 哈希表中（插入方式为 类名为 <code>key</code>，类对象为<code>value</code>, 不包括通过 <em>共享缓存</em> 里面的类），同时还会把类插入到 <code>allocatedClasses</code> 这个集合里面，注意，<code>allocatedClasses</code> 的类型为 <code>NXHashTable</code>，可以类比为 <code>NSSet</code>，而 <code>gdb_objc_realized_classes</code> 的类型为 <code>NXMapTable</code>，可以类比为 <code>NSDictionary</code></li><li>对所有的类进行重映射</li><li>将所有的 <code>SEL</code> 插入到 <code>namedSelectors</code> 哈希表中(插入方式为：<code>SEL</code> 名称为 <code>key</code>，<code>SEL</code> 为<code>value</code>)</li><li>修复函数指针遗留</li><li>将所有的 <code>Protocol</code> 插入到 <code>readProtocol</code> 哈希表中(插入方式为：<code>Protocol</code> 名称为 <code>key</code>，<code>Protocol</code> 为 <code>value</code>)</li><li>对所有的 <code>Protocol</code> 做重映射</li><li>初始化所有的<strong>非懒加载类</strong>，包括 <code>rw</code> 和 <code>ro</code> 的初始化操作</li><li>处理所有的分类(包括类的分类和元类的分类)<a id="more"></a><h2 id="1-2-验证类的加载流程"><a href="#1-2-验证类的加载流程" class="headerlink" title="1.2 验证类的加载流程"></a>1.2 验证类的加载流程</h2></li></ul></li></ul><p>我们大致明白了类的加载流程，接下来，让我们在 <code>_read_images</code> 源码中打印一下类加载之后的结果验证一下是否加载了我们自己创建的类。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119120206.jpg" alt></p><p>如上图所示，我们增加一行代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"_getObjc2NonlazyClassList Class:%s\n"</span>,cls-&gt;mangledName());</span><br></pre></td></tr></table></figure><p>接着我们观察打印结果:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119120352.jpg" alt></p><p>忘了提一句，我们这一个有三个类： <code>LGPerson</code> 、 <code>LGStudent</code> 、 <code>LGTeacher</code> </p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121650.jpg" alt></p><p>但是打印出来的结果没有 <code>LGPerson</code> ，这是为什么呢？答案看这里，我们其实是在 <code>LGStudent</code> 和 <code>LGTeacher</code> 内部实现了 <code>+load</code> 方法。而 <code>LGPerson</code> 则是没有实现 <code>+load</code> 方法。</p><h2 id="1-3-懒加载类的发现"><a href="#1-3-懒加载类的发现" class="headerlink" title="1.3 懒加载类的发现"></a>1.3 懒加载类的发现</h2><p>我们这个时候观察 <code>_read_images</code> 源码这部分的注释:</p><blockquote><p>Realize non-lazy classes (for +load methods and static instances)</p><p>实现<strong>非懒加载</strong>类(实现了 <code>+load</code> 方法和静态实例)</p></blockquote><p>什么意思呢，我们这里其实打印的都是所谓的<strong>非懒加载类</strong>，这里除了我们自己实现了 <code>+load</code> 方法的两个类之外，其他的内容都是系统内置的类，包括我们十分熟悉的 <code>NSObject</code> 类。通过这里其实反过来推论，我们没有实现 <code>+load</code> 方法就是所谓的<strong>懒加载类，这种类并不会在 **`</strong>_read_images**<code>环节被加载，那么应该是在哪里加载呢？我们稍微思考一下，我们一般第一次操作一个类是不是在初始化这个类的时候，而初始化类不就是发送</code>alloc<code>消息吗，而根据我们前面探索消息查找的知识，在第一次发送某个消息的时候，是没有缓存的，所以会来到一个非常重要的方法叫</code>lookUpImpOrForward<code>，我们在</code>main.m<code>中</code>LGPerson<code>类初始化的地方和</code>lookUpImpOrForward` 入口处打上断点:</p><blockquote><p>Tips: 这里有个小技巧，我们先打开 <code>main.m</code> 文件中的断点，等断点来到了我们想要探索的 <code>LGPerson</code> 初始化的位置的时候，我们再打开 <code>lookUpImpOrForward</code> 处的断点，这样才能确保当前执行 <code>lookUpImpOrForward</code> 的是我们的研究对象 <code>LGPerson</code> </p></blockquote><p>因为我们断点的位置是 <code>LGPerson</code> 类发送 <code>alloc</code> 消息，而显然 <code>alloc</code> 作为类方法是存储在元类上的，也就是说 <code>lookUpImpOrForward</code> 的 <code>cls</code> 其实是 <code>LGPerson</code> 元类。那么 <code>inst</code> 就应该是真正的对象，可实际如下图所示：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121717.jpg" alt></p><p>此时的 <code>inst</code> 只是一个地址，说明还没有初始化。我们让程序接着下面走，会来到这样一行代码:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121724.jpg" alt></p><p>这里的 <code>if</code> 判断通过方法名我们不难看出是只有当 <code>cls</code> 未实现的时候才会走里面的 <code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法，那也就是说 <code>LGPerson</code> 元类没有被实现，也就是 <code>LGPerson</code> 类没有实现或者说没有被加载。</p><p>我们就顺着 <code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法往下面走走看，看到底是在哪把我们这个懒加载类给加载出来的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class</span><br><span class="line">realizeClassMaybeSwiftMaybeRelock(Class cls, <span class="keyword">mutex_t</span>&amp; lock, <span class="keyword">bool</span> leaveLocked)</span><br><span class="line">&#123;</span><br><span class="line">    lock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isSwiftStable_ButAllowLegacyForNow()) &#123;</span><br><span class="line">        <span class="comment">// Non-Swift class. Realize it now with the lock still held.</span></span><br><span class="line">        <span class="comment">// fixme wrong in the future for objc subclasses of swift classes</span></span><br><span class="line">        realizeClassWithoutSwift(cls);</span><br><span class="line">        <span class="keyword">if</span> (!leaveLocked) lock.unlock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Swift class. We need to drop locks and call the Swift</span></span><br><span class="line">        <span class="comment">// runtime to initialize it.</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">        cls = realizeSwiftClass(cls);</span><br><span class="line">        assert(cls-&gt;isRealized());    <span class="comment">// callback must have provoked realization</span></span><br><span class="line">        <span class="keyword">if</span> (leaveLocked) lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一路跟随断点来到了 <code>realizeClassMaybeSwiftMaybeRelock</code> 方法，然后我们看到了我们熟悉的一个方法 <code>realizeClassWithoutSwift</code> ，这个方法内部会进行 <code>ro/rw</code> 的赋值操作以及 <code>category</code> 的 <code>attatch</code> ，关于这个方法更多内容可以查看上一篇文章。</p><p>接着我们返回到 <code>lookUpImpOrForward</code> 方法中来，然后进行一下 <code>LLDB</code> 打印，看一下当前这个 <code>inst</code> 也就是 <code>LGPerson</code> 对象是否已经被加载了。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121740.jpg" alt></p><p>通过上面的打印，我们可以看到 <code>rw</code> 已经有值了，也就是说 <code>LGPerson</code> 类被加载了。</p><p>我们总结一下，如果类没有实现 <code>load</code> 方法，那么这个类就是<strong>懒加载类</strong>，其调用堆栈如下图所示：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121758.jpg" alt></p><p>反之、这个类如果实现了 <code>load</code> 方法，那么这个类就是<strong>非懒加载类</strong>，其调用堆栈如下图所示：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121804.jpg" alt></p><h2 id="1-4-懒加载类的流程"><a href="#1-4-懒加载类的流程" class="headerlink" title="1.4 懒加载类的流程"></a>1.4 懒加载类的流程</h2><p>关于<strong>非懒加载类</strong>的加载流程我们已经很熟悉了，我们总结下<strong>懒加载类</strong>的流程：</p><ul><li>类第一次发送消息的时候是没有缓存的，所以会来到 <code>_class_lookupMethodAndLoadCache3</code> ，关于这个方法我们在前面的消息查找章节已经介绍过了，不熟悉的同学可以去查阅一下。</li><li><code>_class_lookupMethodAndLoadCache3</code> 会调用 <code>lookUpImpOrForward</code> ，这个方法的重要性在我们学习 <code>Runtime</code> 的过程中不言而喻</li><li><code>lookUpImpOrForward</code> 内部会进行一下判断，如果 <code>cls</code> 没有被实现，会调用 <code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法</li><li><code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法又会调用 <code>realizeClassMaybeSwiftMaybeRelock</code> 方法</li><li><code>realizeClassMaybeSwiftMaybeRelock</code> 方法内部会进行一下是否是 <code>Swift</code> 的判断，如果不是 <code>Swift</code> 环境的话，就会来到 <code>realizeClassWithoutSwift</code> ，也就是最终的类的加载的地方</li></ul><h1 id="二、分类的底层实现"><a href="#二、分类的底层实现" class="headerlink" title="二、分类的底层实现"></a>二、分类的底层实现</h1><p>分类作为 <code>Objective-C</code> 中常见的特性，相信大家都不会陌生，不过在底层它是怎么实现的呢？</p><h2 id="2-1-重写分类源文件"><a href="#2-1-重写分类源文件" class="headerlink" title="2.1 重写分类源文件"></a>2.1 重写分类源文件</h2><p>为了探究分类的底层实现，我们只需要用 <code>clang</code> 的重写命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc LGTeacher+test.m -o category.cpp</span><br></pre></td></tr></table></figure><p>我们查看 <code>category.cpp</code> 这个文件，来到文件尾部可以看到:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_LGTeacher_</span>$_<span class="title">test</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>,__<span class="title">objc_const</span>"))) = </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="string">"LGTeacher"</span>,</span><br><span class="line"><span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_LGTeacher,</span></span><br><span class="line">(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_LGTeacher_$_test,</span><br><span class="line">(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_LGTeacher_$_test,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">(<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_LGTeacher_$_test,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到 <code>LGTeacher+test</code> 分类在底层的实现是一个结构体，其名字为 <code>_OBJC_$_CATEGORY_LGTeacher_$_test</code> ，很明显这是一个按规则生成的符号，中间的 <code>LGTeacher</code> 是类名，后面的 <code>test</code> 是分类的名字。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121826.jpg" alt></p><p>我们的分类如上图所示，定义了属性、实例方法和类方法，刚好在底层对应了 </p><ul><li><code>_OBJC_$_PROP_LIST_LGTeacher_$_test</code></li><li><code>_OBJC_$_CATEGORY_INSTANCE_METHODS_LGTeacher_$_test</code></li><li><code>_OBJC_$_CATEGORY_CLASS_METHODS_LGTeacher_$_test</code></li></ul><p>同时，我们在后面可以看到如下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> *<span class="title">L_OBJC_LABEL_CATEGORY_</span>$ [1] __<span class="title">attribute__</span>((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>, __<span class="title">objc_catlist</span>,<span class="title">regular</span>,<span class="title">no_dead_strip</span>")))= &#123;</span></span><br><span class="line">&amp;_OBJC_$_CATEGORY_LGTeacher_$_test,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这表明分类是存储在 <code>__DATA</code> 段的 <code>__objc_catlist</code> section 里面的。</p><h2 id="2-2-分类的定义"><a href="#2-2-分类的定义" class="headerlink" title="2.2 分类的定义"></a>2.2 分类的定义</h2><p>我们根据 <code>_category_t</code> 来到 <code>libObjc</code> 源码中进行查找，不过我们需要去掉一下 <code>_category_t</code> 的下划线，然后不难找到分类真正的定义所在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">property_list_t</span> *propertiesForMeta(<span class="keyword">bool</span> isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据刚才 <code>clang</code> 重写之后的内容，我们不难看出</p><ul><li><code>name</code> : 是分类所关联的类，也就是类的名字，而不是分类的名字</li><li><code>cls</code> : 我们在前面可以看到 <code>clang</code> 重写后这个值为 0，但是后面有注释为 <code>&amp;OBJC_CLASS_$_LGTeacher</code> ，也就是我们的类对象的定义，所以这里其实就是我们要扩展的类对象，只是在编译期这个值并不存在</li><li><code>instanceMethods</code> : 分类上存储的实例方法</li><li><code>classMethods</code> ：分类上存储的类方法</li><li><code>protocols</code> ：分类所实现的协议</li><li><code>instanceProperties</code> ：分类所定义的实例属性，不过我们一般在分类中添加属性都是通过关联对象来实现的</li><li><code>_classProperties</code> ：分类所定义的类属性。这里有一行注释：<blockquote><p>Fields below this point are not always present on disk.<br>下面的内容并不是一直在磁盘上保存</p></blockquote></li></ul><p>也就是说 <code>_classProperties</code> 其实是一个私有属性，但并不是一直都存在的。</p><h1 id="三、分类的加载"><a href="#三、分类的加载" class="headerlink" title="三、分类的加载"></a>三、分类的加载</h1><p>我们现在知道了类分为了 <code>懒加载类</code> 和 <code>非懒加载类</code> ，它们的加载时机是不一样的，那么分类的加载又是怎么样的呢？我们还是同样的先分析没有实现 <code>load</code> 方法的分类的情况:</p><p>但是我们在分析前，还要搞清楚一点，分类必须依附于类而存在，如果只有分类，没有类，那么从逻辑上是说不通的，就算实现了，编译器也会忽略掉。而关于类是懒加载还是非懒加载的，所以这里我们还要再细分一次。</p><ul><li>懒加载分类与懒加载类</li><li>懒加载分类和非懒加载类</li></ul><h2 id="3-1-没有实现-load-的分类"><a href="#3-1-没有实现-load-的分类" class="headerlink" title="3.1 没有实现 load 的分类"></a>3.1 没有实现 load 的分类</h2><h3 id="3-1-1-与懒加载类配合加载"><a href="#3-1-1-与懒加载类配合加载" class="headerlink" title="3.1.1 与懒加载类配合加载"></a>3.1.1 与懒加载类配合加载</h3><p>我们先分析第一种情况，也就是类和分类都不实现 <code>load</code> 方法的情况。<br>首先，非懒加载类的流程上面我们已经探索过了，在向类<strong>第一次发送消息</strong>的时候，非懒加载类才会开始加载，而根据我们上一章类的加载探索内容，在 <code>realizeClassWithoutSwift</code> 方法的最后有一个 <code>methodizeClass</code> 方法，在这个方法里面会有一个 <code>Attach categories</code> 的地方：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121859.jpg" alt></p><p>但是我们断点之后发现这个时候通过 <code>unattachedCategoriesForClass</code> 方法并没有取到分类，我们此时不妨通过 <code>LLDB</code> 打印一下当前类里面是否已经把分类的内容附加上了。<br>前面的流程大家都很熟悉了，我们直接看 <code>cls</code> 的 <code>rw</code> 中的 <code>methods</code> 是否有内容：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121906.jpg" alt></p><p>此时 <code>LGTeacher</code> 类里面是没有方法的，这里读取 <code>rw</code> 却有一个结果，我们不难看出这是位于 <code>LGTeacher+test</code> 分类中的一个 <code>initialize</code> 方法，这个方法是我手动加个这个分类的。这样进一步证明了，如果是懒加载类，并且分类也是懒加载，那么分类的加载并不会来到 <code>unattachedCategoriesForClass</code> ，而是直接在编译时加载到了类的 <code>ro</code> 里面，然后在运行时被拷贝到了类的 <code>rw</code> 里面。这一点可以通过下面的 <code>LLDB</code> 打印来证明。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121919.jpg" alt></p><p>如果细心的读者可能会发现，不是在 <code>_read_images</code> 的最后那块有一个 <code>Discover categories</code> 吗，万一懒加载分类是在这里加载的呢？我们一试便知：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121925.jpg" alt></p><p>这里在 <code>Discover categories</code> 内部做了一下判断，如果是 <code>LGTeacher</code> 类进来了，就打印一下，结果发现并没有打印，说明分类也不是在这里被加载的。  </p><h3 id="3-1-2-与非懒加载类配合加载"><a href="#3-1-2-与非懒加载类配合加载" class="headerlink" title="3.1.2 与非懒加载类配合加载"></a>3.1.2 与非懒加载类配合加载</h3><p>   同样的道理，当类为非懒加载类的时候，走的是 <code>_read_images</code> 里面的流程，这个时候我们的懒加载分类是在哪加载的呢？ </p><p>我们直接在 <code>methodizeClass</code> 方法中打上断点，并做了一下简单的判断:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cname = ro-&gt;name;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *oname = <span class="string">"LGTeacher"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(cname, oname) == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"methodizeClass :%s \n"</span>,cname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果可以看到：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121934.jpg" alt></p><p>分类还是不在这，同时通过 <code>LLDB</code> 打印，发现分类的方法已经在类的 <code>ro</code> 里面了，所以说分类的加载其实跟类的懒加载与否并没有关系，也就是说懒加载的分类都是在编译时期被加载的。</p><h2 id="3-2-实现了-load-的分类"><a href="#3-2-实现了-load-的分类" class="headerlink" title="3.2 实现了 load 的分类"></a>3.2 实现了 load 的分类</h2><p>我们再接着分下下面两种情况：</p><ul><li>非懒加载分类与懒加载类</li><li>非懒加载分类和非懒加载类</li></ul><h3 id="3-2-1-与懒加载类配合加载"><a href="#3-2-1-与懒加载类配合加载" class="headerlink" title="3.2.1 与懒加载类配合加载"></a>3.2.1 与懒加载类配合加载</h3><p>其实懒加载和非懒加载的最大区别就是加载是否提前，而实现了 <code>+load</code> 方法的分类，面对的是懒加载的类，<br>而懒加载的类我们前面已经知道了，是在第一次发送消息的时候才会被加载的，那我们直接在<br><code>lookupImpOrForward</code>  =&gt; <code>realizeClassMaybeSwiftAndLeaveLocked</code> =&gt; <code>realizeClassMaybeSwiftMaybeRelock</code> =&gt; <code>realizeClassWithoutSwift</code> =&gt; <code>methodizeClass</code> 流程中的 <code>methodizeClass</code> 打上断点，看下在这里分类会不会被加载：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121942.jpg" alt></p><p>这一次通过 <code>unattachedCategoriesForClass</code> 取出来值了，并且在这之前 <code>cls</code> 的 <code>ro</code> 中并没有分类的 <code>initialize</code> 方法：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121949.jpg" alt></p><p>但是我们注意观察此时的调用堆栈：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121955.jpg" alt></p><p>为什么走的不是发送消息的流程，而走的是 <code>load_images</code> 里面的 <code>prepare_load_methods</code> 方法呢？我们来到 <code>prepare_load_methods</code> 方法处：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119122001.jpg" alt></p><p>可以看到，其实是在这里调用了 <code>realizeClassWithoutSwift</code> 方法来加载类的。而上面的 <code>_getObjc2NonlazyCategoryList</code> 方法显示就是获取的所有的非懒加载分类，然后遍历这些非懒加载分类，然后去加载这些分类所依赖的类。这个逻辑很好理解，非懒加载分类让我们的懒加载类实现提前了，所以说懒加载类<strong>并不一定</strong>只会在第一次消息发送的时候加载，还要取决于有没有非懒加载的分类，如果有非懒加载的分类，那么就走的是 <code>load_images</code> 里面的 <code>prepare_load_methods</code> 的 <code>realizeClassWithoutSwift</code> 。</p><h3 id="3-2-2-与非懒加载类配合加载"><a href="#3-2-2-与非懒加载类配合加载" class="headerlink" title="3.2.2 与非懒加载类配合加载"></a>3.2.2 与非懒加载类配合加载</h3><p>非懒加载类的流程我们也十分熟悉了，在 <code>_read_images</code> 里面进行加载，而此时，分类也是非懒加载。我们还是在 <code>methodizeClass</code> 里面进行断点：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119122009.jpg" alt></p><p>结果如上图所示，这次从 <code>unattachedCategoriesForClass</code> 方法取出来的是 <code>NULL</code> 值，显然分类不是在这个地方被加载的，我们回到 <code>_read_images</code> 方法，还记得那个 <code>Discover categories</code> 流程吗，我们打开里面的断点：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119122014.jpg" alt></p><p>因为当前类已经在前面的非懒加载类加载流程中被加载完成，所以这里会来到 <code>remethodizeClass</code> 方法，我们进入其内部实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remethodizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="keyword">bool</span> isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="literal">false</span><span class="comment">/*not realizing*/</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: attaching categories to class '%s' %s"</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        attachCategories(cls, cats, <span class="literal">true</span> <span class="comment">/*flush caches*/</span>);        </span><br><span class="line">        <span class="built_in">free</span>(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有一个 <code>attachCategories</code> 方法，断点也确实来到了这个地方， <code>attachCategories</code> 方法有一段注释:</p><blockquote><p>// Attach method lists and properties and protocols from categories to a class.<br>// Assumes the categories in cats are all loaded and sorted by load order,<br>// oldest categories first.</p><p>将分类的方法、属性和协议添加到类上<br>假设传入的分类列表都是按加载顺序加载完毕了<br>先加载的分类排在前面</p></blockquote><p>其实 <code>attachCategories</code> 这个方法只会在实现了 <code>load</code> 方法的分类下才会被调用，而来到 <code>attachCategories</code> 之前又取决于类是否为懒加载，如果是懒加载，那么就在 <code>load_images</code> 里面去处理，如果是非懒加载，那么就在 <code>map_images</code> 里面去处理。</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>我们今天探索的内容可能会有点绕，不过其实探索下来，我们只需要保持研究重点就很简单。分类的加载其实可以笼统的分为实现 <code>load</code> 方法和没有实现 <code>load</code> 方法：</p><ul><li>没有实现 <code>load</code> 方法的分类由编译时确定</li><li>实现了 <code>load</code> 方法的分类由运行时去确定</li></ul><p>这也说明分类的加载和类的加载是不一样的，而结合着类的懒加载与否，我们有以下的结论：</p><ul><li>懒加载分类 + 懒加载类</li></ul><blockquote><p>类的加载在<strong>第一次消息发送</strong>的时候，而分类的加载则在<strong>编译时</strong></p></blockquote><ul><li>懒加载分类 + 非懒加载类</li></ul><blockquote><p>类的加载在 <code>_read_images</code> 处，分类的加载还是在<strong>编译时</strong></p></blockquote><ul><li>非懒加载分类 + 懒加载类</li></ul><blockquote><p>类的加载在 <code>load_images</code> 内部，分类的加载在类加载之后的 <code>methodizeClass</code> </p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119122041.jpg" alt></p></blockquote><ul><li>非懒加载分类 + 非懒加载类<blockquote><p>类的加载在 <code>_read_images</code> 处，分类的加载在类加载之后的 <code>reMethodizeClass</code></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119122050.jpg" alt></p></blockquote></li></ul><p>分类的加载探索完了，我们下一章将探索类拓展和关联对象，敬请期待~</p><h1 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h1><p><a href="http://blog.sunnyxx.com/2014/03/05/objc_category_secret/" target="_blank" rel="noopener">objc category的秘密 - sunnyxx</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、初探懒加载类&quot;&gt;&lt;a href=&quot;#一、初探懒加载类&quot; class=&quot;headerlink&quot; title=&quot;一、初探懒加载类&quot;&gt;&lt;/a&gt;一、初探懒加载类&lt;/h1&gt;&lt;p&gt;上一章我们探索了 &lt;code&gt;iOS&lt;/code&gt; 中类的加载，让我们简单回顾一下大概的流程。&lt;/p&gt;
&lt;h2 id=&quot;1-1-类的加载回顾&quot;&gt;&lt;a href=&quot;#1-1-类的加载回顾&quot; class=&quot;headerlink&quot; title=&quot;1.1 类的加载回顾&quot;&gt;&lt;/a&gt;1.1 类的加载回顾&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;libObjc&lt;/code&gt; 向 &lt;code&gt;dyld&lt;/code&gt; 注册了回调 &lt;code&gt;_dyld_objc_notify_register&lt;/code&gt;，当 &lt;code&gt;dyld&lt;/code&gt; 把 &lt;code&gt;App&lt;/code&gt; 以及 &lt;code&gt;App&lt;/code&gt; 所依赖的一系列 &lt;code&gt;Mach-O&lt;/code&gt; 镜像加载到当前 &lt;code&gt;App&lt;/code&gt; 被分配的内存空间之后，&lt;code&gt;dyld&lt;/code&gt; 会通过 &lt;code&gt;_dyld_objc_notify_mapped&lt;/code&gt; 也就是 &lt;code&gt;map_images&lt;/code&gt; 来通知 &lt;code&gt;libObjc&lt;/code&gt; 来完成具体的加载工作，&lt;code&gt;map_images&lt;/code&gt; 被调用之后会来到 &lt;code&gt;_read_images&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_read_images&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;主要会进行类的加载工作，会插入 &lt;strong&gt;所有的类&lt;/strong&gt; 到 &lt;code&gt;gdb_objc_realized_classes&lt;/code&gt; 哈希表中（插入方式为 类名为 &lt;code&gt;key&lt;/code&gt;，类对象为&lt;code&gt;value&lt;/code&gt;, 不包括通过 &lt;em&gt;共享缓存&lt;/em&gt; 里面的类），同时还会把类插入到 &lt;code&gt;allocatedClasses&lt;/code&gt; 这个集合里面，注意，&lt;code&gt;allocatedClasses&lt;/code&gt; 的类型为 &lt;code&gt;NXHashTable&lt;/code&gt;，可以类比为 &lt;code&gt;NSSet&lt;/code&gt;，而 &lt;code&gt;gdb_objc_realized_classes&lt;/code&gt; 的类型为 &lt;code&gt;NXMapTable&lt;/code&gt;，可以类比为 &lt;code&gt;NSDictionary&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对所有的类进行重映射&lt;/li&gt;
&lt;li&gt;将所有的 &lt;code&gt;SEL&lt;/code&gt; 插入到 &lt;code&gt;namedSelectors&lt;/code&gt; 哈希表中(插入方式为：&lt;code&gt;SEL&lt;/code&gt; 名称为 &lt;code&gt;key&lt;/code&gt;，&lt;code&gt;SEL&lt;/code&gt; 为&lt;code&gt;value&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;修复函数指针遗留&lt;/li&gt;
&lt;li&gt;将所有的 &lt;code&gt;Protocol&lt;/code&gt; 插入到 &lt;code&gt;readProtocol&lt;/code&gt; 哈希表中(插入方式为：&lt;code&gt;Protocol&lt;/code&gt; 名称为 &lt;code&gt;key&lt;/code&gt;，&lt;code&gt;Protocol&lt;/code&gt; 为 &lt;code&gt;value&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;对所有的 &lt;code&gt;Protocol&lt;/code&gt; 做重映射&lt;/li&gt;
&lt;li&gt;初始化所有的&lt;strong&gt;非懒加载类&lt;/strong&gt;，包括 &lt;code&gt;rw&lt;/code&gt; 和 &lt;code&gt;ro&lt;/code&gt; 的初始化操作&lt;/li&gt;
&lt;li&gt;处理所有的分类(包括类的分类和元类的分类)
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - 类的加载</title>
    <link href="http://leejunhui.com/2020/01/11/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
    <id>http://leejunhui.com/2020/01/11/iOS-底层探索-类的加载/</id>
    <published>2020-01-10T16:20:05.000Z</published>
    <updated>2020-01-19T03:54:55.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、应用加载回顾"><a href="#一、应用加载回顾" class="headerlink" title="一、应用加载回顾"></a>一、应用加载回顾</h1><p>上一章我们对应用的加载有了初步的认识，我们知道了</p><ul><li>系统调用 <code>exec()</code> 会我们的应用<strong>映射</strong>到新的地址空间</li><li>然后通过 <code>dyld</code> 进行加载、链接、初始化主程序和主程序所依赖的各种动态库</li><li>最后在 <code>initializeMainExecutable</code> 方法中经过一系列初始化调用 <code>notifySingle</code> 函数，该函数会执行一个 <code>load_images</code> 的回调</li><li>然后在 <code>doModinitFuntions</code> 函数内部会调用 <code>__attribute__((constructor))</code> 的 <code>c</code> 函数</li><li>然后 <code>dyld</code> 返回主程序的入口函数，开始进入主程序的 <code>main</code> 函数<a id="more"></a>在 <code>main</code> 函数执行执行，其实 <code>dyld</code> 还会在流程中初始化 <code>libSystem</code>，而 <code>libSystem</code> 又会去初始化 <code>libDispatch</code>，在 <code>libDispatch</code> 初始化方法里面又会有一步 <code>_os_object_init</code>，在 <code>_os_object_init</code> 内部就会调起 <code>_objc_init</code>。而对于 <code>_objc_init</code> 我们还需要继续探索，因为这里面会进行类的加载等一系列重要的工作。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113501.jpg" alt></p><h1 id="二、探索-objc-init"><a href="#二、探索-objc-init" class="headerlink" title="二、探索 _objc_init"></a>二、探索 <code>_objc_init</code></h1><p>首先来到 <code>libObjc</code> 源码的 <code>_objc_init</code> 方法处，你可以直接添加一个符号断点 <code>_objc_init</code> 或者全局搜索关键字来到这里：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着进行分析:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113515.jpg" alt></p><ul><li>判断是否已经初始化了，如果初始化过了，直接返回。</li></ul><h2 id="2-1-environ-init"><a href="#2-1-environ-init" class="headerlink" title="2.1 environ_init"></a>2.1 environ_init</h2><p>接着来到 <code>environ_init</code> 方法内部:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113523.jpg" alt></p><p>我们可以看到，这里主要是读取影响 <code>Runtime</code> 的一些环境变量，如果需要，还可以打印环境变量帮助提示。</p><p>我们可以在终端上测试一下，直接输入 <code>export OBJC_HELP=1</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113531.jpg" alt></p><p>可以看到不同的环境变量对应的内容都被打印出来了。</p><h2 id="2-2-tls-init"><a href="#2-2-tls-init" class="headerlink" title="2.2 tls_init"></a>2.2 tls_init</h2><p>接着来到 <code>tls_init</code> 方法内部:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tls_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    _objc_pthread_key = TLS_DIRECT_KEY;</span><br><span class="line">    pthread_key_init_np(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _objc_pthread_key = tls_create(&amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里执行的是关于线程 <code>key</code> 的绑定，比如每线程数据的析构函数。</p><h2 id="2-3-static-init"><a href="#2-3-static-init" class="headerlink" title="2.3 static_init"></a>2.3 static_init</h2><p>接着来到 <code>static_init</code> 方法内部:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* static_init</span></span><br><span class="line"><span class="comment">* Run C++ static constructor functions.</span></span><br><span class="line"><span class="comment">* libc calls _objc_init() before dyld would call our static constructors, </span></span><br><span class="line"><span class="comment">* so we have to do it ourselves.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        inits[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会运行 <code>C++</code> 的静态构造函数，在 <code>dyld</code> 调用我们的静态构造函数之前，<code>libc</code> 会调用 <code>_objc_init</code>，所以这里我们必须自己来做，并且这里只会初始化系统内置的 <code>C++</code> 静态构造函数，我们自己代码里面写的并不会在这里初始化。</p><h2 id="2-4-lock-init"><a href="#2-4-lock-init" class="headerlink" title="2.4 lock_init"></a>2.4 lock_init</h2><p>接着来到 <code>lock_init</code> 方法内部:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这是一个空的实现。也就是说 <code>objc</code> 的锁是完全采用的 <code>C++</code> 那一套的锁逻辑。</p><h2 id="2-5-exception-init"><a href="#2-5-exception-init" class="headerlink" title="2.5 exception_init"></a>2.5 exception_init</h2><p>接着来到 <code>exception_init</code> 方法内部:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* exception_init</span></span><br><span class="line"><span class="comment">* Initialize libobjc's exception handling system.</span></span><br><span class="line"><span class="comment">* Called by map_images().</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exception_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    old_terminate = <span class="built_in">std</span>::set_terminate(&amp;_objc_terminate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是初始化 <code>libobjc</code> 的异常处理系统，我们程序触发的异常都会来到：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113552.jpg" alt></p><p>我们可以看到 <code>_objc_terminate</code> 是未处理异常的回调函数，其内部逻辑如下:</p><ul><li>检查是否是一个活跃的异常</li><li>如果是活跃的异常，检查是否是 <code>OC</code> 抛出的异常</li><li>如果是 <code>OC</code> 抛出的异常，调用 <code>uncaught_handeler</code> 回调函数指针</li><li>如果不是 <code>OC</code> 抛出的异常，则继续 <code>C++</code> 终止操作</li></ul><h2 id="2-6-dyld-objc-notify-register"><a href="#2-6-dyld-objc-notify-register" class="headerlink" title="2.6 _dyld_objc_notify_register"></a>2.6 _dyld_objc_notify_register</h2><p>接下来使我们今天探索的重点了： <code>_dyld_objc_notify_register</code> ，我们先看下它的定义:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113601.jpg" alt></p><blockquote><p>注意：仅供 <code>objc</code> 运行时使用<br>当 <code>objc</code> 镜像被<strong>映射（mapped）</strong>、<strong>卸载（unmapped）</strong>和<strong>初始化（initialized）</strong>的时候，注册的回调函数就会被调用。<br>这个方法是 <code>dlyd</code> 中声明的，一旦调用该方法，调用结果会作为该函数的参数回传回来。比如，当所有的 <code>images</code> 以及 <code>section</code> 为 <code>objc-image-info</code> 被加载之后会回调 <code>mapped</code> 方法。<br><code>load</code> 方法也将在这个方法中被调用。</p></blockquote><p><code>_dyld_objc_notify_register</code>  方法的三个参数 <code>map_images</code> 、 <code>load_images</code> 、 <code>unmap_image</code>  其实都是函数指针：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113615.jpg" alt></p><p>这三个函数指针是在 <code>dyld</code> 中回调的，我们打开 <code>dyld</code> 的源码即可一探究竟，我们直接搜索 <code>_dyld_objc_notify_register</code> :</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113626.jpg" alt></p><p>接着来到 <code>dyld</code> 的 <code>registerObjCNotifiers</code> 方法内部：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113634.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113641.jpg" alt></p><p>通过上面两张截图的内容说明在 <code>registerObjCNotifiers</code> 内部， <code>libObjc</code> 传过来的这三个函数指针被 <code>dyld</code> 保存在了本地静态变量中。换句话来说，最终函数指针是否能被调用，取决于这三个静态变量：</p><ul><li><code>sNotifyObjCMapped</code> </li><li><code>sNotifyObjCInit</code> </li><li><code>sNotifyObjCUnmapped</code> </li></ul><p>我们注意到 <code>registerObjCNotifiers</code> 的 <code>try-catch</code> 语句中的 <code>try</code> 分支注释如下：</p><blockquote><p>call ‘mapped’ function with all images mapped so far<br>调用 <code>mapped</code> 函数来映射所有的镜像</p></blockquote><p>那么也就是说 <code>notifyBatchPartial</code> 里面会进行真正的函数指针的调用，我们进入这个方法内部：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113650.jpg" alt></p><p>我们可以看到，在 <code>notifyBatchPartial</code> 方法内部，这里的注释:</p><blockquote><p>tell objc about new images 告诉 <code>objc</code> 镜像已经映射完成了</p></blockquote><p>而图中箭头所指的地方正是 <code>sNotifyObjCMapped</code> 函数指针真正调用的地方。</p><p>弄清楚了三个函数指针是怎么调用的还不够，接下来我们要深入各个函数的内部看里面究竟做了什么样的事情。</p><h1 id="三、探索-map-images"><a href="#三、探索-map-images" class="headerlink" title="三、探索 map_images"></a>三、探索 map_images</h1><p>首先是 <code>map_images</code> ，我们来到它的实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* map_images</span></span><br><span class="line"><span class="comment">* Process the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">* Calls ABI-agnostic code after taking ABI-specific locks.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;C</span><br></pre></td></tr></table></figure><blockquote><p>Process the given images which are being mapped in by dyld.<br>Calls ABI-agnostic code after taking ABI-specific locks.</p></blockquote><blockquote><p>处理由 <code>dyld</code> 映射的给定镜像<br>取得特定于 <code>ABI</code> 的锁后，调用与 <code>ABI</code> 无关的代码。</p></blockquote><p>这里会继续往下走到 <code>map_images_nolock</code> </p><p><code>map_images_nolock</code> 内部代码十分冗长，我们经过分析之后，前面的工作基本上都是进行镜像文件信息的提取与统计，所以可以定位到最后的 <code>_read_images</code> ：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113711.jpg" alt></p><blockquote><p>这里进入 <code>_read_images</code> 的条件是 <code>hCount</code> 大于 0， <code>hCount</code> 表示的是 <code>Mach-O</code> 中 <code>header</code> 的数量</p></blockquote><p>OK，我们的主角登场了， <code>_read_images</code> 和 <code>lookupImpOrForward</code> 可以说是我们学习 <code>Runtime</code> 和 <code>iOS</code> 底层里面非常重要的两个概念了， <code>lookUpImpOrForward</code> 已经探索过了，剩下的 <code>_read_images</code> 我们也不能落下。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113721.jpg" alt></p><h2 id="3-1-read-images-定义"><a href="#3-1-read-images-定义" class="headerlink" title="3.1 _read_images 定义"></a>3.1 _read_images 定义</h2><blockquote><p>Perform initial processing of the headers in the linked list beginning with headerList.<br>从 <code>headerList</code> 开始，对已经链接了的 <code>Mach-O</code> 镜像表中的头部进行初始化处理</p></blockquote><p>我们可以看到，整个 <code>_read_images</code> 有接近 400 行代码。我们不妨折叠一下里面的分支代码，然后总览一下：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113734.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113742.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113749.jpg" alt></p><p>通过折叠代码，以及日志打印提示信息，我们大致可以将 <code>_read_images</code> 分为下面几个流程:</p><h2 id="3-2-read-images-具体流程"><a href="#3-2-read-images-具体流程" class="headerlink" title="3.2 _read_images 具体流程"></a>3.2 _read_images 具体流程</h2><hr><p><strong>doneOnce 流程</strong></p><p>我们从第一个分支 <code>doneOnce</code> 开始，这个名词顾名思义，只会执行一次：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113811.jpg" alt></p><ul><li>通过宏 <code>SUPPORT_NONPOINTER_ISA</code> 判断当前是否支持开启内存优化的 <code>isa</code> <ul><li>如果支持，则在某些条件下需要禁用这个优化</li></ul></li><li>通过宏 <code>SUPPORT_INDEXED_ISA</code> 判断当前是否是将类存储在 <code>isa</code> 作为类表索引<ul><li>如果是的话，再递归遍历所有的 <code>Mach-O</code> 的头部，并且判断如果是 <code>Swift 3.0</code> 之前的代码，就需要禁用对 <code>isa</code> 的内存优化</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113824.jpg" alt></p><ul><li>通过宏 <code>TARGET_OS_OSX</code> 判断是否是 <code>macOS</code> 执行环境</li><li>判断 <code>macOS</code> 的系统版本，如果小于 <code>10.11</code> 则说明 <code>app</code> 太陈旧了，需要禁用掉 <code>non-pointer isa</code> </li><li>然后再遍历所有的 <code>Mach-O</code> 的头部，判断如果有 <code>__DATA__,__objc_rawisa</code> 段的存在，则禁用掉 <code>non-pointer isa</code> ，因为很多新的 <code>app</code> 加载老的扩展的时候会需要这样的判断操作。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113854.jpg" alt></p><blockquote><p>预先优化过的类不会加入到 <code>gdb_objc_realized_classes</code> 这个哈希表中来， <code>gdb_objc_realized_classes</code> 哈希表的装载因子为 0.75，这是一个经过验证的效率很高的扩容临界值。</p></blockquote><ul><li>加载所有类到类的 <code>gdb_objc_realized_classes</code> 表中来<br></li></ul><p>我们查看这个表的定义：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113952.jpg" alt></p><blockquote><p>// This is a misnomer: gdb_objc_realized_classes is actually a list of<br>// named classes not in the dyld shared cache, whether realized or not.</p></blockquote><blockquote><p>这是一个误称：gdb_objc_realized_classes 表实际上存储的是不在 <code>dyld</code> 共享缓存里面的命名类，无论这些类是否实现</p></blockquote><p>除了 <code>gdb_objc_realized_classes</code> 表之外，还有一张表 <code>allocatedClasses</code> :</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114000.jpg" alt></p><ul><li>通过 <code>objc_allocateClassPair</code> 开辟之后的类和元类存储的表（也就是说需要 <code>alloc</code> ）</li></ul><p>其实 <code>gdb_objc_realized_classes</code> 对 <code>allocatedClasses</code> 是一种包含的关系，一张是类的总表，一张是已经开辟了内存的类表，</p><hr><p><strong>Discover classes 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114029.jpg" alt></p><blockquote><p>Discover classes. Fix up unresolved future classes. Mark bundle classes.<br>发现类。修正未解析的 <code>future</code> 类，标记 <code>bundle</code> 类。</p></blockquote><ul><li>先通过 <code>_getObjc2ClassList</code> 来获取到所有的类，我们可以通过 <code>MachOView</code> 来验证：</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114038.jpg" alt></p><ul><li>接着还是遍历所有的 <code>Mach-O</code> 的 <code>header</code> 部分，然后通过 <code>mustReadClasses</code> 来判断哪些条件可以跳过读取类这一步骤</li><li>读取 <code>header</code> 是否是 <code>Bundle</code> </li><li>读取 <code>header</code> 是否开启了 <strong>预优化</strong></li><li>遍历 <code>_getObjc2ClassList</code> 取出的所有的类<ul><li>通过 <code>readClass</code> 来读取类信息</li><li>判断如果不相等并且 <code>readClass</code> 结果不为空，则需要重新为类开辟内存</li></ul></li></ul><hr><p><strong>Fix up remapped classes 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114058.jpg" alt></p><blockquote><p>修复 重映射类<br>类表和非懒加载类表没有被重映射 (也就是 <strong>_objc_classlist</strong>)<br>由于消息转发，类引用和父类引用会被重映射 (也就是 <strong>_objc_classrefs</strong>)</p></blockquote><ul><li>通过 <code>noClassesRemapped</code> 方法判断是否有类引用(<strong>_objc_classrefs</strong>)需要进行重映射<ul><li>如果需要，则遍历 <code>EACH_HEADER</code> </li><li>通过 <code>_getObjc2ClassRefs</code> 和 <code>_getObjc2SuperRefs</code> 取出当前遍历到的 <code>Mach-O</code> 的类引用和父类引用，然后调用 <code>remapClassRef</code> 进行重映射  </li></ul></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114114.jpg" alt></p><hr><p><strong>Fix up @selector references 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114341.jpg" alt></p><blockquote><p>修正 <code>SEL</code> 引用</p></blockquote><ul><li>操作前先加一个 <code>selLock</code> 锁</li><li>然后遍历 <code>EACH_HEADER</code> <ul><li>如果开启了<strong>预优化</strong>，contiue 到下一个 <code>Mach-O</code> </li><li>通过 <code>_getObjc2SelectorRefs</code> 拿到所有的 <code>SEL</code> 引用</li><li>然后对所有的 <code>SEL</code> 引用调用 <code>sel_registerNameNoLock</code> 进行注册</li></ul></li></ul><p>也就是说这一流程最主要的目的就是注册 <code>SEL</code> ，我们注册真正发生的地方: <code>__sel_registerName</code> ，这个函数如果大家经常玩 <code>Runtime</code> 肯定不会陌生：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114358.jpg" alt></p><p>我们简单分析一下 <code>__sel_registerName</code> 方法的流程：</p><ul><li>判断是否要加锁</li><li>如果 <code>sel</code> 为空，则返回一个空的 <code>SEL</code> </li><li>从 <code>builtins</code> 中搜索，看是否已经注册过，如果找到，直接返回结果</li><li>从 <code>namedSelectors</code> 哈希表中查询，找到了就返回结果</li><li>如果 <code>namedSelectors</code> 未初始化，则创建一下这个哈希表</li><li>如果上面的流程都没有找到，则需要调用 <code>sel_alloc</code> 来创建一下 <code>SEL</code> ，然后把新创建的 <code>SEL</code> 插入哈希表中进行缓存的填充</li></ul><hr><p><strong>Fix up old objc_msgSend_fixup call sites 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114428.jpg" alt></p><blockquote><p>修正旧的 <code>objc_msgSend_fixup</code> 调用</p></blockquote><p>这个流程的执行前提是 <code>FIXUP</code> 被开启。</p><ul><li>还是老套路，遍历 <code>EACH_HEADER</code> <ul><li>通过 <code>_getObjc2MessageRefs</code> 方法来获取当前遍历到的 <code>Mach-O</code> 镜像的所有消息引用</li><li>然后遍历这些消息引用，然后调用 <code>fixupMessageRef</code> 进行修正</li></ul></li></ul><hr><p><strong>Discover protocols 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114506.jpg" alt></p><blockquote><p>发现协议，并修正协议引用</p></blockquote><hr><p><strong>Fix up @protocol references 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114534.jpg" alt></p><blockquote><p>对所有的协议做重映射</p></blockquote><hr><p><strong>Realize non-lazy classes 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114757.jpg" alt></p><blockquote><p>初始化<strong>非懒加载类( **`</strong>+load<strong>` 方法和静态实例</strong>)**</p></blockquote><hr><p><strong>Realize newly-resolved future classes 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114821.jpg" alt></p><blockquote><p>初始化新解析出来的 <code>future</code> 类</p></blockquote><hr><p><strong>Discover categories 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114844.jpg" alt></p><blockquote><p><strong>处理所有的分类，包括类和元类</strong></p></blockquote><hr><p>到这里， <code>_read_images</code> 的流程就分析完毕，我们可以新建一个文件来去掉一些干扰的信息，只保留核心的逻辑，这样从宏观的角度来分析更直观:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114851.jpg" alt></p><blockquote><p>Q &amp; A 环节<br>Q： <code>dyld</code> 主要逻辑是加载库，也就是镜像文件，但是加载完是怎么读取的呢？<br>A： <code>_read_images</code> 是真正读取的地方</p><p>Q: <code>SEL</code> 方法编号何时加载？<br>A: <code>_read_images</code></p></blockquote><h2 id="3-3-read-class-分析"><a href="#3-3-read-class-分析" class="headerlink" title="3.3 read_class 分析"></a>3.3 read_class 分析</h2><p>我们探索了 <code>_read_images</code> 方法的流程，接下来让我们把目光放到本文的主题 - <strong>类的加载</strong><br>既然是类的加载，那么我们在前面所探索的类的结构中出现的内容都会一一重现。<br>所以我们不妨直接进行断点调试，让我们略过其它干扰信息，聚焦于类的加载。</p><ul><li>根据上一小节我们探索的结果， <code>doneOnce</code> 流程中会创建两个哈希表，并没有涉及到类的加载，所以我们跳过</li><li>我们来到第二个流程 - <strong>类处理</strong></li></ul><p><strong>我们在下图所示的位置处打上断点：</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114933.jpg" alt></p><p>如上图所示，从 <code>classList</code> 中取出的 <code>cls</code> 只是一个内存地址，我们尝试通过 <code>LLDB</code> 打印 <code>cls</code> 的 <code>class_rw_t</code> :</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114946.jpg" alt></p><p>可以看到 <code>cls</code> 的属性、方法、协议以及类名都为空，说明这里类并没有被真正加载完成，我们接着聚焦到 <code>read_class</code> 函数上面，我们进入其内部实现，我们大致浏览之后会定位到如下图所示的代码：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115011.jpg" alt></p><p>看起来类的信息在这里完成了加载，那么为了验证我们的猜想，直接断点调试一下但发现断点根本走不进来，原因在于这里的判断语句 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Class newCls = popFutureNamedClass(mangledName))</span><br></pre></td></tr></table></figure><p>判断当前传入的类的类名是否有 <code>future</code> 类的实现，但是我们刚才已经打印了，类名是空的，所以肯定不会执行这里。我们接着往下走：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115022.jpg" alt></p><ul><li>addNamedClass 内部其实是将 <code>cls</code>  插入到 <code>gdb_objc_realized_classes</code> 表 </li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115035.jpg" alt></p><ul><li>addclassTableEntry 内部是将 <code>cls</code> 插入到 <code>allocatedClasses</code> 表</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115044.jpg" alt></p><p>分析完 <code>read_class</code> ，我们回到 <code>_read_images</code> 方法</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115054.jpg" alt></p><p>我们可以看到 <code>read_class</code> 返回的 <code>newCls</code> 会进行一个判断，判断与传入 <code>read_class</code> 之前的 <code>cls</code> 是否相等，而在 <code>read_class</code> 内部只有一个地方对类的内容进行了改动，但是我们刚才测试了是进不去的，所以这个 <code>if</code> 里面的内容我们可以略过，也就是说 <code>resolvedFutureClasses</code> 的内容我们都可以暂时略过。</p><p>总结一下 <code>readClass</code> ：</p><ul><li>判断是不是要后期处理的类<ul><li>如果是的话，就取出后期处理的类，读取这个类的 <code>data()</code> 类设置 <code>ro/rw</code> </li></ul></li><li>addNamedClass 插入总表</li><li>addClassTableEntry 插入已开辟内存的类的表  </li></ul><h2 id="3-4-realizeClassWithoutSwift-分析"><a href="#3-4-realizeClassWithoutSwift-分析" class="headerlink" title="3.4 realizeClassWithoutSwift 分析"></a>3.4 realizeClassWithoutSwift 分析</h2><p>通过分析 <code>read_class</code> ，我们可以得知，类已经被注册到两个哈希表中去了，那么现在一切时机都已经成熟了。但是我们还是要略过像 <code>Fix up remapped classes</code> 、 <code>Fix up @selector references</code> 、 <code>fix up old objc_msgSend_fixup call sites</code> 、 <code>Discover protocols. Fix up protocol refs</code> 、 <code>Fix up @protocol references</code> ，因为我们的重点是类的加载，我们最终来到了 <code>Realize non-lazy classes (for +load methods and static instances)</code> ，略去无关信息之后，我们可以看到我们的<br>主角 <code>realizeClassWithoutSwift</code> 闪亮登场了：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115106.jpg" alt></p><p>从方法的名称以及方法注释我们可以知道， <code>realizeClassWithoutSwift</code> 是进行类的第一次初始化操作，包括分配读写数据也就是我们常说的 <code>rw</code> ，但是并不会进行任何的 <code>Swift</code> 端初始化。我们直接聚焦下面的代码：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115150.jpg" alt></p><ul><li>通过 <code>calloc</code> 开辟内存空间，返回一个新的 <code>rw</code> </li><li>把 <code>cls</code> 取出来的 <code>ro</code> 赋值给这个 <code>rw</code> </li><li>将 <code>rw</code> 设置到 <code>cls</code> 身上</li></ul><p>那么是不是说在这里 <code>rw</code> 就有值了呢，我们 <code>LLDB</code> 打印大法走起:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115158.jpg" alt></p><p>可以清楚地看到，此时 <code>rw</code> 还是为空，说明这里只是对 <code>rw</code> 进行了初始化，但是方法、属性、协议这些都没有被添加上。</p><p>我们接着往下走:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115206.jpg" alt></p><p>这里可以看到父类和元类都会递归调用 <code>realizeClassWithoutSwift</code> 来初始化各自的 <code>rw</code> 。为什么在类的加载操作里面要去加载类和元类呢？回忆一下类的结构，答案很简单，要保证 <code>superclass</code> 和 <code>isa</code> 的完整性，也就是保证类的完整性，</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115218.jpg" alt></p><p>上面的截图就是最好的证明，初始化完毕的父类和元类被赋值到了类的 <code>superclass</code> 和 <code>isa</code> 上面。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115226.jpg" alt></p><p>接着往下走可以看到，不光要把父类关联到类上面，还要让父类知道子类的存在。</p><p>最后一行代码是 <code>methodizeClass(cls)</code> ，注释显示的是 <code>attach categories</code> ，附加分类到类？我们进入其内部实现一探究竟。</p><p>在探索 <code>methodizeClass</code> 前，我们先总结一下 <code>realizeClassWithoutSwift</code> :</p><ul><li>读取 <code>class</code>  的 <code>data()</code> </li><li><code>ro/rw</code>  赋值</li><li>父类和元类实现<ul><li>supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass))</li><li>metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()))</li></ul></li><li>父类和元类归属关系<ul><li>cls-&gt;superclass = supercls</li><li>cls-&gt;initClassIsa(metacls)</li></ul></li><li>将当前类链接到其父类的子类列表 addSubclass(supercls, cls)</li></ul><h2 id="3-5-methodizeClass-分析"><a href="#3-5-methodizeClass-分析" class="headerlink" title="3.5 methodizeClass 分析"></a>3.5 methodizeClass 分析</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115239.jpg" alt></p><blockquote><p>对类的方法列表、协议列表和属性列表进行修正<br>附加 <code>category</code>  到类上面来</p></blockquote><p>我们直接往下面走：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Install methods and properties that the class implements itself.</span></span><br><span class="line"><span class="keyword">method_list_t</span> *<span class="built_in">list</span> = ro-&gt;baseMethods();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">    prepareMethodLists(cls, &amp;<span class="built_in">list</span>, <span class="number">1</span>, YES, isBundleClass(cls));</span><br><span class="line">    rw-&gt;methods.attachLists(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从 <code>ro</code> 中取出<strong>方法列表</strong>附加到 <code>rw</code> 上</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line"><span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">    rw-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从 <code>ro</code> 中取出<strong>属性列表</strong>附加到 <code>rw</code> 上</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line"><span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">    rw-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从 <code>ro</code> 中取出<strong>协议列表</strong>附加到 <code>rw</code> 上</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing*/</span>);</span><br><span class="line">attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*don't flush caches*/</span>);</span><br></pre></td></tr></table></figure><ul><li>从 <code>cls</code> 中取出未附加的分类进行附加操作</li></ul><p>我们可以看到，这里有一个操作叫 <code>attachLists</code> ，为什么方法、属性、协议都能调用这个方法呢？</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115313.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115322.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115327.jpg" alt></p><p>我们可以看到，方法、属性、协议的数据结构都是一个二维数组，我们深入 <code>attachLists</code> 方法内部实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;<span class="comment">//10</span></span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;<span class="comment">//4</span></span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;<span class="comment">// 10+4</span></span><br><span class="line">   </span><br><span class="line">        memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists,</span><br><span class="line">                oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">        <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">        List* oldList = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断要添加的数量是否为 0，如果为 0，直接返回</li><li>判断当前调用 <code>attachLists</code> 的 <code>list_array_tt</code> 二维数组有多个一维数组<ul><li>如果是，说明是<strong>多对多</strong>的关系</li><li>这里会通过 <code>realloc</code> 对容器进行重新分配，大小为原来的大小加上新增的大小</li><li>然后通过 <code>memmove</code> 把原来的数据移动到容器的末尾</li><li>最后把新的数据拷贝到容器的起始位置</li></ul></li><li>如果调用 <code>attachLists</code> 的 <code>list_array_tt</code> 二维数组为空且新增大小数目为 1，则直接取 <code>addedList</code> 的第一个 <code>list</code> 返回</li><li>如果当前调用 <code>attachLists</code> 的 <code>list_array_tt</code> 二维数组只有一个一维数组<ul><li>如果是，说明是<strong>一对多</strong>的关系</li><li>这里会通过 <code>realloc</code> 对容器进行重新分配，大小为原来的大小加上新增的大小</li><li>因为原来只有一个一维数组，所以直接赋值到新 <code>Array</code> 的最后一个位置</li><li>然后把新数据拷贝到容器的起始位置</li></ul></li></ul><h1 id="四、探索-load-images"><a href="#四、探索-load-images" class="headerlink" title="四、探索 load_images"></a>四、探索 load_images</h1><p>我们接着探索 <code>_dyld_objc_notify_register</code> 的第二个参数 <code>load_images</code> ，这个函数指针是在什么时候调用的呢，同样的，我们接着在 <code>dyld</code> 源码中搜索对应的函数指针 <code>sNotifyObjCInit</code> :</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115339.jpg" alt></p><p>可以看到，在 <code>notifySingle</code> 方法内部， <code>sNotifyObjCInit</code> 函数指针被调用了。根据我们上一篇文章探索 <code>dyld</code> 底层可以知道， <code>_load_images</code> 应该是对于每一个加载进来的 <code>Mach-O</code> 镜像都会递归调用一次。</p><p>我们来到 <code>libObjc</code> 源码中 <code>load_images</code> 的定义处:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115441.jpg" alt></p><blockquote><p>处理由 <code>dyld</code> 映射的给定镜像中的 <code>+load</code>  方法</p></blockquote><ul><li>判断是否有 <code>load</code> 方法，如果没有，直接返回</li><li>搜索 <code>load</code> 方法，具体实现通过 <code>prepare_load_methods</code> </li><li>调用 <code>load</code> 方法，具体实现通过 <code>call_load_methods</code> </li></ul><h2 id="4-1-prepare-load-methods-分析"><a href="#4-1-prepare-load-methods-分析" class="headerlink" title="4.1 prepare_load_methods 分析"></a>4.1 prepare_load_methods 分析</h2><p>从这个方法名称，我们猜测这里应该做的是 <code>load</code> 方法的一些预处理工作，让我们来到源码进行分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">classref_t</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Swift class extensions and categories on Swift "</span></span><br><span class="line">                        <span class="string">"classes are not allowed to have +load methods"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* prepare_load_methods</span></span><br><span class="line"><span class="comment">* Schedule +load for classes in this image, any un-+load-ed </span></span><br><span class="line"><span class="comment">* superclasses in other images, and any categories in this image.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="comment">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span></span><br><span class="line"><span class="comment">// cls must already be connected.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* add_class_to_loadable_list</span></span><br><span class="line"><span class="comment">* Class cls has just become connected. Schedule it for +load if</span></span><br><span class="line"><span class="comment">* it implements a +load method.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先通过 <code>_getObjc2NonlazyClassList</code> 获取所有已经加载进去的类列表</li><li>然后通过 <code>schedule_class_load</code> 遍历这些类<ul><li>递归调用遍历父类的 <code>load</code> 方法，确保父类的 <code>load</code> 方法顺序排在子类的前面</li><li>通过 <code>add_class_to_loadable_list</code> , 把类的 <code>load</code> 方法存在 <code>loadable_classes</code> 里面</li><li><img src="https://upload-images.jianshu.io/upload_images/95471-11cae8927cfdf166?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul></li><li>完成 <code>schedule_class_load</code> 之后，通过 <code>_getObjc2NonlazyCategoryList</code> 取出所有分类数据</li><li>然后遍历这些分类<ul><li>通过 <code>realizeClassWithoutSwift</code> 来防止类没有初始化，如果已经初始化了则不影响</li><li>通过 <code>add_category_to_loadable_list</code> ，加载分类中的 <code>load</code> 方法到 <code>loadable_categories</code> 里面</li><li><img src="https://upload-images.jianshu.io/upload_images/95471-74f44fde4b425ea7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul></li></ul><h2 id="4-2-call-load-methods-分析"><a href="#4-2-call-load-methods-分析" class="headerlink" title="4.2 call_load_methods 分析"></a>4.2 call_load_methods 分析</h2><p><br>通过名称我们可以知道 <code>call_load_methods</code> 应该就是 <code>load</code> 方法被调用的地方了。我们直接看源码：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>call_load_methods<br>调用类和类别中所有未决的 <code>+load</code> 方法<br>类里面 <code>+load</code> 方法是父类优先调用的<br>而在父类的 <code>+load</code> 之后才会调用分类的 <code>+load</code> 方法</p></blockquote><ul><li>通过 <code>objc_autoreleasePoolPush</code> 压栈一个自动释放池</li><li><code>do-while</code> 循环开始<ul><li>循环调用类的 <code>+load</code> 方法直到找不到为止</li><li>调用一次分类中的 <code>+load</code> 方法</li></ul></li><li>通过 <code>objc_autoreleasePoolPop</code> 出栈一个自动释放池</li></ul><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>至此， <code>_objc_init</code> 和 <code>_dyld_objc_notify_register</code> 我们就分析完了，我们对类的加载有了更细致的认知。 <code>iOS</code> 底层有时候探索起来确实很枯燥，但是如果能找到高效的方法以及明确自己的所探索的方向，会让自己从宏观上重新审视这门技术。是的，技术只是工具，我们不能被技术所绑架，我们要做到有的放矢的去探索，这样才能事半功倍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、应用加载回顾&quot;&gt;&lt;a href=&quot;#一、应用加载回顾&quot; class=&quot;headerlink&quot; title=&quot;一、应用加载回顾&quot;&gt;&lt;/a&gt;一、应用加载回顾&lt;/h1&gt;&lt;p&gt;上一章我们对应用的加载有了初步的认识，我们知道了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统调用 &lt;code&gt;exec()&lt;/code&gt; 会我们的应用&lt;strong&gt;映射&lt;/strong&gt;到新的地址空间&lt;/li&gt;
&lt;li&gt;然后通过 &lt;code&gt;dyld&lt;/code&gt; 进行加载、链接、初始化主程序和主程序所依赖的各种动态库&lt;/li&gt;
&lt;li&gt;最后在 &lt;code&gt;initializeMainExecutable&lt;/code&gt; 方法中经过一系列初始化调用 &lt;code&gt;notifySingle&lt;/code&gt; 函数，该函数会执行一个 &lt;code&gt;load_images&lt;/code&gt; 的回调&lt;/li&gt;
&lt;li&gt;然后在 &lt;code&gt;doModinitFuntions&lt;/code&gt; 函数内部会调用 &lt;code&gt;__attribute__((constructor))&lt;/code&gt; 的 &lt;code&gt;c&lt;/code&gt; 函数&lt;/li&gt;
&lt;li&gt;然后 &lt;code&gt;dyld&lt;/code&gt; 返回主程序的入口函数，开始进入主程序的 &lt;code&gt;main&lt;/code&gt; 函数
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - 应用加载</title>
    <link href="http://leejunhui.com/2020/01/10/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://leejunhui.com/2020/01/10/iOS-底层探索-应用加载/</id>
    <published>2020-01-09T16:45:45.000Z</published>
    <updated>2020-01-19T03:30:43.074Z</updated>
    
    <content type="html"><![CDATA[<p><code>App</code> 从被用户在主屏幕上点击之后就开启了它的生命周期，那么在这之中，究竟发生了什么呢?让我们从 <code>App</code> 启动开始探索。在探索之前，我们需要熟悉一些前导知识点。</p><a id="more"></a><h1 id="一、前导知识"><a href="#一、前导知识" class="headerlink" title="一、前导知识"></a>一、前导知识</h1><p>以下参考自 <code>WWDC 2016 Optimizing App Startup Time</code> ：</p><h2 id="1-1-Mach-O"><a href="#1-1-Mach-O" class="headerlink" title="1.1 Mach-O"></a>1.1 Mach-O</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104621.jpg" alt></p><blockquote><p>Mach-O is a bunch of file types for different run time executables.<br><code>Mach-O</code> 是 <code>iOS</code> 系统不同运行时期<strong>可执行的文件</strong>的文件类型统称。</p></blockquote><p>维基百科上关于 <code>Mach-O</code> 的描述：</p><blockquote><p>Mach-O 是 Mach object 文件格式的缩写，它是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。作为 a.out 格式的替代品，Mach-O 提供了更好的扩展性，并提升了符号表中信息的访问速度。<br>大多数基于 Mach 内核的操作系统都使用 Mach-O。NeXTSTEP、OS X 和 iOS 是使用这种格式作为本地可执行文件、库和对象代码的例子。</p></blockquote><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104635.jpg" alt></p><p><code>Mach-O</code> 有三种文件类型: <code>Executable</code>、<code>Dylib</code>、<code>Bundle</code></p><ul><li><code>Executable</code> 类型</li></ul><blockquote><p>So the first executable, that’s the main binary in an app, it’s also the main binary in an app extension.<br><code>executable</code> 是 <code>app</code> 的二进制主文件，同时也是 <code>app extension</code> 的二进制主文件</p></blockquote><p>我们一般可以在 <code>Xcode</code> 项目中的 <code>Products</code> 文件夹中找到它：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104647.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104653.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104659.jpg" alt></p><p>如上图箭头所示，<code>App加载流程</code> 就是我们 <code>App</code> 的二进制主文件。</p><ul><li><code>Dylib</code> 类型</li></ul><blockquote><p>A dylib is a dynamic library, on other platforms meet, you may know those as DSOs or DLLs.<br><code>dylib</code> 是动态库，在其他平台也叫 <code>DSO</code> 或者 <code>DLL</code>。</p></blockquote><p>对于接触 <code>iOS</code> 开发比较早的同学，可能知道我们在 <code>Xcode 7</code> 之前添加一些比如 <code>sqlite</code> 的库的时候，其后缀名为 <code>dylib</code>，而 <code>Xcode 7</code> 之后后缀名都改成了 <code>tbd</code>。</p><p>这里引用 <a href="https://stackoverflow.com/questions/31450690/why-xcode-7-shows-tbd-instead-of-dylib" target="_blank" rel="noopener">StackoverFlow</a> 上的一篇回答。</p><blockquote><p>So it appears that the .dylib file is the actual library of binary code that your project is using and is located in the /usr/lib/ directory on the user’s device. The .tbd file, on the other hand, is just a text file that is included in your project and serves as a link to the required .dylib binary. Since this text file is much smaller than the binary library, it makes the SDK’s download size smaller.<br>看起来 <code>.dylib</code> 文件是项目中真正使用到的二进制库文件，它位于用户设备上的 <code>/usr/lib</code> 目录下。而 <code>.tbd</code> 文件，只是位于你项目中的一个文本文件，它扮演的是链接到真正的 <code>.dylib</code> 二进制文件的角色。因为文本文件的大小远远小于二进制文件的大小，所以让 <code>Xcode 的</code>SDK` 的下载大小更小。</p></blockquote><p>这里再插一句，那么有动态库，肯定就有静态库，它们的区别是什么呢？</p><p>我们先梳理一下整个的编译过程。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104715.jpg" alt></p><p>当然，这个过程中间其实还设计到编译器前端的 <code>词法分析</code>、<code>语法分析</code>、<code>语义分析</code>、<code>优化</code> 等流程，我们在后面探索 <code>LLVM</code> 和 <code>Clang</code> 的时候会详细介绍。</p><p>回到刚才的话题，静态库和动态库的区别：</p><blockquote><p>Static frameworks are linked at <strong>compile time</strong>. Dynamic frameworks are linked <strong>at runtime</strong>.</p></blockquote><p>静态库和动态库都是编译好的二进制文件，只是用法不同。那为什么要分动态和静态库呢？</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104729.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104736.jpg" alt></p><p>通过上面两幅图我们可以知道：</p><ul><li>静态库表现为：在链接阶段会将汇编生成的目标文件与引用的库一起链接打包进可执行文件中。</li><li>动态库表现为：程序编译并不会链接到目标代码中，在程序可执行文件里面会保留对动态库的引用。其中，动态库分为动态链接库和动态加载库。<ul><li><strong>动态链接库</strong>：在没有被加载到内存的前提下，当可执行文件被加载，动态库也随着被加载到内存中。在 <code>Linked Framework and Libraries</code> 设置的一些 <code>share libraries</code>。【随着程序启动而启动】</li><li><strong>动态加载库</strong>：当需要的时候再使用 <code>dlopen</code> 等通过代码或者命令的方式来加载。【在程序启动之后】</li></ul></li><li><code>Bundle</code> 类型</li></ul><blockquote><p>Now a bundle’s a special kind of dylib that you cannot link against, all you can do is load it at run time by an dlopen and that’s used on a Mac OS for plug-ins.<br>现阶段 <code>Bundle</code> 是一种特殊类型的 <code>dylib</code>，你是无法对其进行链接的。你所能做的是在 <code>Runtime</code> 运行时去通过 <code>dlopen</code> 来加载它，它可以在 <code>macOS</code> 上用于插件。</p></blockquote><ul><li><code>Image</code> 和 <code>Framework</code></li></ul><blockquote><p>Image refers to any of these three types.<br>镜像文件包含了上述的三种文件类型</p></blockquote><blockquote><p>a framework is a dylib with a special directory structure around it to holds files needed by that dylib.<br>有很多东西都叫做 <code>Framework</code>，但在本文中，<code>Framework</code> 指的是一个 <code>dylib</code>，它周围有一个特殊的目录结构来保存该 <code>dylib</code> 所需的文件。</p></blockquote><h3 id="1-1-1-Mach-O-结构分析"><a href="#1-1-1-Mach-O-结构分析" class="headerlink" title="1.1.1 Mach-O 结构分析"></a>1.1.1 Mach-O 结构分析</h3><h4 id="1-1-1-1-segment-段"><a href="#1-1-1-1-segment-段" class="headerlink" title="1.1.1.1 segment 段"></a>1.1.1.1 segment 段</h4><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104753.jpg" alt></p><p><code>Mach-O</code> 镜像文件是由 <code>segments</code> 段组成的。</p><ul><li>段的名称为大写格式<br><br>所有的段都是 <code>page size</code> 的倍数。</li><li>arm64 上段大小为 <code>16</code> 字节</li><li>其它架构为 <code>4</code> 字节</li></ul><p>这里再普及一下<strong>虚拟内存</strong>和<strong>内存页</strong>的知识：</p><blockquote><p>具有 <code>VM</code> 机制的操作系统，会对每个运行的进程创建一个逻辑地址空间 <code>logical address space</code> 或者叫虚拟地址空间 <code>virtual address space</code>；该空间的大小由操作系统位数决定：<code>32</code> 位的操作系统，其逻辑地址空间的大小为 <code>4GB</code>，64位的操作系统为 <code>18 exabyes</code>（其计算方式是 <code>2^32</code> || <code>2^64</code>）。</p></blockquote><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104805.jpg" alt></p><blockquote><p>虚拟地址空间(或者逻辑地址空间)会被分为相同大小的块，这些块被称为内存页（page）。计算机处理器和它的内存管理单元（MMU - memory management uinit）维护着一张将程序的逻辑地址空间映射到物理地址上的分页表 <code>page table</code>。</p></blockquote><blockquote><p>在 <code>masOS</code> 和早版本的 <code>iOS</code> 中，分页的大小为 <code>4kB</code>。在之后的基于 <code>A7</code> 和 <code>A8</code> 的系统中，虚拟内存（<code>64</code> 位的地址空间）地址空间的分页大小变为了 <code>16KB</code>，而物理RAM上的内存分页大小仍然维持在 <code>4KB</code>；基于A9及之后的系统，虚拟内存和物理内存的分页都是<code>16KB</code>。</p></blockquote><h4 id="1-1-1-2-section"><a href="#1-1-1-2-section" class="headerlink" title="1.1.1.2 section"></a>1.1.1.2 section</h4><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104814.jpg" alt></p><p>在 <code>segment</code> 段内部还有许多的 <code>section</code> 区。<code>section</code> 名称为小写格式。</p><blockquote><p>But sections are really just a subrange of a segment, they don’t have any of the constraints of being page size, but they are non-overlapping.<br>但是 <code>sections</code> 节实际上只是一个 <code>segment</code> 段的子范围，它们没有页面大小的任何限制，但是它们是不重叠的。</p></blockquote><p>通过 <code>MachOView</code> 工具查看 <code>app</code> 的二进制可执行文件可以查看到:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104825.jpg" alt></p><h4 id="1-1-1-3-常见的-segments"><a href="#1-1-1-3-常见的-segments" class="headerlink" title="1.1.1.3 常见的 segments"></a>1.1.1.3 常见的 <code>segments</code></h4><ul><li><code>__TEXT</code>：代码段，包括头文件、代码和常量。只读不可修改</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104838.jpg" alt></p><ul><li><code>__DATA</code>：数据段，包括全局变量, 静态变量等。可读可写。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104849.jpg" alt></p><ul><li><code>__LINKEDIT</code>：如何加载程序, 包含了方法和变量的元数据（位置，偏移量），以及代码签名等信息。只读不可修改。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104902.jpg" alt></p><h3 id="1-1-2-Mach-O-Universal-Files"><a href="#1-1-2-Mach-O-Universal-Files" class="headerlink" title="1.1.2 Mach-O Universal Files"></a>1.1.2 Mach-O Universal Files</h3><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104912.jpg" alt></p><p><code>Mach-O</code> 通用文件，将多种架构的 <code>Mach-O</code> 文件合并而成。它通过 <code>header</code> 来记录不同架构在文件中的偏移量，<code>segement</code> 占多个分页，<code>header</code>占一页的空间。可能有人会觉得 <code>header</code> 单独占一页会浪费空间，但这有利于虚拟内存的实现。</p><h2 id="1-2-虚拟内存"><a href="#1-2-虚拟内存" class="headerlink" title="1.2 虚拟内存"></a>1.2 虚拟内存</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119105004.jpg" alt></p><p>虚拟内存是一层<strong>间接寻址</strong>。</p><p>虚拟内存解决的是管理所有进程使用<strong>物理 RAM</strong> 的问题。通过添加间接层来让每个进程使用<strong>逻辑地址空间</strong>，它可以映射到 RAM 上的某个物理页上。这种映射不是一对一的，逻辑地址可能映射不到 RAM 上，也可能有多个逻辑地址映射到同一个物理 RAM 上。</p><ul><li>针对第一种情况，当进程要存储逻辑地址内容时会触发 <code>page fault</code>。</li><li>而第二种情况就是多进程共享内存。</li><li>对于文件可以不用一次性读入整个文件，可以使用分页映射 <code>mmap()</code> 的方式读取。也就是把文件<strong>某个片段</strong>映射到进程逻辑内存的<strong>某个页</strong>上。当某个想要读取的页没有在内存中，就会触发 <code>page fault</code>，内核只会读入那一页，实现文件的<strong>懒加载</strong>。也就是说 <code>Mach-O</code> 文件中的 <code>__TEXT</code> 段可以映射到多个进程，并可以懒加载，且进程之间<strong>共享内存</strong>。</li><li><code>__DATA</code> 段是可读写的。这里使用到了 <code>Copy-On-Write</code> 技术，简称 <code>COW</code>。也就是多个进程共享一页内存空间时，一旦有进程要做写操作，它会先将这页内存内容<strong>复制</strong>一份出来，然后重新映射逻辑地址到新的 <code>RAM</code> 页上。也就是这个进程自己拥有了那页内存的拷贝。这就涉及到了 <code>clean/dirty page</code> 的概念。<code>dirty page</code> 含有进程自己的信息，而 <code>clean page</code> 可以被内核重新生成（重新读磁盘）。所以 <code>dirty page</code> 的代价大于 <code>clean page</code>。</li></ul><h2 id="1-3-多进程加载-Mach-O-镜像"><a href="#1-3-多进程加载-Mach-O-镜像" class="headerlink" title="1.3 多进程加载 Mach-O 镜像"></a>1.3 多进程加载 Mach-O 镜像</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119105025.jpg" alt></p><ul><li>所以在多个进程加载 <code>Mach-O</code> 镜像时 <code>__TEXT</code> 和 <code>__LINKEDIT</code> 因为只读，都是可以共享内存的，读取速度就会很快。</li><li>而 <code>__DATA</code> 因为可读写，就有可能会产生 <code>dirty page</code>，如果检测到有 <code>clean page</code> 就可以直接使用，反之就需要重新读取 <code>DATA page</code>。一旦产生了 <code>dirty page</code>，当 <code>dyld</code> 执行结束后，<code>__LINKEDIT</code> 需要通知内核当前页面不再需要了，当别人需要的使用时候就可以重新 <code>clean</code> 这些页面。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119105037.jpg" alt></p><h2 id="1-4-ASLR"><a href="#1-4-ASLR" class="headerlink" title="1.4 ASLR"></a>1.4 ASLR</h2><p><code>ASLR</code> (Address Space Layout Randomization) 地址空间布局随机化，镜像会在随机的地址上加载。</p><h2 id="1-5-Code-Signing"><a href="#1-5-Code-Signing" class="headerlink" title="1.5 Code Signing"></a>1.5 Code Signing</h2><p>可能我们认为 <code>Xcode</code> 会把整个文件都做加密 <code>hash</code> 并用做数字签名。其实为了在运行时验证 <code>Mach-O</code> 文件的签名，并不是每次重复读入整个文件，而是把每页内容都生成一个单独的加密散列值，并存储在 <code>__LINKEDIT</code> 中。这使得文件每页的内容都能及时被校验确并保不被篡改。</p><h2 id="1-6-exec"><a href="#1-6-exec" class="headerlink" title="1.6 exec()"></a>1.6 <code>exec()</code></h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119105102.jpg" alt></p><blockquote><p>Exec is a system call. When you trap into the kernel, you basically say I want to replace this process with this new program.</p></blockquote><blockquote><p><code>exec()</code> 是一个系统调用。系统内核把应用映射到新的地址空间，且每次起始位置都是随机的（因为使用 <code>ASLR</code>）。并将起始位置到 <code>0x000000</code> 这段范围的进程权限都标记为不可读写不可执行。如果是 <code>32</code> 位进程，这个范围至少是 <code>4KB</code>；对于 <code>64</code> 位进程则至少是 <code>4GB</code> 。<code>NULL</code> 指针引用和指针截断误差都是会被它捕获。这个范围也叫做 <code>PAGEZERO</code>。</p></blockquote><h2 id="1-7-dyld"><a href="#1-7-dyld" class="headerlink" title="1.7 dyld"></a>1.7 dyld</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111212.jpg" alt></p><blockquote><p>Unix 的前二十年很安逸，因为那时还没有发明动态链接库。有了动态链接库后，一个用于加载链接库的帮助程序被创建。在苹果的平台里是 <code>dyld</code>，其他 <code>Unix</code> 系统也有 <code>ld.so</code>。 当内核完成映射进程的工作后会将名字为 <code>dyld</code> 的 <code>Mach-O</code> 文件映射到进程中的随机地址，它将 <code>PC</code> 寄存器设为 <code>dyld</code> 的地址并运行。<code>dyld</code> 在应用进程中运行的工作是加载应用依赖的所有动态链接库，准备好运行所需的一切，它拥有的权限跟应用一样。</p></blockquote><h2 id="1-8-dyld-流程"><a href="#1-8-dyld-流程" class="headerlink" title="1.8 dyld 流程"></a>1.8 dyld 流程</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111227.jpg" alt></p><ul><li>Load dylibs</li></ul><blockquote><p>从主执行文件的 <code>header</code> 获取到需要加载的所依赖动态库列表，而 <code>header</code> 早就被内核映射过。然后它需要找到每个 <code>dylib</code>，然后打开文件读取文件起始位置，确保它是 <code>Mach-O</code> 文件。接着会找到代码签名并将其注册到内核。然后在 <code>dylib</code> 文件的每个 <code>segment</code> 上调用 <code>mmap()</code>。应用所依赖的 <code>dylib</code> 文件可能会再依赖其他 <code>dylib</code>，所以 <code>dyld</code> 所需要加载的是动态库列表一个递归依赖的集合。一般应用会加载 <code>100</code> 到 <code>400</code> 个 <code>dylib</code> 文件，但大部分都是系统 <code>dylib</code>，它们会被预先计算和缓存起来，加载速度很快。</p></blockquote><ul><li>Fix-ups</li></ul><blockquote><p>在加载所有的动态链接库之后，它们只是处在相互独立的状态，需要将它们<strong>绑定</strong>起来，这就是 <code>Fix-ups</code>。代码签名使得我们不能修改指令，那样就不能让一个 <code>dylib</code> 的调用另一个 <code>dylib</code>。这时需要加很多间接层。<br>现代 <code>code-gen</code> 被叫做动态 <strong>PIC（Position Independent Code）</strong>，意味着代码可以被加载到间接的地址上。当调用发生时，<code>code-gen</code> 实际上会在 <code>__DATA</code> 段中创建一个指向被调用者的指针，然后加载指针并跳转过去。所以 <code>dyld</code> 做的事情就是修正（<code>fix-up</code>）指针和数据。<code>Fix-up</code> 有两种类型，<code>rebasing</code> 和 <code>binding</code>。</p></blockquote><ul><li>Rebasing 和 Binding</li></ul><blockquote><p>Rebasing：在镜像内部<strong>调整</strong>指针的指向<br>Binding：将指针<strong>指向镜像外部</strong>的内容</p></blockquote><p><code>dyld</code> 的时间线由上图可知为：</p><p>Load dylibs -&gt; Rebase -&gt; Bind -&gt; ObjC -&gt; Initializers</p><h2 id="1-9-dyld2-amp-amp-dyld3"><a href="#1-9-dyld2-amp-amp-dyld3" class="headerlink" title="1.9 dyld2 &amp;&amp; dyld3"></a>1.9 dyld2 &amp;&amp; dyld3</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111245.jpg" alt></p><p>在 <code>iOS 13</code> 之前，所有的第三方 <code>App</code> 都是通过 <code>dyld 2</code> 来启动 <code>App</code> 的，主要过程如下：</p><ul><li>解析 <code>Mach-O</code> 的 <code>Header</code> 和 <code>Load Commands</code>，找到其依赖的库，并递归找到所有依赖的库</li><li>加载 <code>Mach-O</code> 文件</li><li>进行符号查找</li><li>绑定和变基</li><li>运行初始化程序</li></ul><p><code>dyld3</code> 被分为了<strong>三个组件</strong>：</p><ul><li>一个进程外的 <code>MachO</code> 解析器<ul><li>预先处理了所有可能影响启动速度的 <code>search path</code>、<code>@rpaths</code> 和环境变量</li><li>然后分析 <code>Mach-O</code> 的 <code>Header</code> 和依赖，并完成了所有符号查找的工作</li><li>最后将这些结果创建成了一个启动闭包</li><li>这是一个普通的 <code>daemon</code> 进程，可以使用通常的测试架构</li></ul></li><li>一个进程内的引擎，用来运行启动闭包<ul><li>这部分在进程中处理</li><li>验证启动闭包的安全性，然后映射到 <code>dylib</code> 之中，再跳转到 <code>main</code> 函数</li><li>不需要解析 <code>Mach-O</code> 的 <code>Header</code> 和依赖，也不需要符号查找。</li></ul></li><li>一个启动闭包缓存服务<ul><li>系统 <code>App</code> 的启动闭包被构建在一个 <code>Shared Cache</code> 中， 我们甚至不需要打开一个单独的文件</li><li>对于第三方的 <code>App</code>，我们会在 <code>App</code> 安装或者升级的时候构建这个启动闭包。</li><li>在 <code>iOS</code>、<code>tvOS</code>、<code>watchOS</code>中，这这一切都是 <code>App</code> 启动之前完成的。在 <code>macOS</code> 上，由于有 <code>Side Load App</code>，进程内引擎会在首次启动的时候启动一个 <code>daemon</code> 进程，之后就可以使用启动闭包启动了。</li></ul></li></ul><p>dyld 3 把很多耗时的查找、计算和 <code>I/O</code> 的事前都预先处理好了，这使得启动速度有了很大的提升。</p><p>好了，先导知识就总结到这里，接下来让我们调整呼吸进入下一章~</p><h1 id="二、App-加载分析"><a href="#二、App-加载分析" class="headerlink" title="二、App 加载分析"></a>二、App 加载分析</h1><p>我们在探索 <code>iOS</code> 底层的时候，对于对象、类、方法有了一定的认知哦，接下来我们就一起来探索一下应用是怎么加载的。</p><p>我们直接新建一个 <code>Single View App</code> 的项目，然后在 <code>main.m</code> 中打一个断点:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111300.jpg" alt></p><p>然后我们可以看到在 <code>main</code> 方法执行前有一步 <code>start</code>，而这一流程是由 <code>libdyld.dylib</code> 这个动态库来执行的。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111305.jpg" alt></p><p>这个现象说明了什么呢？说明我们的 <code>app</code> 在 <code>main</code> 函数执行之前其实还通过 <code>dyld</code> 做了很多事情。那为了搞清楚具体的流程，我们不妨从 <a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">Apple OpenSource</a> 上下载 <code>dyld</code> 的源码来进行探索。</p><p>我们选择最新的 <code>655.1.1</code> 版本：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111329.jpg" alt></p><h1 id="三、dyld-源码分析"><a href="#三、dyld-源码分析" class="headerlink" title="三、dyld 源码分析"></a>三、<code>dyld</code> 源码分析</h1><p>面对 <code>dyld</code> 的源码，我们不可能一行一行的去分析。我们不妨在刚才创建的项目中断点一下 <code>load</code> 方法，看下调用堆栈:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111343.jpg" alt></p><p>这一次我们发现，<code>load</code> 方法的调用要早于 <code>main</code> 函数的调用，其次，我们得到了一个非常有价值的线索: <code>_dyld_start</code>。</p><h2 id="3-1-dyld-start"><a href="#3-1-dyld-start" class="headerlink" title="3.1 _dyld_start"></a>3.1 _dyld_start</h2><p>我们直接在 <code>dyld 655.1.1</code> 中全局搜索这个 <code>_dyld_start</code>，我们可以来到 <code>dyldStartup.s</code> 这个汇编文件，然后我们聚焦于 <code>arm64</code> 架构下的汇编代码:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111418.jpg" alt></p><p>对于这里的汇编代码，我们肯定也没必要逐行分析，我们直接定位到 <code>bl</code> 语句后面(<code>bl</code> 在汇编层面是跳转的意思)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bl__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm</span><br></pre></td></tr></table></figure><p>我们可以看到这里有一行注释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)</span><br></pre></td></tr></table></figure><p>这行注释的意思是调用位于 <code>dyldbootstrap</code> 命名空间下的 <code>start</code> 方法，我们继续搜索一下这个 <code>start</code> 方法，结果位于 <code>dyldInitialization.cpp</code> 文件(从文件名我们可以看出该文件主要是用来初始化 <code>dyld</code>)，这里查找 <code>start</code> 的时候可能会有很多结果，我们其实可以先搜索命名空间，再搜索 <code>start</code> 方法。</p><h2 id="3-2-dyldbootstrap-start"><a href="#3-2-dyldbootstrap-start" class="headerlink" title="3.2 dyldbootstrap::start"></a>3.2 dyldbootstrap::start</h2><p><code>start</code> 方法源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</span></span><br><span class="line"><span class="comment">//  In dyld we have to do this manually.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">uintptr_t</span> start(<span class="keyword">const</span> struct macho_header* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], </span><br><span class="line"><span class="keyword">intptr_t</span> slide, <span class="keyword">const</span> struct macho_header* dyldsMachHeader,</span><br><span class="line"><span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class="line"><span class="comment">// we have to do this before using any global variables</span></span><br><span class="line">    slide = slideOfMainExecutable(dyldsMachHeader);</span><br><span class="line">    <span class="keyword">bool</span> shouldRebase = slide != <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(ptrauth_calls)</span></span><br><span class="line">    shouldRebase = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> ( shouldRebase ) &#123;</span><br><span class="line">        rebaseDyld(dyldsMachHeader, slide);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// allow dyld to use mach messaging</span></span><br><span class="line">mach_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line"><span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">++apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up random value for stack canary</span></span><br><span class="line">__guard_setup(apple);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line"><span class="comment">// run all C++ initializers inside dyld</span></span><br><span class="line">runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// now that we are done bootstrapping dyld, call dyld's main</span></span><br><span class="line"><span class="keyword">uintptr_t</span> appsSlide = slideOfMainExecutable(appsMachHeader);</span><br><span class="line"><span class="keyword">return</span> dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们刚才探索到了 <code>start</code> 方法，具体流程如下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111440.jpg" alt></p><ul><li>根据 <code>dyld</code> 的 <code>Mach-O</code> 文件的 <code>header</code> 判断是否需要对 <code>dyld</code> 这个 <code>Mach-O</code> 进行 <code>rebase</code> 操作</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111448.jpg" alt></p><ul><li>初始化 <code>mach</code>，使得 <code>dyld</code> 可以进行 <code>mach</code> 通讯。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111504.jpg" alt></p><ul><li>内核将 <code>env</code> 指针设置为刚好超出 <code>agv</code> 数组的末尾；内核将 <code>apple</code> 指针设置为刚好超出 <code>envp</code> 数组的末尾</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111511.jpg" alt></p><ul><li>栈溢出保护</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111519.jpg" alt></p><ul><li>读取 <code>app</code> 主二进制文件 <code>Mach-O</code> 的 <code>header</code> 来得到偏移量 <code>appSlide</code>，然后调用 <code>dyld</code> 命名空间下的 <code>_main</code> 方法。</li></ul><h2 id="3-3-dyldbootstrap-main"><a href="#3-3-dyldbootstrap-main" class="headerlink" title="3.3 dyldbootstrap::_main"></a>3.3 dyldbootstrap::_main</h2><p>我们通过搜索来到 <code>dyld.cpp</code> 文件下的 <code>_main</code> 方法：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111542.jpg" alt></p><p><code>_main方法</code> 官方的注释如下：</p><blockquote><p><code>dyld</code> 的入口。内核加载了 <code>dyld</code> 然后跳转到 <code>__dyld_start</code> 来设置一些寄存器的值然后调用到了这个方法。<br>返回 <code>__dyld_start</code> 所跳转到的目标程序的 <code>main</code> 函数地址。</p></blockquote><p>我们乍一看，这个方法有四五百行，所以我们不能老老实实的一行一行来看，这样太累了。我们应该着重于有注释的地方。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111551.jpg" alt></p><ul><li>我们首先可以看到这里是从环境变量中获取主要可执行文件的 <code>cdHash</code> 值。这个哈希值 <code>mainExecutableCDHash</code> 在后面用来校验 <code>dyld3</code> 的启动闭包。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111601.jpg" alt></p><ul><li>上图代码作用是追踪 <code>dyld</code> 的加载。然后判断当前是否为模拟器环境，如果不是模拟器，则追踪主二进制可执行文件的加载。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111608.jpg" alt></p><ul><li>显示宏定义判断是否为 <code>macOS</code> 执行环境，如果是则判断 <code>DYLD_ROOT_PATH</code> 环境变量是否存在，如果存在，然后判断模拟器是否有自己的 <code>dyld</code>，如果有就使用，如果没有，则返回错误信息。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111647.jpg" alt></p><ul><li>打印日志：<code>dyld 启动开始</code></li><li>根据传入 <code>dyldbootstrap::_main</code> 方法的参数来设置上下文</li><li>拾取指向 <code>exec</code> 路径的指针</li><li>从 <code>dyl</code> d移除临时 <code>apple [0]</code> 过渡代码</li><li>判断 <code>exec</code> 路径是否为绝对路径，如果为相对路径，使用 <code>cwd</code> 转化为绝对路径</li><li>为了后续的日志打印从 <code>exec</code> 路径中取出进程的名称 (<code>strrchr</code> 函数是获取第二个参数出现的最后的一个位置，然后返回从这个位置开始到结束的内容)</li><li>根据 <code>App</code> 主二进制可执行文件 <code>Mach-O</code> 的 <code>Header</code> 的内容配置进程的一些限制条件</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111938.jpg" alt></p><ul><li>判断是否为 <code>macOS</code> 执行环境，如果是的话，再判断上下文的一些配置属性是否被设置了，如果没有被设置，则再次进行一次 <code>setContext</code> 上下文配置操作。</li><li>根据传入的参数 <code>envp</code> 检查环境变量</li><li>默认未初始化的后备路径</li><li>判断是否为 <code>macOS</code> 执行环境，如果是的话，再判断当前 <code>app</code> 的 <code>Mach-O</code> 可执行文件是否为 <code>iOSMac</code> 类型且不为 <code>macOS</code> 类型的话，则重置上下文的根路径，然后再判断 <code>DYLD_FALLBACK_LIBRARY_PATH</code> 和 <code>DYLD_FALLBACK_FRAMEWORK_PATH</code> 这两个环境变量是否都是默认后备路径，如果是的话赋值为受限的后备路径。<br></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111950.jpg" alt></p><ul><li>根据环境变量 <code>DYLD_PRINT_OPTS</code> 和 <code>DYLD_PRINT_ENV</code> 来判断是否需要打印</li><li>通过当前 <code>app</code> 的 <code>Mach-O</code> 可执行文件的 <code>header</code> 和 <code>ASLR</code> 之后的偏移量来获取架构信息。在这里会判断如果是 <code>GC</code> 的程序则会禁用掉共享缓存。<br></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112001.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112010.jpg" alt></p><ul><li>判断共享缓存是否开启，如果开启了就将共享缓存映射到当前进程的逻辑内存空间内</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112047.jpg" alt></p><ul><li>检查共享缓存这里会先判断 <code>app</code> 的 <code>Mach-O</code> 二进制可执行文件是否有段覆盖了共享缓存区域，如果覆盖了则禁用共享缓存。但是这里的前提是 <code>macOS</code>，在 <code>iOS</code> 中，共享缓存是必需的。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112057.jpg" alt></p><blockquote><p>这里为了方便查看，我们可以折叠一些分支条件。</p></blockquote><ul><li>通过共享缓存中的头的版本信息来判断是走 <code>dyld 2</code> 还是 <code>dyld 3</code> 的流程</li></ul><h2 id="3-4-dyld3-的处理"><a href="#3-4-dyld3-的处理" class="headerlink" title="3.4 dyld3 的处理"></a>3.4 dyld3 的处理</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112122.jpg" alt></p><ul><li>由于 <code>dyld3</code> 会创建一个启动闭包<img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112105.jpg" alt><br>，我们需要来读取它，这里会现在缓存中查找是否有启动闭包的存在，前面我们已经说过了，系统级的 <code>app</code> 的启动闭包是存在于共享缓存中，而我们自己开发的 <code>app</code> 的启动闭包是在 <code>app</code> 安装或者升级的时候构建的，所以这里检查 <code>dyld</code> 中的缓存是有意义的。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112229.jpg" alt></p><ul><li>宏定义判断代码执行条件为真机。</li><li>如果 <code>dyld</code> 缓存中没有找到启动闭包或者找到了启动闭包但是验证失败（我们最开始提到的 <code>cdHash</code> 在这里出现了）<ul><li>从启动闭包缓存中查找<ul><li>如果还是没有找到，那就创建一个新的启动闭包</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112240.jpg" alt></p><ul><li>打印日志信息：<code>dyld3 启动开始</code></li><li>尝试通过启动闭包进行启动<ul><li>如果启动失败，则创建一个新的启动闭包尝试再次启动</li><li>如果启动成功，由于 <code>start()</code> 是以函数指针的方式调用 <code>_main</code> 方法的返回的指针，需要进行签名。</li></ul></li></ul><p>至此，<code>dyld3</code> 的流程就处理完毕，我们再接着往下分析 <code>dyld2</code> 的流程。</p><h2 id="3-5-dyld2-的处理"><a href="#3-5-dyld2-的处理" class="headerlink" title="3.5 dyld2 的处理"></a>3.5 dyld2 的处理</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112254.jpg" alt></p><ul><li>这里会添加 <code>dyld</code> 的镜像文件到 <code>UUID</code> 列表中，主要的目的是启用堆栈的符号化。<br></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112300.jpg" alt></p><hr><p><strong>reloadAllImages</strong></p><blockquote><p><code>ImageLoader</code> 是一个用于加载可执行文件的基类，它负责链接镜像，但不关心具体文件格式，因为这些都交给子类去实现。每个可执行文件都会对应一个 <code>ImageLoader</code>实例。<code>ImageLoaderMachO</code> 是用于加载 <code>Mach-O</code> 格式文件的 <code>ImageLoader</code> 子类，而 <code>ImageLoaderMachOClassic</code> 和 <code>ImageLoaderMachOCompressed</code> 都继承于 <code>ImageLoaderMachO</code>，分别用于加载那些 <code>__LINKEDIT</code> 段为传统格式和压缩格式的 <code>Mach-O</code> 文件。</p></blockquote><p>接下来就来到重头戏了 <code>reloadAllImages</code> 了：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112310.jpg" alt></p><hr><p><strong>实例化主程序</strong></p><p>这里我们看到有一行代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br></pre></td></tr></table></figure><p>显然，在这里我们的主程序被实例化了，我们进入这个方法内部：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112334.jpg" alt></p><p>这里相当于要为已经映射到主可执行文件中的文件创建一个 <code>ImageLoader*</code>。</p><p>从上面代码我们不难看出这里真正执行的逻辑是 <code>ImageLoaderMachO::instantiateMainExecutable</code> 方法：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112344.jpg" alt></p><p>我们再进入 <code>sniiffLoadCommands</code> 方法内部：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112354.jpg" alt></p><p>通过注释不难看出：<code>sniiffLoadCommands</code> 会确定此 <code>mach-o</code> 文件是否具有原始的或压缩的 <code>LINKEDIT</code> 以及 <code>mach-o</code> 文件的 <code>segement</code> 的个数。</p><p><code>sniiffLoadCommands</code> 完成后，判断 <code>LINKEDIT</code> 是压缩的格式还是传统格式，然后分别调用对应的 <code>instantiateMainExecutable</code> 方法来实例化主程序。</p><hr><p><strong>加载任何插入的动态库</strong><br></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112524.jpg" alt></p><hr><p><strong>链接库</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112533.jpg" alt></p><p>先是链接主二进制可执行文件，然后链接任何插入的动态库。这里都用到了 <code>link</code> 方法，在这个方法内部会执行递归的 <code>rebase</code> 操作来修正 <code>ASLR</code> 偏移量问题。同时还会有一个 <code>recursiveApplyInterposing</code> 方法来递归的将动态加载的镜像文件插入。</p><hr><p><strong>运行所有初始化程序</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112542.jpg" alt></p><p>完成链接之后需要进行初始化了，这里会来到 <code>initializeMainExecutable</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112548.jpg" alt></p><p>这里注意执行顺序：</p><ul><li>先为所有插入并链接完成的动态库执行初始化操作</li><li>然后再为主程序可执行文件执行初始化操作</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112555.jpg" alt></p><p>在 <code>runInitializers</code> 内部我们继续探索到 <code>processInitializers</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112602.jpg" alt></p><p>然后我们来到 <code>recursiveInitialization</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112609.jpg" alt></p><p>然后我们来到 <code>notifySingle</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112617.jpg" alt></p><p>箭头所示的地方是获取镜像文件的真实地址。</p><p>我们全局搜索一下 <code>sNotifyObjcInit</code> 可以来到 <code>registerObjCNotifiers</code>：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112623.jpg" alt></p><p>接着搜索 <code>registerObjCNotifiers</code>：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112630.jpg" alt></p><p>此时，我们打开 <code>libObjc</code> 的源码可以看到:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112638.jpg" alt></p><p>上面这一连串的跳转，结果很显然：<code>dyld</code> 注册了回调才使得 <code>libobjc</code> 能知道镜像何时加载完毕。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112702.jpg" alt></p><p>在 <code>ImageLoader::recursiveInitialization</code> 方法中还有一个 <code>doInitialization</code> 值得注意，这里是真正做初始化操作的地方。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112714.jpg" alt></p><p><code>doInitialization</code> 主要有两个操作，一个是 <code>doImageInit</code>，一个是 <code>doModInitFunctions</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112723.jpg" alt></p><p><code>doImageInit</code> 内部会通过初始地址 + 偏移量拿到初始化器 <code>func</code>，然后进行签名的验证。验证通过后还要判断初始化器是否在镜像文件中以及 <code>libSystem</code> 库是否已经初始化，最后才执行初始化器。</p><hr><p><strong>通知监听 dyld 的 main</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112731.jpg" alt></p><p>一切工作做完后通知监听 <code>dyld</code> 的 <code>main</code>，然后为主二进制可执行文件找到入口，最后对结果进行签名。</p><h1 id="四、探索-objc-init"><a href="#四、探索-objc-init" class="headerlink" title="四、探索 _objc_init"></a>四、探索 _objc_init</h1><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112747.jpg" alt></p><p>我们直接通过 <code>LLDB</code> 大法来断点调试 <code>libObjc</code> 中的 <code>_objc_init</code>，然后通过 <code>bt</code> 命令打印出当前的调用堆栈，根据上一节我们探索 <code>dyld</code> 的源码，此刻一切的一切都是那么的清晰明了：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112754.jpg" alt></p><p>我们可以看到 <code>dyld</code> 的最后一个流程是 <code>doModInitFunctions</code> 方法的执行。</p><p>我们打开 <code>libSystem</code> 的源码，全局搜索 <code>libSystem_initializer</code> 可以看到：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112803.jpg" alt></p><p>然后我们打开 <code>libDispatch</code> 的源码，全局搜索 <code>libdispatch_init</code> 可以看到：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113010.jpg" alt></p><p>我们再搜索 <code>_os_object_init</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113018.jpg" alt></p><p>完美~，<code>_objc_init</code> 在这里就被调用了。所以 <code>_objc_init</code> 的流程是</p><p>dyld -&gt; libSystem -&gt; libDispatch -&gt; libObc -&gt; <code>_objc_init</code></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>本文主要探索了 <code>app</code> 启动之后 <code>dyld</code> 的流程，整个分析过程确实比较复杂，但在探索的过程中，我们不仅对底层源码有了新的认知，同时对于优化我们 <code>app</code> 启动也是有很多好处的。下一章，我们会对 <code>objc_init</code> 内部的 <code>map_images</code> 和 <code>load_images</code> 进行更深入的分析，敬请期待~</p><h1 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h1><p><a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="noopener">Optimizing App Startup Time</a></p><p><a href="https://xiaozhuanlan.com/topic/4690823715" target="_blank" rel="noopener">优化 App 启动</a></p><p><a href="https://github.com/Damonvvong/DevNotes/blob/master/Notes/framework.md" target="_blank" rel="noopener">iOS 开发中的『库』(一)</a></p><p><a href="https://www.awsomejiang.com/2018/01/15/Memory-Management-For-iOS-Apps-No-2/" target="_blank" rel="noopener">iOS应用的内存管理（二）</a></p><p><a href="http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/#%E5%8A%A0%E8%BD%BD-Dylib" target="_blank" rel="noopener">优化 App 的启动时间</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;App&lt;/code&gt; 从被用户在主屏幕上点击之后就开启了它的生命周期，那么在这之中，究竟发生了什么呢?让我们从 &lt;code&gt;App&lt;/code&gt; 启动开始探索。在探索之前，我们需要熟悉一些前导知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - 消息转发</title>
    <link href="http://leejunhui.com/2020/01/08/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>http://leejunhui.com/2020/01/08/iOS-底层探索-消息转发/</id>
    <published>2020-01-08T07:33:00.000Z</published>
    <updated>2020-01-19T02:35:44.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态方法解析流程分析"><a href="#动态方法解析流程分析" class="headerlink" title="动态方法解析流程分析"></a>动态方法解析流程分析</h1><p>我们在上一章《消息查找》分析到了<strong>动态方法解析</strong>，为了更好的掌握具体的流程，我们接下来直接进行源码追踪。</p><a id="more"></a><p>我们先来到 <code>_class_resolveMethod</code> 方法，该方法源码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line"></span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概的流程如下：</p><ul><li>判断进行解析的是否是元类</li><li>如果不是元类，则调用 <code>_class_resolveInstanceMethod</code> 进行对象方法动态解析</li><li>如果是元类，则调用 <code>_class_resolveClassMethod</code> 进行类方法动态解析</li><li>完成类方法动态解析后，再次查询 <code>cls</code> 中的 <code>imp</code>，如果没有找到，则进行一次对象方法动态解析</li></ul><h2 id="1-1-对象方法动态解析"><a href="#1-1-对象方法动态解析" class="headerlink" title="1.1 对象方法动态解析"></a>1.1 对象方法动态解析</h2><p>我们先分析对象方法的动态解析，我们直接来到 <code>_class_resolveInstanceMethod</code> 方法处:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _class_resolveInstanceMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </span><br><span class="line">                         NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的流程如下:</p><ul><li>检查是否实现了 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 类方法，如果没有实现则直接返回(通过 <code>cls-&gt;ISA()</code> 是拿到元类，因为类方法是存储在元类上的对象方法)</li><li>如果当前实现了 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 类方法，则通过 <code>objc_msgSend</code> 手动调用该类方法</li><li>完成调用后，再次查询 <code>cls</code> 中的 <code>imp</code></li><li>如果 <code>imp</code> 找到了，则输出动态解析对象方法成功的日志</li><li>如果 <code>imp</code> 没有找到，则输出虽然实现了 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code>，并且返回了 <code>YES</code>，但并没有查找到 <code>imp</code> 的日志</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119101935.jpg" alt></p><h2 id="类方法动态解析"><a href="#类方法动态解析" class="headerlink" title="类方法动态解析"></a>类方法动态解析</h2><p>接着我们分析类方法动态解析，我们直接来到 <code>_class_resolveClassMethod</code> 方法处:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _class_resolveClassMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    assert(cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(_class_getNonMetaClass(cls, inst), </span><br><span class="line">                        SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveClassMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的流程如下:</p><ul><li>断言是否是元类，如果不是，直接退出</li><li>检查是否实现了 <code>+(BOOL)resolveClassMethod:(SEL)sel</code> 类方法，如果没有实现则直接返回(通过 <code>cls-</code> 是因为当前 <code>cls</code> 就是元类，因为类方法是存储在元类上的对象方法)</li><li>如果当前实现了 <code>+(BOOL)resolveClassMethod:(SEL)sel</code> 类方法，则通过 <code>objc_msgSend</code> 手动调用该类方法，注意这里和动态解析对象方法不同，这里需要<strong>通过元类和对象来找到类</strong>，也就是 <code>_class_getNonMetaClass</code></li><li>完成调用后，再次查询 <code>cls</code> 中的 <code>imp</code></li><li>如果 <code>imp</code> 找到了，则输出动态解析对象方法成功的日志</li><li>如果 <code>imp</code> 没有找到，则输出虽然实现了 <code>+(BOOL)resolveClassMethod:(SEL)sel</code>，并且返回了 <code>YES</code>，但并没有查找到 <code>imp</code> 的日志</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103157.jpg" alt></p><blockquote><p>这里有一个注意点，如果我们把上面例子中的 <code>objc_getMetaClass(&quot;LGPerson&quot;)</code> 换成 <code>self</code> 试试，会导致 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 方法被调用，其实问题是发生在 <code>class_getMethodImplementation</code> 方法处，其内部会调用到 <code>_class_resolveMethod</code> 方法，而我们的 <code>cls</code> 传的是 <code>self</code>，所以又会走一次 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code><br><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103217.jpg" alt></p></blockquote><h2 id="特殊的-NSObject-对象方法动态解析"><a href="#特殊的-NSObject-对象方法动态解析" class="headerlink" title="特殊的 NSObject 对象方法动态解析"></a>特殊的 <code>NSObject</code> 对象方法动态解析</h2><p>我们再聚焦到 <code>_class_resolveMethod</code> 方法上，如果 <code>cls</code> 是元类，也就是说进行的是类方法动态解析的话，有以下源码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_class_resolveClassMethod(cls, sel, inst); <span class="comment">// 已经处理</span></span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对象方法 决议</span></span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>对于 <code>_class_resolveClassMethod</code> 的执行，肯定是没有问题的，只是为什么在判断如果动态解析失败之后，还要再进行一次对象方法解析呢，这个时候就需要上一张经典的 <code>isa</code> 走位图了:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103234.jpg" alt></p><p>由这个流程图我们可以知道，元类最终继承于<strong>根元类</strong>，而<strong>根元类</strong>又继承于 <code>NSObject</code>，那么也就是说在<strong>根元类</strong>中存储的类方法等价于在 <code>NSObject</code> 中存储的对象方法。而系统在执行 <code>lookUpImpOrNil</code> 时，会递归查找元类的父类的方法列表。但是由于元类和根元类都是系统自动生成的，我们是无法直接编写它们，而对于 <code>NSObject</code>，我们可以借助分类(<code>Category</code>)来实现<strong>统一的类方法动态解析</strong>，不过前提是类本身是没有实现 <code>resolveClassMethod</code> 方法：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103249.jpg" alt></p><p>这也就解释了为什么 <code>_class_resolveClassMethod</code> 为什么会多一步对象方法解析的流程了。</p><h1 id="消息转发快速流程"><a href="#消息转发快速流程" class="headerlink" title="消息转发快速流程"></a>消息转发快速流程</h1><p>如果我们没有进行动态方法解析，消息查找流程接下来会来到的是什么呢?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No implementation found, and method resolver didn't help. </span></span><br><span class="line">    <span class="comment">// Use forwarding.</span></span><br><span class="line"></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br></pre></td></tr></table></figure><p>根据 <code>lookUpImpOrForward</code> 源码我们可以看到当动态解析没有成功后，会直接返回一个 <code>_objc_msgForward_impcache</code>。我们尝试搜索一下它，定位到 <code>objc-msg-arm64.s</code> 汇编源码处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"><span class="comment">// No stret specialization.</span></span><br><span class="line">b__objc_msgForward</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENTRY __objc_msgForward</span><br><span class="line"></span><br><span class="line">adrpx17, __objc_forward_handler@PAGE</span><br><span class="line">ldrp17, [x17, __objc_forward_handler@PAGEOFF]</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward</span><br></pre></td></tr></table></figure><p>可以看到在 <code>__objc_msgForward_impcache</code> 内部会跳转到 <code>__objc_msgForward</code>，而 <code>__objc_msgForward</code> 内部我们并拿不到有用的信息。这个时候是不是线索就断了呢？我们会议一下前面的流程，如果找到了 <code>imp</code>，会进行缓存的填充以及日志的打印，我们不妨找到打印的日志文件看看里面会不会有我们需要的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">log_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_MESSAGE_LOGGING</span></span><br><span class="line">    <span class="keyword">if</span> (objcMsgLogEnabled) &#123;</span><br><span class="line">        <span class="keyword">bool</span> cacheIt = logMessageSend(implementer-&gt;isMetaClass(), </span><br><span class="line">                                      cls-&gt;nameForLogging(),</span><br><span class="line">                                      implementer-&gt;nameForLogging(), </span><br><span class="line">                                      sel);</span><br><span class="line">        <span class="keyword">if</span> (!cacheIt) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    cache_fill (cls, sel, imp, receiver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">logMessageSend</span><span class="params">(<span class="keyword">bool</span> isClassMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">char</span> *objectsClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">char</span> *implementingClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                    SEL selector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>buf[ <span class="number">1024</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create/open the log file</span></span><br><span class="line">    <span class="keyword">if</span> (objcMsgLogFD == (<span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span> (buf, <span class="keyword">sizeof</span>(buf), <span class="string">"/tmp/msgSends-%d"</span>, (<span class="keyword">int</span>) getpid ());</span><br><span class="line">        objcMsgLogFD = secure_open (buf, O_WRONLY | O_CREAT, geteuid());</span><br><span class="line">        <span class="keyword">if</span> (objcMsgLogFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// no log file - disable logging</span></span><br><span class="line">            objcMsgLogEnabled = <span class="literal">false</span>;</span><br><span class="line">            objcMsgLogFD = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make the log entry</span></span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%c %s %s %s\n"</span>,</span><br><span class="line">            isClassMethod ? <span class="string">'+'</span> : <span class="string">'-'</span>,</span><br><span class="line">            objectsClass,</span><br><span class="line">            implementingClass,</span><br><span class="line">            sel_getName(selector));</span><br><span class="line"></span><br><span class="line">    objcMsgLogLock.lock();</span><br><span class="line">    write (objcMsgLogFD, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    objcMsgLogLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell caller to not cache the method</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们很清楚的能看到日志文件的存储位置已经命名方式:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103306.jpg" alt></p><p>这里还有一个注意点:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103315.jpg" alt></p><p>只有当 <code>objcMsgLogEnabled</code> 这个值为 <code>true</code> 的时候才会进行日志的输出，我们直接搜索这个值出现过的地方:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103334.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103342.jpg" alt></p><p>很明显，通过调用 <code>instrumentObjcMessageSends</code> 可以来实现打印的开与关。我们可以简单测试一下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103350.jpg" alt></p><p>我们运行一下，然后来到 <code>/private/tmp</code> 目录下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103358.jpg" alt></p><p>我们打开这个文件:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103410.jpg" alt></p><p>我们看到了熟悉的 <code>resolveInstanceMethod</code>，但是在这之后有 2 个之前我们没探索过的方法: <code>forwardingTargetForSelector</code> 和 <code>methodSignatureForSelector</code>。然后会有 <code>doesNotRecognizeSelector</code> 方法的打印，此时 <code>Xcode</code> 控制台打印如下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103417.jpg" alt></p><p>我们可以看到 <code>___forwarding___</code> 发生在 <code>CoreFoundation</code> 框架里面。我们还是老规矩，<strong>以官方文档为准</strong>，查询一下 <code>forwardingTargetForSelector</code> 和 <code>methodSignatureForSelector</code>。</p><p>先是 <code>forwardingTargetForSelector</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103427.jpg" alt></p><p><code>forwardingTargetForSelector</code> 的官方定义是返回未找到 <code>IMP</code> 的消息首先定向到的对象，说人话就是在这个方法可以实现<strong>狸猫换太子</strong>，不是找不到 <code>IMP</code> 吗，我把这个消息交给其他的对象来处理不就完事了吗？我们直接用代码说话:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s -- %@"</span>,__func__,<span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(saySomething)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [LGTeacher alloc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们直接返回 <code>[LGTeacher alloc]</code>，我们运行试试看:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103436.jpg" alt></p><p>完美~，我们对 <code>LGStudent</code> 实例对象发送 <code>saySomething</code> 消息，结果最后是由 <code>LGTeacher</code> 响应了这个消息。关于 <code>forwardingTargetForSelector</code> ，苹果还给出了几点提示:</p><blockquote><p>If an object implements (or inherits) this method, and returns a non-nil (and non-self) result, that returned object is used as the new receiver object and the message dispatch resumes to that new object. (Obviously if you return self from this method, the code would just fall into an infinite loop.)<br>译: 如果一个对象实现或继承了该方法，然后返回一个非空(非 <code>self</code>)的结果，那么这个返回值会被当做新的消息接受者对象，消息会被转发到该对象身上。(如果你在这个方法里返回 <code>self</code>，那么显然就会发生一个<strong>死循环</strong>)。</p></blockquote><blockquote><p>If you implement this method in a non-root class, if your class has nothing to return for the given selector then you should return the result of invoking super’s implementation.<br>译: 如果你在一个非基类中实现了该方法，并且这个类没有任何可以返回的内容，那么你需要返回父类的实现。也就是 <code>return [super forwardingTargetForSelector:aSelector];</code>。</p></blockquote><blockquote><p>This method gives an object a chance to redirect an unknown message sent to it before the much more expensive forwardInvocation: machinery takes over. This is useful when you simply want to redirect messages to another object and can be an order of magnitude faster than regular forwarding. It is not useful where the goal of the forwarding is to capture the NSInvocation, or manipulate the arguments or return value during the forwarding.<br>译: 这个方法使对象有机会在更昂贵的 <code>forwardInvocation：</code> 机械接管之前重定向发送给它的未知消息。当你只想将消息重定向到另一个对象，并且比常规转发快一个数量级时，这个方法就很有用。在转发的目标是捕获 <code>NSInvocation</code> 或在转发过程中操纵参数或返回值的情况下，此功能就无用了。</p></blockquote><p>通过上面的官方文档定义，我们可以理清下思路：</p><ul><li><code>forwardingTargetForSelector</code> 是一种快速的消息转发流程，它直接让其他对象来响应未知的消息。</li><li><code>forwardingTargetForSelector</code> 不能返回 <code>self</code>，否则会陷入死循环，因为返回 <code>self</code> 又回去当前实例对象身上走一遍消息查找流程，显然又会来到 <code>forwardingTargetForSelector</code>。</li><li><code>forwardingTargetForSelector</code> 适用于消息转发给其他能响应未知消息的对象，什么意思呢，就是最终返回的内容必须和要查找的消息的参数和返回值一致，如果想要不一致，就需要走其他的流程。</li></ul><h1 id="消息转发慢速流程"><a href="#消息转发慢速流程" class="headerlink" title="消息转发慢速流程"></a>消息转发慢速流程</h1><p>上面说到如果想要最终返回的内容必须和要查找的消息的参数和返回值不一致，需要走其他流程，那么到底是什么流程呢，我们接着看一下刚才另外一个方法 <code>methodSignatureForSelector</code> 的官方文档:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103449.jpg" alt></p><p>官方的定义是 <code>methodSignatureForSelector</code> 返回一个 <code>NSMethodSignature</code> 方法签名对象，这个该对象包含由给定选择器标识的方法的描述。</p><blockquote><p>This method is used in the implementation of protocols. This method is also used in situations where an NSInvocation object must be created, such as during message forwarding. If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature.<br>译: 这个方法用于协议的实现。同时在消息转发的时候，在必须创建 <code>NSInvocation</code> 对象的情况下，也会用到这个方法。如果您的对象维护一个委托或能够处理它不直接实现的消息，则应重写此方法以返回适当的方法签名。</p></blockquote><p>我们在文档的最后可以看到有一个叫 <code>forwardInvocation:</code> 的方法</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103456.jpg" alt></p><p>我们来到该方法的文档处：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103511.jpg" alt></p><blockquote><p>To respond to methods that your object does not itself recognize, you must override methodSignatureForSelector: in addition to forwardInvocation:. The mechanism for forwarding messages uses information obtained from methodSignatureForSelector: to create the NSInvocation object to be forwarded. Your overriding method must provide an appropriate method signature for the given selector, either by pre formulating one or by asking another object for one.<br>译：要响应对象本身无法识别的方法，除了 <code>forwardInvocation：</code>外，还必须重写<code>methodSignatureForSelector:</code> 。 转发消息的机制使用从<code>methodSignatureForSelector：</code>获得的信息来创建要转发的 <code>NSInvocation</code> 对象。 你的重写方法必须为给定的选择器提供适当的方法签名，方法是预先制定一个公式，也可以要求另一个对象提供一个方法签名。</p></blockquote><p>显然，<code>methodSignatureForSelector</code> 和 <code>forwardInvocation</code> 不是孤立存在的，需要一起出现。我们直接上代码说话:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s -- %@"</span>,__func__,<span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(saySomething)) &#123; <span class="comment">// v @ :</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v@:"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s "</span>,__func__);</span><br><span class="line"></span><br><span class="line">   SEL aSelector = [anInvocation selector];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ([[LGTeacher alloc] respondsToSelector:aSelector])</span><br><span class="line">       [anInvocation invokeWithTarget:[LGTeacher alloc]];</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后查看打印结果：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103526.jpg" alt></p><p>可以看到，先是来到了 <code>methodSignatureForSelector</code>，然后来到了 <code>forwardInvocation</code>，最后 <code>saySomething</code> 消息被查找到了。</p><p>关于 <code>forwardInvocation</code>，还有几个注意点：</p><ul><li><code>forwardInvocation</code> 方法有两个任务:<ul><li>查找可以响应 <code>inInvocation</code> 中编码的消息的对象。对于所有消息，此对象不必相同。</li><li>使用 <code>anInvocation</code> 将消息发送到该对象。<code>anInvocation</code> 将保存结果，运行时系统将提取结果并将其传递给原始发送者。</li></ul></li><li><code>forwardInvocation</code> 方法的实现不仅仅可以转发消息。<code>forwardInvocation</code>还可以，例如，可以用于合并响应各种不同消息的代码，从而避免了必须为每个选择器编写单独方法的麻烦。<code>forwardInvocation</code> 方法在对给定消息的响应中还可能涉及其他几个对象，而不是仅将其转发给一个对象。</li><li><code>NSObject</code> 的 <code>forwardInvocation</code> 实现：只会调用 <code>dosNotRecognizeSelector：方法，它不会转发任何消息。因此，如果选择不实现</code>forwardInvocation`，将无法识别的消息发送给对象将引发异常。</li></ul><p>至此，消息转发的慢速流程我们就探索完了。</p><h1 id="四、消息转发流程图"><a href="#四、消息转发流程图" class="headerlink" title="四、消息转发流程图"></a>四、消息转发流程图</h1><p>我们从动态消息解析到快速转发流程再到慢速转发流程可以总结出如下的流程图：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103534.jpg" alt></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>我们从 <code>objc_msgSend</code> 开始，探索了消息发送之后是怎么样的一个流程，这对于我们理解 <code>iOS</code> 底层有很大的帮助。当然，限于笔者的水平，探索的过程可能会有一定的瑕疵。我们简单总结一下：</p><ul><li>动态方法解析分为<strong>对象方法动态解析</strong>和<strong>类方法动态解析</strong><ul><li><strong>对象方法动态解析</strong>需要消息发送者实现 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 方法</li><li><strong>类方法动态解析</strong>需要消息发送者实现 <code>+(BOOL)resolveClassMethod:(SEL)sel</code> 方法</li></ul></li><li>动态方法解析失败会进入消息转发流程</li></ul><ul><li>消息转发分为两个流程：快速转发和慢速转发</li><li>快速转发的实现是 <code>forwardingTargetForSelector</code>，让其他能响应要查找消息的对象来干活</li><li>慢速转发的实现是 <code>methodSignatureForSelector</code> 和 <code>forwardInvocation</code> 的结合，提供了更细粒度的控制，先返回方法签名给 <code>Runtime</code>，然后让 <code>anInvocation</code> 来把消息发送给提供的对象，最后由 <code>Runtime</code> 提取结果然后传递给原始的消息发送者。</li></ul><p><code>iOS</code> 底层探索已经来到了第七篇，我们接下来将会从 <code>app</code> 加载开始探索，探究 <code>冷启动</code> 和 <code>热启动</code>，以及 <code>dyld</code> 是如何工作的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态方法解析流程分析&quot;&gt;&lt;a href=&quot;#动态方法解析流程分析&quot; class=&quot;headerlink&quot; title=&quot;动态方法解析流程分析&quot;&gt;&lt;/a&gt;动态方法解析流程分析&lt;/h1&gt;&lt;p&gt;我们在上一章《消息查找》分析到了&lt;strong&gt;动态方法解析&lt;/strong&gt;，为了更好的掌握具体的流程，我们接下来直接进行源码追踪。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - 消息查找</title>
    <link href="http://leejunhui.com/2020/01/07/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E6%B6%88%E6%81%AF%E6%9F%A5%E6%89%BE/"/>
    <id>http://leejunhui.com/2020/01/07/iOS-底层探索-消息查找/</id>
    <published>2020-01-07T03:06:03.000Z</published>
    <updated>2020-01-19T02:12:59.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="objc-msgSend-汇编补充"><a href="#objc-msgSend-汇编补充" class="headerlink" title="objc_msgSend 汇编补充"></a><code>objc_msgSend</code> 汇编补充</h1><p>我们知道，之所以使用汇编来实现 <code>objc_msgSend</code> 有两个原因:</p><ul><li>因为 C 无法通过写一个函数来保留未知的参数并且跳转到一个任意的函数指针。</li><li><code>objc_msgSend</code> 必须足够快。</li></ul><a id="more"></a><h2 id="objc-msgSend-流程"><a href="#objc-msgSend-流程" class="headerlink" title="objc_msgSend 流程"></a><code>objc_msgSend</code> 流程</h2><ul><li>ENTRY _objc_msgSend</li><li>对消息接收者进行判断、处理 (id self, sel _cmd)</li><li>taggedPointer 判断处理</li><li><code>GetClassFromIsa_p16</code> isa 指针处理拿到 class</li><li>CacheLookup 查找缓存</li><li><code>cache_t</code> 处理 <code>bucket</code> 以及内存哈希处理<ul><li>找不到递归下一个 <code>bucket</code></li><li>找到了就返回 <code>{imp, sel} = *bucket-&gt;imp</code>\</li><li>遇到意外就重试</li><li>找不到就跳到 <code>junpMiss</code></li></ul></li><li><code>__objc_msgSend_uncached</code> 找不到缓存 <code>imp</code></li><li><code>STATIC ENTRY __objc_msgSend_uncached</code></li><li><code>MethodTableLookup</code> 方法表查找<ul><li><code>save parameters registers</code></li><li><code>self</code> 以及 <code>_cmd</code> 准备</li><li><code>_class_lookupMethodAndLoadCache3</code> 调用</li></ul></li></ul><h1 id="通过汇编找到下一流程"><a href="#通过汇编找到下一流程" class="headerlink" title="通过汇编找到下一流程"></a>通过汇编找到下一流程</h1><p>我们在探索 <code>objc_msgSend</code> 的时候，当找不到缓存的时候，会来到一个地方叫做 <code>objc_msgSend_uncached</code>，然后会来到 <code>MethodTableLookup</code>，然后会有一个核心的查找方法 <code>__class_lookupMethodAndLoadCache3</code>。但是我们知道其实已经要进入 C/C++ 的流程了，所以我们还可以汇编来定位。<br>我们打开 <code>Always Show Disassembly</code>选项</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119100507.jpg" alt></p><p>然后我们进入 <code>objc_msgSend</code> 内部</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119100515.jpg" alt></p><p>然后我们进入 <code>_objc_msgSend_uncached</code> 的内部</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119100525.jpg" alt></p><p>我们会来到 <code>_class_lookupMethodAndLoadCache3</code>，这就是真正的方法查找实现。</p><h1 id="代码分析方法查找流程"><a href="#代码分析方法查找流程" class="headerlink" title="代码分析方法查找流程"></a>代码分析方法查找流程</h1><h2 id="对象方法测试"><a href="#对象方法测试" class="headerlink" title="对象方法测试"></a>对象方法测试</h2><ul><li>对象的实例方法 - 自己有</li><li>对象的实例方法 - 自己没有 - 找父类的</li><li>对象的实例方法 - 自己没有 - 父类也没有 - 找父类的父类 - NSObject</li><li>对象的实例方法 - 自己没有 - 父类也没有 - 找父类的父类 - NSObject也没有 - 崩溃</li></ul><h2 id="3-2-类方法测试"><a href="#3-2-类方法测试" class="headerlink" title="3.2 类方法测试"></a>3.2 类方法测试</h2><ul><li>类方法 - 自己有</li><li>类方法 - 自己没有 - 找父类的</li><li>类方法 - 自己没有 - 父类也没有 - 找父类的父类 - NSObject</li><li>类方法 - 自己没有 - 父类也没有 - 找父类的父类 - NSObject也没有 - 崩溃</li><li>类方法 - 自己没有 - 父类也没有 - 找父类的父类 - NSObject也没有 - 但是有对象方法</li></ul><h1 id="源码分析方法查找流程"><a href="#源码分析方法查找流程" class="headerlink" title="源码分析方法查找流程"></a>源码分析方法查找流程</h1><p>我们直接定位到 <code>_class_lookupMethodAndLoadCache3</code> 源码处:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              YES<span class="comment">/*initialize*/</span>, NO<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们进入 <code>lookUpImpOrForward</code>，这里注意一下， <code>cache</code> 是传的 <code>NO</code>，因为来到这里已经说明缓存不存在，所以需要进行方法查找。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119100821.jpg" alt></p><h2 id="lookUpImpOrForward"><a href="#lookUpImpOrForward" class="headerlink" title="lookUpImpOrForward"></a>lookUpImpOrForward</h2><p>我们接着定位到 <code>lookUpImpOrForward</code> 的源码处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br></pre></td></tr></table></figure><p>由该方法的参数我们可以知道，<code>lookUpImpOrForward</code> 应该是个公共方法，<code>initialize</code> 和 <code>cache</code> 分别代表是否避免 <code>+initialize</code> 和是否从缓存中查找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>如果 <code>cache</code> 为 <code>YES</code>，那么就直接调用 <code>cache_getImp</code> 来从 <code>cls</code> 的缓存中获取 <code>sel</code> 对应的 <code>IMP</code>，如果找到了就返回。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>判断当前要查找的 <code>cls</code> 是否已经完成了准备工作，如果没有，则需要进行一下类的 <code>realize</code>。</li></ul><h2 id="从当前类上查找"><a href="#从当前类上查找" class="headerlink" title="从当前类上查找"></a>从当前类上查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try this class's method lists.</span></span><br><span class="line">    &#123;</span><br><span class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>上面的方法很显然，是从类的方法列表中查找 <code>IMP</code>。这里加两个大括号的目的是形成<strong>局部作用域</strong>，让命名不会不想冲突。通过 <code>getMethodNoSuper_nolock</code> 查找 <code>Method</code>，找到了之后就调用 <code>log_and_fill_cache</code> 进行缓存的填充，然后返回 <code>imp</code>。</li></ul><h3 id="getMethodNoSuper-nolock"><a href="#getMethodNoSuper-nolock" class="headerlink" title="getMethodNoSuper_nolock"></a>getMethodNoSuper_nolock</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">method_t</span> *</span><br><span class="line">getMethodNoSuper_nolock(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line">    <span class="comment">// fixme nil cls? </span></span><br><span class="line">    <span class="comment">// fixme nil sel?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> mlists = cls-&gt;data()-&gt;methods.beginLists(), </span><br><span class="line">              end = cls-&gt;data()-&gt;methods.endLists(); </span><br><span class="line">         mlists != end;</span><br><span class="line">         ++mlists)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">method_t</span> *m = search_method_list(*mlists, sel);</span><br><span class="line">        <span class="keyword">if</span> (m) <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> method_t *<span class="title">search_method_list</span><span class="params">(<span class="keyword">const</span> <span class="keyword">method_list_t</span> *mlist, SEL sel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> methodListIsFixedUp = mlist-&gt;isFixedUp();</span><br><span class="line">    <span class="keyword">int</span> methodListHasExpectedSize = mlist-&gt;entsize() == <span class="keyword">sizeof</span>(<span class="keyword">method_t</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMethodInSortedMethodList(sel, mlist);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Linear search of unsorted method list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name == sel) <span class="keyword">return</span> &amp;meth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="comment">// sanity-check negative results</span></span><br><span class="line">    <span class="keyword">if</span> (mlist-&gt;isFixedUp()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name == sel) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"linear search worked when binary search did not"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getMethodNoSuper_nolock</code> 实现很简单，就是从 <code>cls</code> 的 <code>data()</code> 中进行遍历，然后对遍历到的 <code>method_list_t</code> 结构体指针再次调用 <code>search_method_list</code> 与 <code>sel</code> 进行匹配。这里的 <code>findMethodInSortedMethodList</code> 我们再接着往下探索。</p><h3 id="findMethodInSortedMethodList"><a href="#findMethodInSortedMethodList" class="headerlink" title="findMethodInSortedMethodList"></a>findMethodInSortedMethodList</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> method_t *<span class="title">findMethodInSortedMethodList</span><span class="params">(SEL key, <span class="keyword">const</span> <span class="keyword">method_list_t</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_t</span> * <span class="keyword">const</span> first = &amp;<span class="built_in">list</span>-&gt;first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_t</span> *base = first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_t</span> *probe;</span><br><span class="line">    <span class="keyword">uintptr_t</span> keyValue = (<span class="keyword">uintptr_t</span>)key;</span><br><span class="line">    <span class="keyword">uint32_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (count = <span class="built_in">list</span>-&gt;count; count != <span class="number">0</span>; count &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        probe = base + (count &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">uintptr_t</span> probeValue = (<span class="keyword">uintptr_t</span>)probe-&gt;name;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (keyValue == probeValue) &#123;</span><br><span class="line">            <span class="comment">// `probe` is a match.</span></span><br><span class="line">            <span class="comment">// Rewind looking for the *first* occurrence of this value.</span></span><br><span class="line">            <span class="comment">// This is required for correct category overrides.</span></span><br><span class="line">            <span class="keyword">while</span> (probe &gt; first &amp;&amp; keyValue == (<span class="keyword">uintptr_t</span>)probe[<span class="number">-1</span>].name) &#123;</span><br><span class="line">                probe--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">method_t</span> *)probe;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (keyValue &gt; probeValue) &#123;</span><br><span class="line">            base = probe + <span class="number">1</span>;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>findMethodInSortedMethodList</code> 的核心逻辑是<strong>二分查找</strong>，这种算法的前提是<strong>有序</strong>的集合。</p><h2 id="从父类中查找"><a href="#从父类中查找" class="headerlink" title="从父类中查找"></a>从父类中查找</h2><p>源码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try superclass caches and method lists.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> attempts = unreasonableClassCount();</span><br><span class="line">        <span class="keyword">for</span> (Class curClass = cls-&gt;superclass;</span><br><span class="line">             curClass != nil;</span><br><span class="line">             curClass = curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">            <span class="keyword">if</span> (--attempts == <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Memory corruption in class list."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass cache.</span></span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    <span class="keyword">goto</span> done;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">                    <span class="comment">// Stop searching, but don't cache yet; call method </span></span><br><span class="line">                    <span class="comment">// resolver for this class first.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass method list.</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp = meth-&gt;imp;</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Superclass cache.</span></span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br></pre></td></tr></table></figure><ul><li>在父类中查找的时候，和在当前类查找有一点不同的是需要检查缓存。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    <span class="keyword">goto</span> done;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">                    <span class="comment">// Stop searching, but don't cache yet; call method </span></span><br><span class="line">                    <span class="comment">// resolver for this class first.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><ul><li>如果在父类中找到了 <code>IMP</code>，同时判断是否是消息转发的入口，如果不是消息转发，那么就把找到的 <code>IMP</code> 通过 <code>log_and_fill_cache</code> 缓存到当前类的缓存中；如果是消息转发，就退出循环。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Superclass method list.</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp = meth-&gt;imp;</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>如果父类缓存中没有找到，那么就查找父类的方法列表，这里和上面在当前类中的方法列表中查找是异曲同工之妙，就不再赘述了。</li></ul><h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        <span class="comment">// Don't cache the result; we don't hold the lock so it may have </span></span><br><span class="line">        <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">        triedResolver = YES;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果在类和父类中都没有找到，<code>Runtime</code> 给了我们一个机会来进行<strong>动态方法解析</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _class_resolveMethod</span></span><br><span class="line"><span class="comment">* Call +resolveClassMethod or +resolveInstanceMethod.</span></span><br><span class="line"><span class="comment">* Returns nothing; any result would be potentially out-of-date already.</span></span><br><span class="line"><span class="comment">* Does not check if the method already exists.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line"></span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来分析一下 <code>_class_resolveMethod</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line"></span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>判断当前类是否是元类，如果不是的话，调用 <code>_class_resolveInstanceMethod</code>。</li><li>如果是元类的话，说明要查找的是类方法，调用 <code>_class_resolveClassMethod</code>。</li></ul><h3 id="class-resolveInstanceMethod"><a href="#class-resolveInstanceMethod" class="headerlink" title="_class_resolveInstanceMethod"></a>_class_resolveInstanceMethod</h3><p>首先我们分析动态解析对象方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _class_resolveInstanceMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </span><br><span class="line">                         NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IMP <span class="title">lookUpImpOrNil</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);</span><br><span class="line">    <span class="keyword">if</span> (imp == _objc_msgForward_impcache) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还有一个注意点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br></pre></td></tr></table></figure><p>对当前 <code>cls</code> 发送 <code>SEL_resolveInstanceMethod</code> 消息，如果返回的是 <code>YES</code>，那说明当前类是实现了动态方法解析。</p><p>由上面的代码可知动态方法解析到最后会回到 <code>lookUpImpOrForward</code>。注意这里的传参:<br><code>cache</code> 是 <code>YES</code>，<code>resolver</code> 是 <code>NO</code>，什么意思呢?</p><blockquote><p>Cache the result (good or bad) so the resolver doesn’t fire next time.<br>缓存查找的结果，所以解析器下一次就不会被触发，其实本质上就是<strong>打破递归</strong>。</p></blockquote><h3 id="class-resolveClassMethod"><a href="#class-resolveClassMethod" class="headerlink" title="_class_resolveClassMethod"></a>_class_resolveClassMethod</h3><p>我们接着分析动态解析类方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _class_resolveClassMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    assert(cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(_class_getNonMetaClass(cls, inst), </span><br><span class="line">                        SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveClassMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个注意点：传进来的 <code>cls</code> 必须是<strong>元类</strong>，因为类方法存在元类的缓存或方法列表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象方法动态解析</span></span><br><span class="line"><span class="keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法动态解析</span></span><br><span class="line"><span class="keyword">bool</span> resolved = msg(_class_getNonMetaClass(cls, inst), </span><br><span class="line">                        SEL_resolveClassMethod, sel);</span><br></pre></td></tr></table></figure><p>这里 <code>msg</code> 方法的第一个参数就明显不同，解析对象方法的时候传的是当前类，而解析类方法的时候传的是 <code>_class_getNonMetaClass(cls, inst)</code> 的结果。我们进入 <code>_class_getNonMetaClass</code> 内部:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class _class_getNonMetaClass(Class cls, id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock(runtimeLock);</span><br><span class="line">    cls = getNonMetaClass(cls, obj);</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着进入 <code>getNonMetaClass</code>，这个方法的目的就是<strong>通过元类获取类</strong>，我们去除一些干扰信息:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">getNonMetaClass</span><span class="params">(Class metacls, id inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total, named, secondary, sharedcache;</span><br><span class="line">    realizeClass(metacls);</span><br><span class="line"></span><br><span class="line">    total++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经不是元类的，那就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!metacls-&gt;isMetaClass()) <span class="keyword">return</span> metacls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// metacls really is a metaclass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根元类的特殊情况，这里回忆一下，根元类的isa指向的是自己</span></span><br><span class="line">    <span class="comment">// where inst == inst-&gt;ISA() == metacls is possible</span></span><br><span class="line">    <span class="keyword">if</span> (metacls-&gt;ISA() == metacls) &#123;</span><br><span class="line">        Class cls = metacls-&gt;superclass;</span><br><span class="line">        assert(cls-&gt;isRealized());</span><br><span class="line">        assert(!cls-&gt;isMetaClass());</span><br><span class="line">        assert(cls-&gt;ISA() == metacls);</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;ISA() == metacls) <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果实例不为空</span></span><br><span class="line">    <span class="keyword">if</span> (inst) &#123;</span><br><span class="line">        Class cls = (Class)inst;</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        <span class="comment">// cls 可能是一个子类，这里通过实例获取到类对象，</span></span><br><span class="line">        <span class="comment">// 然后通过一个 while 循环来遍历判断类对象的 isa 是否是元类</span></span><br><span class="line">        <span class="comment">// 如果是元类的话，就跳出循环；如果不是接着获取类对象的父类</span></span><br><span class="line">        <span class="comment">// cls may be a subclass - find the real class for metacls</span></span><br><span class="line">        <span class="keyword">while</span> (cls  &amp;&amp;  cls-&gt;ISA() != metacls) &#123;</span><br><span class="line">            cls = cls-&gt;superclass;</span><br><span class="line">            realizeClass(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明已经找到了当前元类所匹配的类</span></span><br><span class="line">        <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">            assert(!cls-&gt;isMetaClass());</span><br><span class="line">            assert(cls-&gt;ISA() == metacls);</span><br><span class="line">            <span class="keyword">return</span> cls;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">        _objc_fatal(<span class="string">"cls is not an instance of metacls"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">// release build: be forgiving and fall through to slow lookups</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试命名查询</span></span><br><span class="line">    &#123;</span><br><span class="line">        Class cls = getClass(metacls-&gt;mangledName());</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;ISA() == metacls) &#123;</span><br><span class="line">            named++;</span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"INITIALIZE: %d/%d (%g%%) "</span></span><br><span class="line">                             <span class="string">"successful by-name metaclass lookups"</span>,</span><br><span class="line">                             named, total, named*<span class="number">100.0</span>/total);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            realizeClass(cls);</span><br><span class="line">            <span class="keyword">return</span> cls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试 NXMapGet</span></span><br><span class="line">    &#123;</span><br><span class="line">        Class cls = (Class)NXMapGet(nonMetaClasses(), metacls);</span><br><span class="line">        <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">            secondary++;</span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"INITIALIZE: %d/%d (%g%%) "</span></span><br><span class="line">                             <span class="string">"successful secondary metaclass lookups"</span>,</span><br><span class="line">                             secondary, total, secondary*<span class="number">100.0</span>/total);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            assert(cls-&gt;ISA() == metacls);            </span><br><span class="line">            realizeClass(cls);</span><br><span class="line">            <span class="keyword">return</span> cls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try any duplicates in the dyld shared cache</span></span><br><span class="line">    <span class="comment">// 尝试从 dyld 动态共享缓存库中查询</span></span><br><span class="line">    &#123;</span><br><span class="line">        Class cls = nil;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        Class *classes = copyPreoptimizedClasses(metacls-&gt;mangledName(),&amp;count);</span><br><span class="line">        <span class="keyword">if</span> (classes) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (classes[i]-&gt;ISA() == metacls) &#123;</span><br><span class="line">                    cls = classes[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(classes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">            sharedcache++;</span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"INITIALIZE: %d/%d (%g%%) "</span></span><br><span class="line">                             <span class="string">"successful shared cache metaclass lookups"</span>,</span><br><span class="line">                             sharedcache, total, sharedcache*<span class="number">100.0</span>/total);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            realizeClass(cls);</span><br><span class="line">            <span class="keyword">return</span> cls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _objc_fatal(<span class="string">"no class for metaclass %p"</span>, (<span class="keyword">void</span>*)metacls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No implementation found, and method resolver didn't help. </span></span><br><span class="line">    <span class="comment">// Use forwarding.</span></span><br><span class="line"></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br></pre></td></tr></table></figure><p>如果<strong>动态消息解析</strong>仍然失败，那么就会来到消息查找的最后一步了，<strong>消息转发</strong>。</p><p>此时会返回一个类型为 <code>_objc_msgForward_impcache</code> 的 <code>IMP</code>，然后填充到 <code>cls</code> 中的 <code>cache_t</code> 里面。至此，我们的消息查找流程就此结束了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>方法查找或者说消息查找，起始于 <code>_class_lookupMethodAndLoadCache3</code>。</li><li><code>_class_lookupMethodAndLoadCache3</code> 的核心实现是 <code>lookUpImpOrForward</code>。</li><li>从 <code>_class_lookupMethodAndLoadCache3</code> 进入的话，是忽略缓存直接从方法列表中查找。</li><li>查找之前会确保类已经完成诸如 属性、方法、协议等内容的 <code>attach</code>。</li><li>先从当前类的方法列表中查找，找到了返回，找不到交给父类。</li><li>先从父类的缓存中查找，如果找到返回，如果没有查找方法列表，找到了返回，找不到进行<strong>动态方法解析</strong>。</li><li>根据当前是类还是元类来进行<strong>对象方法动态解析</strong>和<strong>类方法动态解析</strong>。</li><li>如果解析成功，则返回，如果失败，进入消息转发流程。</li></ul><p>我们今天一起探索了消息查找的底层，下一章我们将会沿着今天的方向再往下探索方法转发的流程。敬请期待~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;objc-msgSend-汇编补充&quot;&gt;&lt;a href=&quot;#objc-msgSend-汇编补充&quot; class=&quot;headerlink&quot; title=&quot;objc_msgSend 汇编补充&quot;&gt;&lt;/a&gt;&lt;code&gt;objc_msgSend&lt;/code&gt; 汇编补充&lt;/h1&gt;&lt;p&gt;我们知道，之所以使用汇编来实现 &lt;code&gt;objc_msgSend&lt;/code&gt; 有两个原因:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为 C 无法通过写一个函数来保留未知的参数并且跳转到一个任意的函数指针。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;objc_msgSend&lt;/code&gt; 必须足够快。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - 方法</title>
    <link href="http://leejunhui.com/2020/01/07/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E6%96%B9%E6%B3%95/"/>
    <id>http://leejunhui.com/2020/01/07/iOS-底层探索-方法/</id>
    <published>2020-01-07T02:48:15.000Z</published>
    <updated>2020-01-19T01:59:16.557Z</updated>
    
    <content type="html"><![CDATA[<p>我们在前面探索了对象和类的底层原理，接下来我们要探索一下方法的本质，而在探索之前，我们先简单过一遍 <code>Runtime</code> 的知识点，如果读者对这块内容已经很熟悉了的话可以直接跳过第一章。</p><a id="more"></a><blockquote><p>PS: 由于笔者对汇编暂时还是摸索的阶段，关于汇编源码的部分如有错误，欢迎指正。</p></blockquote><h1 id="Runtime-简介"><a href="#Runtime-简介" class="headerlink" title="Runtime 简介"></a><code>Runtime</code> 简介</h1><p>众所周知，<code>Objective-C</code> 是一门动态语言，而承载整个 <code>OC</code> 动态特性的就是 <code>Runtime</code>。关于 <code>Runtime</code> 更多内容可以直接进入<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">官网文档</a>查看。</p><p><code>Runtime</code> 是以 <code>C</code>/<code>C++</code>和汇编编写而成的，为什么不用 <code>OC</code> 呢，这是因为对我们编译器来说，<code>OC</code> 属于更高级的语言，相比于 <code>C</code> 和 <code>C++</code> 以及汇编，执行效率更慢，而在运行时系统需要尽可能快的执行效率。</p><h2 id="Runtime-的前世今生"><a href="#Runtime-的前世今生" class="headerlink" title="Runtime 的前世今生"></a><code>Runtime</code> 的前世今生</h2><p><code>Runtime</code> 分为两个版本，<code>legacy</code> 和 <code>modern</code>，分别对标 <code>OC 1.0</code> 和 <code>OC 2.0</code>。我们通常只需要专注于 <code>modern</code> 版本即可，在 <code>libObjc</code> 源码中体现在 <code>new</code> 后缀的文件上。</p><h2 id="Runtime-三种交互方式"><a href="#Runtime-三种交互方式" class="headerlink" title="Runtime 三种交互方式"></a><code>Runtime</code> 三种交互方式</h2><p>我们与 <code>Runtime</code> 打交道有三种方式:</p><ul><li>直接在 <code>OC</code> 层进行交互：比如 <code>@selector</code></li><li><code>NSObject</code> 的方法：<code>NSSelectorFromName</code></li><li><code>Runtime</code> 的函数： <code>sel_registerName</code></li></ul><h1 id="方法的本质探索"><a href="#方法的本质探索" class="headerlink" title="方法的本质探索"></a>方法的本质探索</h1><h2 id="方法初探"><a href="#方法初探" class="headerlink" title="方法初探"></a>方法初探</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119095137.jpg" alt></p><p>我们可以看到，通过 <code>clang</code> 重写之后，<code>sayNB</code> 在底层其实是一个消息的发送。</p><p>我们把右侧的发送消息的代码简化一下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LGPerson *person = objc_msgSend((id)objc_getClass(<span class="string">"LGPerson"</span>), sel_registerName(<span class="string">"alloc"</span>));</span><br><span class="line">objc_msgSend((id)person, sel_registerName(<span class="string">"sayNB"</span>));</span><br></pre></td></tr></table></figure><p>由此可见，真正发送消息的地方是 <code>objc_msgSend</code>，这个方法有两个参数，一个是消息的接受者为 <code>id</code> 类型，第二个个是方法编号 <code>sel</code>。</p><p>作为对比，<code>run</code> 方法就直接执行了，并没有通过 <code>objc_msgSend</code> 进行消息发送:</p><h2 id="方法发送的几种情况"><a href="#方法发送的几种情况" class="headerlink" title="方法发送的几种情况"></a>方法发送的几种情况</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LGStudent *s = [LGStudent new];</span><br><span class="line">[s sayCode];        </span><br><span class="line"></span><br><span class="line">objc_msgSend(s, sel_registerName(<span class="string">"sayCode"</span>));</span><br></pre></td></tr></table></figure><p>上述代码表示的是向对象 <code>s</code> 发送 <code>sayCode</code> 消息。</p><hr><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> cls = [LGStudent <span class="keyword">class</span>];</span><br><span class="line"><span class="keyword">void</span> *pointA = &amp;cls;</span><br><span class="line">[(__bridge <span class="keyword">id</span>)pointA sayNB];</span><br><span class="line"></span><br><span class="line">objc_msgSend(objc_getClass(<span class="string">"LGStudent"</span>), sel_registerName(<span class="string">"sayNB"</span>));</span><br></pre></td></tr></table></figure><p>上述代码表示向 <code>LGStudent</code> 这个类发送 <code>sayNB</code> 消息。</p><hr><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向父类发消息(对象方法)</span></span><br><span class="line"><span class="keyword">struct</span> objc_super lgSuper;</span><br><span class="line">lgSuper.receiver = s;</span><br><span class="line">lgSuper.super_class = [LGPerson <span class="keyword">class</span>];</span><br><span class="line">objc_msgSendSuper(&amp;lgSuper, <span class="keyword">@selector</span>(sayHello));</span><br></pre></td></tr></table></figure><p>上述代码表示向父类发送 <code>sayHello</code> 消息。</p><hr><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向父类发消息(类方法)</span></span><br><span class="line"><span class="keyword">struct</span> objc_super myClassSuper;</span><br><span class="line">myClassSuper.receiver = [s <span class="keyword">class</span>];</span><br><span class="line">myClassSuper.super_class = class_getSuperclass(object_getClass([s <span class="keyword">class</span>]));<span class="comment">// 元类</span></span><br><span class="line">objc_msgSendSuper(&amp;myClassSuper, sel_registerName(<span class="string">"sayNB"</span>));</span><br></pre></td></tr></table></figure><p>上述代码表示向父类的类，也就是<strong>元类</strong>发送 <code>sayNB</code> 消息。</p><p>我们在 <code>OC</code> 中使用 <code>objc_msgSend</code> 的时候，要注意需要将 <code>Enbale Strict of Checking of objc_msgSend Calls</code> 设置为 <code>NO</code>。这样才不会报警告。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119095253.jpg" alt></p><h1 id="探索-objc-msgSend"><a href="#探索-objc-msgSend" class="headerlink" title="探索 objc_msgSend"></a>探索 <code>objc_msgSend</code></h1><p><code>objc_msgSend</code> 之所以采用汇编来实现，是因为</p><ul><li>汇编更容易能被机器识别</li><li>参数未知、类型未知对于 <code>C</code> 和 <code>C++</code> 来说不如汇编更得心应手</li></ul><h2 id="消息查找机制"><a href="#消息查找机制" class="headerlink" title="消息查找机制"></a>消息查找机制</h2><ul><li>快速流程</li><li>慢速流程</li></ul><h2 id="定位-objc-msgSend-汇编源码"><a href="#定位-objc-msgSend-汇编源码" class="headerlink" title="定位 objc_msgSend 汇编源码"></a>定位 <code>objc_msgSend</code> 汇编源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENTRY _objc_msgSend</span><br><span class="line">UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">cmpp0, #<span class="number">0</span><span class="comment">// nil check and tagged pointer check</span></span><br></pre></td></tr></table></figure><p>判断 <code>p0</code> ，也就是我们 <code>objc_msgSend</code> 的第一个参数 <code>id</code> 消息的接收者是否为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldrp13, [x0]// p13 = isa</span><br><span class="line">GetClassFromIsa_p16 p13// p16 = class</span><br></pre></td></tr></table></figure><p>读取 <code>x0</code> 然后赋值到 <code>p13</code> ，这里 <code>p13</code> 拿到的是 <code>isa</code>。为什么要拿 <code>isa</code> 呢，因为不论是对象方法还是类方法，我们都需要在类或者元类的缓存或方法列表中去查找，所以 <code>isa</code> 是必需的。</p><h2 id="GetClassFromIsa-p16"><a href="#GetClassFromIsa-p16" class="headerlink" title="GetClassFromIsa_p16"></a>GetClassFromIsa_p16</h2><p>通过 <code>GetClassFromIsa_p16</code>，将获取到的 <code>class</code> 存在 <code>p16</code> 上面。</p><p><code>GetClassFromIsa_p16</code> 源码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.macro GetClassFromIsa_p16 <span class="comment">/* src */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line"><span class="comment">// Indexed isa</span></span><br><span class="line">movp16, $<span class="number">0</span><span class="comment">// optimistically set dst = src</span></span><br><span class="line">tbzp16, #ISA_INDEX_IS_NPI_BIT, <span class="number">1f</span><span class="comment">// done if not non-pointer isa</span></span><br><span class="line"><span class="comment">// isa in p16 is indexed</span></span><br><span class="line">adrpx10, _objc_indexed_classes@PAGE</span><br><span class="line">addx10, x10, _objc_indexed_classes@PAGEOFF</span><br><span class="line">ubfxp16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS  <span class="comment">// extract index</span></span><br><span class="line">ldrp16, [x10, p16, UXTP #PTRSHIFT]<span class="comment">// load class from array</span></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __LP64__</span></span><br><span class="line"><span class="comment">// 64-bit packed isa</span></span><br><span class="line"><span class="keyword">and</span>p16, $<span class="number">0</span>, #ISA_MASK</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// 32-bit raw isa</span></span><br><span class="line">movp16, $<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>这个方法的目的就是通过位移操作获取 <code>isa</code> 的 <code>shiftcls</code> 然后进行位运算与操作得到真正的类信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LGetIsaDone:</span><br><span class="line">CacheLookup NORMAL<span class="comment">// calls imp or objc_msgSend_uncached</span></span><br></pre></td></tr></table></figure><h2 id="CacheLookup"><a href="#CacheLookup" class="headerlink" title="CacheLookup"></a>CacheLookup</h2><p>获取完 <code>isa</code> 之后，接下来就要进行 <code>CacheLookup</code> ，查找方法缓存，我们再来到 <code>CacheLookup</code> 的源码处:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CacheLookup NORMAL|GETIMP|LOOKUP</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Locate the implementation for a selector in a class method cache.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Takes:</span></span><br><span class="line"><span class="comment"> * x1 = selector</span></span><br><span class="line"><span class="comment"> * x16 = class to be searched</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Kills:</span></span><br><span class="line"><span class="comment"> *  x9,x10,x11,x12, x17</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On exit: (found) calls or returns IMP</span></span><br><span class="line"><span class="comment"> *                  with x16 = class, x17 = IMP</span></span><br><span class="line"><span class="comment"> *          (not found) jumps to LCacheMiss</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> ********************************************************************/</span></span><br><span class="line"></span><br><span class="line">.macro CacheLookup</span><br><span class="line"><span class="comment">// p1 = SEL, p16 = isa</span></span><br><span class="line">ldpp10, p11, [x16, #CACHE]<span class="comment">// p10 = buckets, p11 = occupied|mask</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__LP64__</span></span><br><span class="line"><span class="keyword">and</span>w11, w11, <span class="number">0xffff</span><span class="comment">// p11 = mask</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">and</span>w12, w1, w11<span class="comment">// x12 = _cmd &amp; mask</span></span><br><span class="line">addp12, p10, p12, LSL #(<span class="number">1</span>+PTRSHIFT)</span><br><span class="line">             <span class="comment">// p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</span></span><br><span class="line"></span><br><span class="line">ldpp17, p9, [x12]<span class="comment">// &#123;imp, sel&#125; = *bucket</span></span><br><span class="line"><span class="number">1</span>:cmpp9, p1<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">b.ne<span class="number">2f</span><span class="comment">//     scan more</span></span><br><span class="line">CacheHit $<span class="number">0</span><span class="comment">// call or return imp</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>:<span class="comment">// not hit: p12 = not-hit bucket</span></span><br><span class="line">CheckMiss $<span class="number">0</span><span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line">cmpp12, p10<span class="comment">// wrap if bucket == buckets</span></span><br><span class="line">b.eq<span class="number">3f</span></span><br><span class="line">ldpp17, p9, [x12, #-BUCKET_SIZE]!<span class="comment">// &#123;imp, sel&#125; = *--bucket</span></span><br><span class="line">b<span class="number">1b</span><span class="comment">// loop</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:<span class="comment">// wrap: p12 = first bucket, w11 = mask</span></span><br><span class="line">addp12, p12, w11, UXTW #(<span class="number">1</span>+PTRSHIFT)</span><br><span class="line">                        <span class="comment">// p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Clone scanning loop to miss instead of hang when cache is corrupt.</span></span><br><span class="line"><span class="comment">// The slow path may detect any corruption and halt later.</span></span><br><span class="line"></span><br><span class="line">ldpp17, p9, [x12]<span class="comment">// &#123;imp, sel&#125; = *bucket</span></span><br><span class="line"><span class="number">1</span>:cmpp9, p1<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">b.ne<span class="number">2f</span><span class="comment">//     scan more</span></span><br><span class="line">CacheHit $<span class="number">0</span><span class="comment">// call or return imp</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>:<span class="comment">// not hit: p12 = not-hit bucket</span></span><br><span class="line">CheckMiss $<span class="number">0</span><span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line">cmpp12, p10<span class="comment">// wrap if bucket == buckets</span></span><br><span class="line">b.eq<span class="number">3f</span></span><br><span class="line">ldpp17, p9, [x12, #-BUCKET_SIZE]!<span class="comment">// &#123;imp, sel&#125; = *--bucket</span></span><br><span class="line">b<span class="number">1b</span><span class="comment">// loop</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:<span class="comment">// double wrap</span></span><br><span class="line">JumpMiss $<span class="number">0</span></span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>通过上述代码可知 <code>CacheLookup</code> 有三种模式：<code>NORMAL</code>，<code>GETIMP</code>， <code>LOOKUP</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldpp10, p11, [x16, #CACHE]</span><br></pre></td></tr></table></figure><ul><li><code>CacheLookup</code> 需要读取上一步拿到的类的 <code>cache</code> 缓存，而根据我们前面对类结构的学习，这里显然进行 16 字节地址平移操作，然后把拿到的 <code>cache_t</code> 中的 <code>buckets</code> 和 <code>occupied</code>、<code>mask</code> 赋值给 <code>p10</code>, <code>p11</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span>w12, w1, w11<span class="comment">// x12 = _cmd &amp; mask</span></span><br><span class="line">addp12, p10, p12, LSL #(<span class="number">1</span>+PTRSHIFT)</span><br><span class="line">             <span class="comment">// p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</span></span><br><span class="line"></span><br><span class="line">ldpp17, p9, [x12]<span class="comment">// &#123;imp, sel&#125; = *bucket</span></span><br></pre></td></tr></table></figure><ul><li>这里是将 <code>w1</code> 和 <code>w11</code> 进行与操作，其实本质就是 <code>_cmd</code> &amp; <code>mask</code>。这一步和我们探索 <code>cache_t</code> 时遇到的<br><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119095327.jpg" alt><br>是一模模一样样的道理。目的就是拿到下标。然后经过哈希运算之后，得到了 <code>bucket</code> 结构体指针，然后将这个结构体指针中的 <code>imp</code>，<code>sel</code> 分别存在 <code>p17</code>，<code>p9</code> 中。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:cmpp9, p1<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">b.ne<span class="number">2f</span><span class="comment">//     scan more</span></span><br><span class="line">CacheHit $<span class="number">0</span><span class="comment">// call or return imp</span></span><br></pre></td></tr></table></figure><ul><li>接着我们将上一步获取到的 <code>sel</code> 和我们要查找的 <code>sel</code>（在这里也就是所谓的 <code>_cmd</code>）进行比较，如果匹配了，就通过 <code>CacheHit</code> 将 <code>imp</code> 返回；如果没有匹配，就走下一步流程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>:<span class="comment">// not hit: p12 = not-hit bucket</span></span><br><span class="line">CheckMiss $<span class="number">0</span><span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line">cmpp12, p10<span class="comment">// wrap if bucket == buckets</span></span><br><span class="line">b.eq<span class="number">3f</span></span><br><span class="line">ldpp17, p9, [x12, #-BUCKET_SIZE]!<span class="comment">// &#123;imp, sel&#125; = *--bucket</span></span><br><span class="line">b<span class="number">1b</span><span class="comment">// loop</span></span><br></pre></td></tr></table></figure><ul><li>由于上一步的 <code>sel</code> 没有匹配上，我们需要接着进行搜索。</li></ul><h2 id="CheckMiss"><a href="#CheckMiss" class="headerlink" title="CheckMiss"></a>CheckMiss</h2><p>我们来到 <code>CheckMiss</code> 的源码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.macro CheckMiss</span><br><span class="line"><span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line">.<span class="keyword">if</span> $<span class="number">0</span> == GETIMP</span><br><span class="line">cbzp9, LGetImpMiss</span><br><span class="line">.elseif $<span class="number">0</span> == NORMAL</span><br><span class="line">cbzp9, __objc_msgSend_uncached</span><br><span class="line">.elseif $<span class="number">0</span> == LOOKUP</span><br><span class="line">cbzp9, __objc_msgLookup_uncached</span><br><span class="line">.<span class="keyword">else</span></span><br><span class="line">.<span class="built_in">abort</span> oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>这里由于我们是 <code>NORMAL</code> 模式，所以会来到 <code>__objc_msgSend_uncached</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line"><span class="comment">// THIS IS NOT A CALLABLE C FUNCTION</span></span><br><span class="line"><span class="comment">// Out-of-band p16 is the class to search</span></span><br><span class="line"></span><br><span class="line">MethodTableLookup</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure><p><code>__objc_msgSend_uncached</code> 中最核心的逻辑就是 <code>MethodTableLookup</code>，意为查找方法列表。</p><p><a name="ab4985f9"></a></p><h2 id="3-6-MethodTableLookup"><a href="#3-6-MethodTableLookup" class="headerlink" title="3.6 MethodTableLookup"></a>3.6 MethodTableLookup</h2><p>我们再来到 <code>MethodTableLookup</code> 的定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.macro MethodTableLookup</span><br><span class="line"></span><br><span class="line"><span class="comment">// push frame</span></span><br><span class="line">SignLR</span><br><span class="line">stpfp, lr, [sp, #<span class="number">-16</span>]!</span><br><span class="line">movfp, sp</span><br><span class="line"></span><br><span class="line"><span class="comment">// save parameter registers: x0..x8, q0..q7</span></span><br><span class="line">subsp, sp, #(<span class="number">10</span>*<span class="number">8</span> + <span class="number">8</span>*<span class="number">16</span>)</span><br><span class="line">stpq0, q1, [sp, #(<span class="number">0</span>*<span class="number">16</span>)]</span><br><span class="line">stpq2, q3, [sp, #(<span class="number">2</span>*<span class="number">16</span>)]</span><br><span class="line">stpq4, q5, [sp, #(<span class="number">4</span>*<span class="number">16</span>)]</span><br><span class="line">stpq6, q7, [sp, #(<span class="number">6</span>*<span class="number">16</span>)]</span><br><span class="line">stpx0, x1, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">0</span>*<span class="number">8</span>)]</span><br><span class="line">stpx2, x3, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">2</span>*<span class="number">8</span>)]</span><br><span class="line">stpx4, x5, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">4</span>*<span class="number">8</span>)]</span><br><span class="line">stpx6, x7, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">6</span>*<span class="number">8</span>)]</span><br><span class="line">strx8,     [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">8</span>*<span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// receiver and selector already in x0 and x1</span></span><br><span class="line">movx2, x16</span><br><span class="line">bl__class_lookupMethodAndLoadCache3</span><br><span class="line"></span><br><span class="line"><span class="comment">// IMP in x0</span></span><br><span class="line">movx17, x0</span><br><span class="line"></span><br><span class="line"><span class="comment">// restore registers and return</span></span><br><span class="line">ldpq0, q1, [sp, #(<span class="number">0</span>*<span class="number">16</span>)]</span><br><span class="line">ldpq2, q3, [sp, #(<span class="number">2</span>*<span class="number">16</span>)]</span><br><span class="line">ldpq4, q5, [sp, #(<span class="number">4</span>*<span class="number">16</span>)]</span><br><span class="line">ldpq6, q7, [sp, #(<span class="number">6</span>*<span class="number">16</span>)]</span><br><span class="line">ldpx0, x1, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">0</span>*<span class="number">8</span>)]</span><br><span class="line">ldpx2, x3, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">2</span>*<span class="number">8</span>)]</span><br><span class="line">ldpx4, x5, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">4</span>*<span class="number">8</span>)]</span><br><span class="line">ldpx6, x7, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">6</span>*<span class="number">8</span>)]</span><br><span class="line">ldrx8,     [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">8</span>*<span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">movsp, fp</span><br><span class="line">ldpfp, lr, [sp], #<span class="number">16</span></span><br><span class="line">AuthenticateLR</span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>我们观察 <code>MethodTableLookup</code> 内容之后会定位到 <code>__class_lookupMethodAndLoadCache3</code>。在 <code>__class_lookupMethodAndLoadCache3</code> 之前会做一些准备工作，真正的方法查找流程核心逻辑是位于 <code>__class_lookupMethodAndLoadCache3</code> 里面的。 但是我们全局搜索 <code>__class_lookupMethodAndLoadCache3</code> 会发现找不到，这是因为此时我们会从汇编跳入到 <code>C/C++</code>。所以去掉一个下划线就能找到:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              YES<span class="comment">/*initialize*/</span>, NO<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="c57341de"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>方法的本质就是消息发送，消息发送是通过 <code>objc_msgSend</code> 以及其派生函数来实现的。</li><li><code>objc_msgSend</code> 为了执行效率以及 C/C++ 不能支持参数未知，类型未知的代码，所以采用汇编来实现 <code>objc_msgSend</code>。</li><li>消息查找或者说方法查找，会优先去从类中查找缓存，找到了就返回，找不到就需要去类的方法列表中查找。</li><li>由汇编过渡到 C/C++，在类的方法列表中查找失败之后，会进行转发。核心逻辑位于 <code>lookUpImpOrForward</code>。</li></ul><p>我们下一章将会从 <code>lookUpImpOrForward</code> 开始探索，探索底层的方法查找的具体流程到底是怎么样的，敬请期待~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在前面探索了对象和类的底层原理，接下来我们要探索一下方法的本质，而在探索之前，我们先简单过一遍 &lt;code&gt;Runtime&lt;/code&gt; 的知识点，如果读者对这块内容已经很熟悉了的话可以直接跳过第一章。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - cache_t</title>
    <link href="http://leejunhui.com/2020/01/06/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-cache-t/"/>
    <id>http://leejunhui.com/2020/01/06/iOS-底层探索-cache-t/</id>
    <published>2020-01-06T06:32:21.000Z</published>
    <updated>2020-01-18T18:38:59.201Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇我们一起探索了 <code>iOS</code> 类的底层原理，其中比较重要的四个属性我们都简单的过了一遍，我们接下来要重点探索第三个属性 <code>cache_t</code>，对于这个属性，我们可以学习到苹果对于缓存的设计与理解，同时也会接触到消息发送相关的知识。</p><a id="more"></a><h1 id="探索-cache-t"><a href="#探索-cache-t" class="headerlink" title="探索 cache_t"></a>探索 <code>cache_t</code></h1><h2 id="cache-t-基本结构"><a href="#cache-t-基本结构" class="headerlink" title="cache_t 基本结构"></a><code>cache_t</code> 基本结构</h2><p>我们还是先过一遍 <code>OC</code> 中类的结构:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...省略代码...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们查看源码中 <code>cache_t</code> 的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;</span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;</span><br><span class="line">    </span><br><span class="line">    ...省略代码... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们发现 <code>cache_t</code> 结构体的第一个成员 <code>_buckets</code> 也是一个结构体类型 <code>bucket_t</code>，我们再查看一下 <code>bucket_t</code> 的定义:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// IMP-first is better for arm64e ptrauth and no worse for arm64.</span></span><br><span class="line">    <span class="comment">// SEL-first is better for armv7* and i386 and x86_64.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line">    <span class="keyword">cache_key_t</span> _key;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">cache_key_t</span> _key;</span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> cache_key_t <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> IMP <span class="title">imp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (IMP)_imp; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(<span class="keyword">cache_key_t</span> newKey)</span> </span>&#123; _key = newKey; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setImp</span><span class="params">(IMP newImp)</span> </span>&#123; _imp = newImp; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">cache_key_t</span> newKey, IMP newImp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从源码定义中不难看出，<code>bucket_t</code> 其实缓存的是方法实现 <code>IMP</code>。这里有一个注意点，就是 <code>IMP-first</code> 和 <code>SEL-first</code>。</p><blockquote><p>IMP-first is better for arm64e ptrauth and no worse for arm64.</p></blockquote><ul><li>IMP-first 对 arm64e 的效果更好，对 arm64 不会有坏的影响。</li></ul><blockquote><p>SEL-first is better for armv7* and i386 and x86_64.</p></blockquote><ul><li>SEL-first 适用于 armv7 * 和 i386 和 x86_64。</li></ul><p>如果对 <code>SEL</code> 和 <code>IMP</code> 不是很熟悉的同学可以去 <code>objc4-756</code> 源码中查看方法 <code>method_t</code> 的定义:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;   <span class="comment">// 方法选择器</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types; <span class="comment">// 方法类型字符串</span></span><br><span class="line">    MethodListIMP imp;  <span class="comment">// 方法实现</span></span><br><span class="line"></span><br><span class="line">    ...省略代码... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上面的源码，我们大致了解了 bucket_t 类型的结构，那么现在问题来了，类中的 cache 是在什么时候以什么样的方式来进行缓存的呢？ </p><h2 id="LLDB-大法"><a href="#LLDB-大法" class="headerlink" title="LLDB 大法"></a><code>LLDB</code> 大法</h2><p>了解到 <code>cache_t</code> 和 <code>bucket_t</code> 的基本结构后，我们可以通过 <code>LLDB</code> 来打印验证一下：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023640.jpg" alt></p><p><code>cache_t</code> 内部的这三个属性，我们从其名称不难看出 <code>_occupied</code> 应该是表示当前已经占用了多少缓存，<code>_mask</code> 暂时不知道，<code>_buckets</code> 应该是存放具体缓存的地方。那么为了验证我们的猜想，我们调用代码来测试:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023653.jpg" alt></p><p>我们发现，断点断到 45 行的时候，<code>_ocuupied</code> 的值为 1，我们打印一下 <code>_buckets</code> 里面的内容看看:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023700.jpg" alt></p><p>我们可以看到，打印到 <code>_buckets</code> 的第三个元素的时候，我们的 <code>init</code> 方法被缓存了，也就是说 <code>_ocuupied</code> 确实是表示当前被缓存方法的个数。这里可能读者会说为什么 <code>alloc</code> 和 <code>class</code> 为什么没有被缓存呢？其实这是因为 <code>alloc</code> 和 <code>class</code> 是类方法，而根据我们前面探索类底层原理的时候，类方法是存储在元类里面的，所以这里类的缓存里面只会存储对象方法。<br>我们接着把断点过到 46 行:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023709.jpg" alt></p><p><code>_ocuupied</code> 的值果然发生了变化，我们刚才的猜想进一步得到了验证，我们再往下面走一行:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023718.jpg" alt></p><p>此时 <code>_ocuupied</code> 值已经为 3 了，我们回顾一下当前缓存里面缓存的方法:</p><table><thead><tr><th>_ocuupied 的值</th><th>缓存的方法</th></tr></thead><tbody><tr><td>1</td><td>NSObject下的<code>init</code></td></tr><tr><td>2</td><td>NSObject下的<code>init</code>，person下的 <code>sayHello</code></td></tr><tr><td>3</td><td>NSObject下的<code>init</code>，person下的 <code>sayHello</code>, person下的 <code>sayCode</code></td></tr></tbody></table><p>那么，当我们的断点断到下一行的时候，是不是 <code>_ocuupied</code> 就会变为 4 呢? 我们接着往下走：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023729.jpg" alt></p><p>令人惊奇的事情发生了，<code>_ocuupied</code> 的值变成了 1，而 <code>_mask</code> 变成了 7。这是为什么呢？</p><p>如果读者了解并掌握散列表这种数据结构的话，相信已经看出端倪了。是的，这里其实就是用到了 <strong>开放寻址法</strong> 来解决散列冲突（哈希冲突）。</p><blockquote><p>关于哈希冲突，可以借助鸽笼理论，即把 11 只鸽子放进 10 个抽屉里面，肯定会有一个抽屉里面有 2 只鸽子。是不是理解起来很简单? :)</p></blockquote><p>通过上面的测试，我们明确了方法缓存使用的是哈希表存储，并且为了解决无法避免的哈希冲突使用的是开放寻址法，而开放寻址法必然要在合适的时机进行扩容，这个时机肯定不是会在数据已经装满的时候，我们可以进源码探索一下，我们快速定位到 <code>cache_t</code> 的源码处:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">cache_t</span>::expand()</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> oldCapacity = capacity();</span><br><span class="line">    <span class="keyword">uint32_t</span> newCapacity = oldCapacity ? oldCapacity*<span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)(<span class="keyword">mask_t</span>)newCapacity != newCapacity) &#123;</span><br><span class="line">        <span class="comment">// mask overflow - can't grow further</span></span><br><span class="line">        <span class="comment">// fixme this wastes one bit of mask</span></span><br><span class="line">        newCapacity = oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reallocate(oldCapacity, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码不难看出 <code>expand</code> 方法就是扩容的核心算法，我们梳理一下里面的逻辑:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cacheUpdateLock.assertLocked();</span><br></pre></td></tr></table></figure><ul><li>缓存锁断言一下判断当前执行上下文是否已经上锁</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> oldCapacity = capacity();</span><br></pre></td></tr></table></figure><ul><li>通过 <code>capacity()</code> 方法获取当前的容量大小</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> newCapacity = oldCapacity ? oldCapacity*<span class="number">2</span> : INIT_CACHE_SIZE;</span><br></pre></td></tr></table></figure><ul><li>判断当前的容量大小，如果为0，则赋值为 <code>INIT_CACHE_SIZE</code>，而根据</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">2</span>,</span><br><span class="line">    INIT_CACHE_SIZE      = (<span class="number">1</span> &lt;&lt; INIT_CACHE_SIZE_LOG2)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可知 <code>INIT_CACHE_SIZE</code> 初始值为 4；如果当前容量大小不为 0，则直接翻倍。</p><p>到了这里相信聪明的读者根据我们上面的测试应该猜到了，我们的 <code>_mask</code> 其实就是容量大小减 1 后的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reallocate(oldCapacity, newCapacity);</span><br></pre></td></tr></table></figure><ul><li>最后调用 <code>reallocate</code> 方法进行缓存大小的重置</li></ul><p>我们接着进入 <code>reallocate</code> 内部一探究竟:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">cache_t</span>::reallocate(<span class="keyword">mask_t</span> oldCapacity, <span class="keyword">mask_t</span> newCapacity)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> freeOld = canBeFreed();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bucket_t</span> *oldBuckets = buckets();</span><br><span class="line">    <span class="keyword">bucket_t</span> *newBuckets = allocateBuckets(newCapacity);</span><br><span class="line"></span><br><span class="line">    assert(newCapacity &gt; <span class="number">0</span>);</span><br><span class="line">    assert((<span class="keyword">uintptr_t</span>)(<span class="keyword">mask_t</span>)(newCapacity<span class="number">-1</span>) == newCapacity<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    setBucketsAndMask(newBuckets, newCapacity - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (freeOld) &#123;</span><br><span class="line">        cache_collect_free(oldBuckets, oldCapacity);</span><br><span class="line">        cache_collect(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">cache_t</span>::setBucketsAndMask(struct <span class="keyword">bucket_t</span> *newBuckets, <span class="keyword">mask_t</span> newMask)</span><br><span class="line">&#123;</span><br><span class="line">    mega_barrier();</span><br><span class="line"></span><br><span class="line">    _buckets = newBuckets;</span><br><span class="line">    </span><br><span class="line">    mega_barrier();</span><br><span class="line">    </span><br><span class="line">    _mask = newMask;</span><br><span class="line">    _occupied = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，<code>_mask</code> 是这一步 <code>setBucketsAndMask(newBuckets, newCapacity - 1);</code> 被赋值为容量减 1 的。</p><p>同样的，我们还可以通过 <code>capacity</code> 方法来验证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mask_t</span> <span class="keyword">cache_t</span>::capacity() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mask() ? mask()+<span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="深入-cache-t"><a href="#深入-cache-t" class="headerlink" title="深入 cache_t"></a>深入 <code>cache_t</code></h1><p>其实我们在探索 <code>iOS</code> 底层的时候，尽量不要站在上帝视角去审视相应的技术点，我们可以尽量给自己多抛出几个问题，然后尝试去解决每个问题，通过这样的探索，对提高我们阅读源码的能力十分重要。</p><p>通过前面的探索，我们知道了 <code>cache_t</code> 实质上是缓存了我们类的实例方法，那么对于类方法来说，自然就是缓存在了元类上了。这一点我相信读者应该都能理解。</p><h2 id="方法缓存策略"><a href="#方法缓存策略" class="headerlink" title="方法缓存策略"></a>方法缓存策略</h2><p>按照最常规的思维，缓存内容最省时省力的办法肯定是来一个缓存一个，那么我们的 <code>cache_t</code> 是不是这么做的呢，实践出真知，我们一试便知。</p><p>我们在源码中搜索 <code>capacity()</code> 方法，我们找到了 <code>cache_fill_nolock</code> 方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cache_fill_nolock</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Never cache before +initialize is done</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isInitialized()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the entry wasn't added to the cache by some other thread </span></span><br><span class="line">    <span class="comment">// before we grabbed the cacheUpdateLock.</span></span><br><span class="line">    <span class="keyword">if</span> (cache_getImp(cls, sel)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">cache_t</span> *cache = getCache(cls);</span><br><span class="line">    <span class="keyword">cache_key_t</span> key = getKey(sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the cache as-is if it is less than 3/4 full</span></span><br><span class="line">    <span class="keyword">mask_t</span> newOccupied = cache-&gt;occupied() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">mask_t</span> capacity = cache-&gt;capacity();</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newOccupied &lt;= capacity / <span class="number">4</span> * <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Cache is too full. Expand it.</span></span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for the first unused slot and insert there.</span></span><br><span class="line">    <span class="comment">// There is guaranteed to be an empty slot because the </span></span><br><span class="line">    <span class="comment">// minimum size is 4 and we resized at 3/4 full.</span></span><br><span class="line">    <span class="keyword">bucket_t</span> *bucket = cache-&gt;find(key, receiver);</span><br><span class="line">    <span class="keyword">if</span> (bucket-&gt;key() == <span class="number">0</span>) cache-&gt;incrementOccupied();</span><br><span class="line">    bucket-&gt;<span class="built_in">set</span>(key, imp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cache_fill_nolock</code> 方法乍一看有些复杂，我们不妨将它分解一下:</p><p>第一行代码还是加锁的判断，我们直接略过，来到第二行:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cache_getImp(cls, sel)) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>cache_getImp</code> 来判断当前 <code>cls</code> 下的 <code>sel</code> 是否已经被缓存了，如果是，直接返回。而 <code>cache_getImp</code> 底层实现是 <code>_cache_getImp</code>，并且是在汇编层实现的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cache_t</span> *cache = getCache(cls);</span><br><span class="line"><span class="keyword">cache_key_t</span> key = getKey(sel);</span><br></pre></td></tr></table></figure><ul><li>调用 <code>getCache</code> 来获取 <code>cls</code> 的方法缓存，然后通过 <code>getKey</code> 来获取到缓存的 <code>key</code>，这里的 <code>getKey</code> 其实是将 <code>SEL</code> 类型强转成 <code>cache_key_t</code> 类型。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mask_t</span> newOccupied = cache-&gt;occupied() + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>在 <code>cache</code> 已经占用的基础上进行加 1，得到的是新的缓存占用大小 <code>newOccupied</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mask_t</span> capacity = cache-&gt;capacity();</span><br></pre></td></tr></table></figure><ul><li>然后读取现在缓存的容量 <code>capacity</code>。</li></ul><p>然后接下来是一系列的判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">    <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">    cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果缓存为空了，那么就重新申请一下内存并覆盖之前的缓存，之所以这样做是因为缓存是只读的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newOccupied &lt;= capacity / <span class="number">4</span> * <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 full. Use it as-is.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果新的缓存占用大小 <code>小于等于</code> 缓存容量的四分之三，则可以进行缓存流程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Cache is too full. Expand it.</span></span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果缓存不为空，且缓存占用大小已经超过了容量的四分之三，则需要进行扩容。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *bucket = cache-&gt;find(key, receiver);</span><br></pre></td></tr></table></figure><ul><li>通过前面生成的 <code>key</code> 在缓存中查找对应的 <code>bucket_t</code>，也就是对应的方法实现。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bucket-&gt;key() == <span class="number">0</span>) cache-&gt;incrementOccupied();</span><br><span class="line">bucket-&gt;<span class="built_in">set</span>(key, imp);</span><br></pre></td></tr></table></figure><ul><li>判断获取到的<strong>桶</strong> <code>bucket</code> 是否是新的桶，如果是的话，就在缓存里面增加一个占用大小。然后把 <code>key</code> 和 <code>imp</code> 放到桶里面。</li></ul><p><code>cache_fill_nolock</code> 的基本流程我们分析完了，这个方法主要针对的是没有缓存的情况。<br>但是这个方法里面的 <code>cache-&gt;find</code> 我们并不知道是怎么实现的，我们接着探索这个方法:</p><h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> * <span class="keyword">cache_t</span>::find(<span class="keyword">cache_key_t</span> k, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    assert(k != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bucket_t</span> *b = buckets();</span><br><span class="line">    <span class="keyword">mask_t</span> m = mask();</span><br><span class="line">    <span class="keyword">mask_t</span> begin = cache_hash(k, m);</span><br><span class="line">    <span class="keyword">mask_t</span> i = begin;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i].key() == <span class="number">0</span>  ||  b[i].key() == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((i = cache_next(i, m)) != begin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hack</span></span><br><span class="line">    Class cls = (Class)((<span class="keyword">uintptr_t</span>)<span class="keyword">this</span> - offsetof(objc_class, cache));</span><br><span class="line">    <span class="keyword">cache_t</span>::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>find</code> 方法我们乍一看会发现有一个 <code>do-while</code> 循环，因为这个方法的作用是根据 <code>key</code> 查找 <code>IMP</code>，但需要注意的是，这里返回的并不是一个 <code>IMP</code>，而是 <code>bucket_t</code> 结构体指针。</p><ul><li>通过 <code>buckets()</code> 方法获取当前 <code>cache_t</code> 下所有的缓存<code>桶</code>。</li><li>通过 <code>mask()</code> 方法获取当前 <code>cache_t</code> 的缓存大小减一的值 <code>mask_t</code>。</li><li>然后把 <code>mask_t</code> 的值作为循环的索引。</li><li>在 <code>do-while</code> 循环里遍历整个 <code>bucket_t</code>，如果 <code>key</code> 为 0，说明当前索引位置上还没有缓存过方法，则需要停止循环，返回当前位置上的 <code>bucket_t</code>；如果 <code>key</code> 为要查询的 <code>k</code>，说明缓存命中了，则直接返回结果。</li><li>这里的循环遍历是通过 <code>cache_next</code> 方法实现的，这个方法内部就是当前下标 <code>i</code> 与 <code>mask_t</code> 的值进行与操作，来实现索引更新的。</li></ul><h1 id="cache-t-探索后的疑问点"><a href="#cache-t-探索后的疑问点" class="headerlink" title="cache_t 探索后的疑问点"></a><code>cache_t</code> 探索后的疑问点</h1><p>整个 <code>cache_t</code> 的工作流程，简略描述如下：</p><ul><li>当前查找的 <code>IMP</code> 没有被缓存，调用 <code>cache_fill_nolock</code> 方法进行填充缓存。</li><li>当前查找的 <code>IMP</code> 已经被缓存了，然后判断缓存容量是否已经达到 <code>3/4</code> 的临界点<ul><li>如果已经到了临界点，则需要进行扩容，扩容大小为原来缓存大小的 2 倍。扩容后处于效率的考虑，会清空之前的内容，然后把当前要查找的 <code>IMP</code> 通过 <code>cache_fill_nolock</code> 方法缓存起来。</li><li>如果没有到临界点，那么直接返回找到的 <code>IMP</code>。</li></ul></li></ul><p>我们梳理完 <code>cache_t</code> 的大致流程之后，我们还有一些遗留问题没有解决，接下来一一来解决一下。</p><h2 id="3-1-mask-的作用"><a href="#3-1-mask-的作用" class="headerlink" title="3.1 mask 的作用"></a>3.1 <code>mask</code> 的作用</h2><p>我们先回顾一下 <code>mask</code> 出现在了哪些地方:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setBucketsAndMask(newBuckets, newCapacity - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">cache_t</span>::setBucketsAndMask(struct <span class="keyword">bucket_t</span> *newBuckets, <span class="keyword">mask_t</span> newMask)</span><br><span class="line">&#123;</span><br><span class="line">    mega_barrier();</span><br><span class="line"></span><br><span class="line">    _buckets = newBuckets;</span><br><span class="line">    </span><br><span class="line">    mega_barrier();</span><br><span class="line">    </span><br><span class="line">    _mask = newMask;</span><br><span class="line">    _occupied = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mask_t</span> <span class="keyword">cache_t</span>::capacity() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mask() ? mask()+<span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，<code>mask</code> 是作为 <code>cache_t</code> 的属性存在的，它代表的是<strong>缓存容量的大小减一</strong>的值。这一点在 <code>setBucketsAndMask</code> 与 <code>capacity</code> 方法中可以得到证实。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cache_fill_nolock &#123;</span><br><span class="line">    <span class="keyword">cache_key_t</span> key = getKey(sel);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bucket_t</span> *bucket = cache-&gt;find(key, receiver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Class points to cache. SEL is key. Cache buckets store SEL+IMP.</span></span><br><span class="line">    <span class="comment">// Caches are never built in the dyld shared cache.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> mask_t <span class="title">cache_hash</span><span class="params">(<span class="keyword">cache_key_t</span> key, <span class="keyword">mask_t</span> mask)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">mask_t</span>)(key &amp; mask);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> mask_t <span class="title">cache_next</span><span class="params">(<span class="keyword">mask_t</span> i, <span class="keyword">mask_t</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i+<span class="number">1</span>) &amp; mask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的伪代码，<code>cache_fill_nolock</code> 方法里面，会先根据要查找的 <code>sel</code> 强转成 <code>cache_key_t</code> 结构，这是因为 <code>sel</code> 其实为方法名:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023814.jpg" alt></p><p>而经过强转之后为:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023825.jpg" alt></p><p>也就是说最后缓存的 <code>key</code> 其实是一个无符号长整型值，这样相对于直接拿字符串来作为键值，明显效率更高。</p><p>经过强转之后，把 <code>key</code> 传给 <code>find</code> 方法。然后会有一个 <code>cache_hash</code> 方法，其注释如下：</p><blockquote><p>类指向缓存，<code>SEL</code> 是键，<code>buckets</code>缓存存储的是 <code>SEL</code> + <code>IMP</code>。<br>方法缓存永远不会存储在 <code>dyld</code> 共享缓存里面。</p></blockquote><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023837.jpg" alt></p><p>实际测试如上图所示，<code>cache_hash</code> 方法其实就是哈希算法，得到的是一个哈希值。拿到这个哈希值后就可以在哈希表中进行查询。在 <code>find</code> 方法中就是获得索引的起始值。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023851.jpg" alt></p><p>通过上图的测试我们可以得出这里是使用的 <code>LRU</code> 缓存算法。</p><blockquote><p><code>LRU</code> 算法的全称是 <code>Least Recently Used</code> ，也就是最近最少使用策略。这个策略的核心思想就是先淘汰最近最少使用的内容。</p></blockquote><h2 id="capacity-的变化"><a href="#capacity-的变化" class="headerlink" title="capacity 的变化"></a><code>capacity</code> 的变化</h2><p><code>capacity</code> 的变化主要发生在扩容的时候，当缓存已经占满了四分之三的时候，会进行两倍原来缓存空间大小的扩容，这一步是为了避免哈希冲突。</p><h2 id="为什么是在-3-4-时进行扩容"><a href="#为什么是在-3-4-时进行扩容" class="headerlink" title="为什么是在 3/4 时进行扩容"></a>为什么是在 <code>3/4</code> 时进行扩容</h2><p>在哈希这种数据结构里面，有一个概念叫<strong>装载因子</strong>，装载因子是用来表示空位的多少。其公式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">散列表的装载因子=填入表中的元素个数/散列表的长度</span><br></pre></td></tr></table></figure><p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。<br>苹果这里设计的装载因子显然为 1 - 3/4 = 1/4 =&gt; <strong>0.25</strong> 。<br>因为本质上方法缓存就是为了更快的执行效率，所以为了避免发生哈希冲突，在采用<code>开放寻址法</code>的前提下，尽可能小的装载因子可以提高散列表的性能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initial cache bucket count. INIT_CACHE_SIZE must be a power of two. */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">2</span>,</span><br><span class="line">    INIT_CACHE_SIZE      = (<span class="number">1</span> &lt;&lt; INIT_CACHE_SIZE_LOG2)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br></pre></td></tr></table></figure><p>初始化的缓存大小是 1 左移 2，结果为 4。然后在 <code>reallocate</code> 方法进行一下缓存的重新开辟。这也就意味着初始的缓存空间大小为 4。</p><h2 id="方法缓存是否有序"><a href="#方法缓存是否有序" class="headerlink" title="方法缓存是否有序"></a>方法缓存是否有序</h2><p>方法缓存是无序的，这是因为计算缓存下标是一个哈希算法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> mask_t <span class="title">cache_hash</span><span class="params">(<span class="keyword">cache_key_t</span> key, <span class="keyword">mask_t</span> mask)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mask_t</span>)(key &amp; mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>cache_hash</code> 之后计算出来的下标并不是有序的，下标值取决于 <code>key</code> 和 <code>mask</code> 的值。</p><h2 id="bucket-与-mask-capacity-sel-imp-的关系"><a href="#bucket-与-mask-capacity-sel-imp-的关系" class="headerlink" title="bucket 与 mask, capacity, sel, imp 的关系"></a>bucket 与 mask, capacity, sel, imp 的关系</h2><p>一个类有一个属性 <code>cache_t</code>，而一个 <code>cache_t</code> 的 <code>buckets</code> 会有多个 <code>bucket</code>。一个 <code>bucket</code> 存储的是 <code>imp</code> 和 <code>cache_key_t</code> 。</p><p><code>mask</code> 的值对于 <code>bucket</code> 来说，主要是用来在缓存查找时的哈希算法。<br>而 <code>capacity</code> 则可以获取到 <code>cache_t</code> 中 <code>bucket</code> 的数量。</p><p><code>sel</code> 在缓存的时候是被强转成了 <code>cache_key_t</code> 的形式，更方便查询使用。<br><code>imp</code> 则是函数指针，也就是方法的具体实现，缓存的主要目的就是通过一系列策略让编译器更快的执行消息发送的逻辑。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>OC</code> 中实例方法缓存在类上面，类方法缓存在元类上面。</li><li><code>cache_t</code> 缓存会提前进行扩容防止溢出。</li><li>方法缓存是为了最大化的提高程序的执行效率。</li><li>苹果在方法缓存这里用的是<code>开放寻址法</code>来解决哈希冲突。</li><li>通过 <code>cache_t</code> 我们可以进一步延伸去探究 <code>objc_msgSend</code>，因为查找方法缓存是属于 <code>objc_msgSend</code> 查找方法实现的快速流程。</li></ul><p>我们下一篇将开始探索 <code>iOS</code> 中方法的底层原理，敬请期待~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇我们一起探索了 &lt;code&gt;iOS&lt;/code&gt; 类的底层原理，其中比较重要的四个属性我们都简单的过了一遍，我们接下来要重点探索第三个属性 &lt;code&gt;cache_t&lt;/code&gt;，对于这个属性，我们可以学习到苹果对于缓存的设计与理解，同时也会接触到消息发送相关的知识。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - 类</title>
    <link href="http://leejunhui.com/2020/01/06/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB/"/>
    <id>http://leejunhui.com/2020/01/06/iOS-底层探索-类/</id>
    <published>2020-01-05T18:34:29.000Z</published>
    <updated>2020-01-18T18:30:41.823Z</updated>
    
    <content type="html"><![CDATA[<p>我们在前面探索了 <code>iOS</code> 中的对象原理，面向对象编程中有一句名言:</p><blockquote><p>万物皆对象</p></blockquote><p>那么对象又是从哪来的呢？有过面向对象编程基础的同学肯定都知道是类派生出对象的，那么今天我们就一起来探索一下类的底层原理吧。</p><a id="more"></a><h1 id="iOS-中的类到底是什么？"><a href="#iOS-中的类到底是什么？" class="headerlink" title="iOS 中的类到底是什么？"></a><code>iOS</code> 中的类到底是什么？</h1><p>我们在日常开发中大多数情况都是从 <code>NSObject</code> 这个基类来派生出我们需要的类。那么在 <code>OC</code> 底层，我们的类 <code>Class</code> 到底被编译成什么样子了呢？</p><p>我们新建一个 <code>macOS</code> 控制台项目，然后新建一个 <code>Animal</code> 类出来。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Animal.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Animal.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Animal *animal = [[Animal alloc] init];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, animal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在终端执行 <code>clang</code> 命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure><p>这个命令是将我们的 <code>main.m</code> 重写成 <code>main.cpp</code>，我们打开这个文件搜索 <code>Animal</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022446.jpg" alt></p><p>我们发现有多个地方都出现了 <code>Animal</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> <span class="title">Animal</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal_IMPL</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> <span class="title">NSObject_IVARS</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">objc_getClass(<span class="string">"Animal"</span>)</span><br></pre></td></tr></table></figure><p>我们先全局搜索第一个 <code>typedef struct objc_object</code>，发现有 843 个结果</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022507.jpg" alt></p><p>我们通过 <code>Command + G</code> 快捷键快速翻阅一下，最终在 7626 行找到了 <code>Class</code> 的定义:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></table></figure><p>由这行代码我们可以得出一个结论，<code>Class</code> 类型在底层是一个结构体类型的指针，这个结构体类型为 <code>objc_class</code>。<br>再搜索 <code>typedef struct objc_class</code> 发现搜不出来了，这个时候我们需要在 <code>objc4-756</code> 源码中进行探索了。</p><p>我们在 <code>objc4-756</code> 源码中直接搜索 <code>struct objc_class</code> ，然后定位到 <code>objc-runtime-new.h</code> 文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，细心的读者可能会发现，我们在前面探索对象原理中遇到的 <code>objc_object</code> 再次出现了，并且这次是作为 <code>objc_class</code> 的父类。这里再次引用那句经典名言 <strong>万物皆对象</strong>，也就是说类其实也是一种<strong>对象</strong>。</p><p>由此，我们可以简单总结一下类和对象在 <code>C</code> 和 <code>OC</code> 中分别的定义</p><table><thead><tr><th>C</th><th>OC</th></tr></thead><tbody><tr><td>objc_object</td><td>NSObject</td></tr><tr><td>objc_class</td><td>NSObject(Class)</td></tr></tbody></table><h1 id="类的结构是什么样的呢？"><a href="#类的结构是什么样的呢？" class="headerlink" title="类的结构是什么样的呢？"></a>类的结构是什么样的呢？</h1><p>通过上面的探索，我们已经知道了类本质上也是对象，而日常开发中常见的成员变量、属性、方法、协议等都是在类里面存在的，那么我们是不是可以猜想在 <code>iOS</code> 底层，类其实就存储了这些内容呢？</p><p>我们可以通过分析源码来验证我们的猜想。</p><p>从上一节中 <code>objc_class</code> 的定义处，我们可以梳理出 <code>Class</code> 中的 4 个属性</p><ul><li><code>isa</code> 指针</li><li><code>superclass</code> 指针</li><li><code>cache</code></li><li><code>bits</code></li></ul><blockquote><p>需要值得注意的是，这里的 <code>isa</code> 指针在这里是隐藏属性.</p></blockquote><h2 id="isa-指针"><a href="#isa-指针" class="headerlink" title="isa 指针"></a><code>isa</code> 指针</h2><p>首先是 <code>isa</code> 指针，我们之前已经探索过了，在对象初始化的时候，通过 <code>isa</code> 可以让对象和类关联，这一点很好理解，可是为什么在类结构里面还会有 <code>isa</code> 呢？看过上一篇文章的同学肯定知道这个问题的答案了。没错，就是<strong>元类</strong>。我们的对象和类关联起来需要 <code>isa</code>，同样的，类和元类之间关联也需要 <code>isa</code>。</p><h2 id="superclass-指针"><a href="#superclass-指针" class="headerlink" title="superclass 指针"></a><code>superclass</code> 指针</h2><p>顾名思义，<code>superclass</code> 指针表明当前类指向的是哪个父类。一般来说，类的根父类基本上都是 <code>NSObject</code> 类。根元类的父类也是 <code>NSObject</code> 类。</p><h2 id="cache-缓存"><a href="#cache-缓存" class="headerlink" title="cache 缓存"></a><code>cache</code> 缓存</h2><p><code>cache</code> 的数据结构为 <code>cache_t</code>，其定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;</span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;</span><br><span class="line">    </span><br><span class="line">    ...省略代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的缓存里面存放的是什么呢？是属性？是实例变量？还是方法？我们可以通过阅读 <code>objc-cache.mm</code> 源文件来解答这个问题。</p><blockquote><ul><li>objc-cache.m</li><li>Method cache management</li><li>Cache flushing</li><li>Cache garbage collection</li><li>Cache instrumentation</li><li>Dedicated allocator for large caches</li></ul></blockquote><p>上面是 <code>objc-cache.mm</code> 源文件的注释信息，我们可以看到 <code>Method cache management</code> 的出现，翻译过来就是方法缓存管理。那么是不是就是说 <code>cache</code> 属性就是缓存的方法呢？而 <code>OC</code> 中的方法我们现在还没有进行探索，先假设我们已经掌握了相关的底层原理，这里先简单提一下。</p><blockquote><p>我们在类里面编写的方法，在底层其实是以 <code>SEL</code> + <code>IMP</code> 的形式存在。<code>SEL</code> 就是方法的选择器，而 <code>IMP</code> 则是具体的方法实现。这里可以以书籍的目录以及内容来类比，我们查找一篇文章的时候，需要先知道其标题(<code>SEL</code>)，然后在目录中看有没有对应的标题，如果有那么就翻到对应的页，最后我们就找到了我们想要的内容。当然，<code>iOS</code> 中方法要比书籍的例子复杂一些，不过暂时可以这么简单的理解，后面我们会深入方法的底层进行探索。</p></blockquote><h2 id="bits-属性"><a href="#bits-属性" class="headerlink" title="bits 属性"></a><code>bits</code> 属性</h2><p><code>bits</code> 的数据结构类型是 <code>class_data_bits_t</code>，同时也是一个结构体类型。而我们阅读 <code>objc_class</code> 源码的时候，会发现很多地方都有 <code>bits</code> 的身影，比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">    <span class="keyword">return</span> bits.data();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCustomRR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ! bits.hasDefaultRR();</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canAllocFast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(!isFuture());</span><br><span class="line">    <span class="keyword">return</span> bits.canAllocFast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里值得我们注意的是，<code>objc_class</code> 的 <code>data()</code> 方法其实是返回的 <code>bits</code> 的 <code>data()</code> 方法，而通过这个 <code>data()</code> 方法，我们发现诸如类的字节对齐、<code>ARC</code>、元类等特性都有 <code>data()</code> 的出现，这间接说明 <code>bits</code> 属性其实是个大容器，有关于内存管理、C++ 析构等内容在其中有定义。</p><p>这里我们会遇到一个十分重要的知识点: <code>class_rw_t</code>，<code>data()</code> 方法的返回值就是 <code>class_rw_t</code> 类型的指针对象。我们在本文后面会重点介绍。</p><h1 id="类的属性存在哪？"><a href="#类的属性存在哪？" class="headerlink" title="类的属性存在哪？"></a>类的属性存在哪？</h1><p>上一节我们对 <code>OC</code> 中类结构有了基本的了解，但是我们平时最常打交道的内容-<strong>属性</strong>，我们还不知道它究竟是存在哪个地方。接下来我们要做一件事情，就是在 <code>objc4-756</code> 的源码中新建一个 <code>Target</code>，为什么不直接用上面的 <code>macOS</code> 命令行项目呢？因为我们要开始结合 <code>LLDB</code> 打印一些类的内部信息，所以只能是新建一个依靠于 <code>objc4-756</code> 源码 <code>project</code> 的 <code>target</code> 出来。同样的，我们还是选择 <code>macOS</code> 的命令行作为我们的 <code>target</code>。</p><p>接着我们新建一个类 <code>Person</code>，然后添加一些实例变量和属性出来。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *hobby;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *nickName;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        Class pClass = object_getClass(p);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们打一个断点到 <code>main.m</code> 文件中的 <code>NSLog</code> 语句处，然后运行刚才新建的 <code>target</code>。</p><p><code>target</code> 跑起来之后，我们在控制台先打印输出一下 <code>pClass</code> 的内容:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022526.jpg" alt></p><h2 id="类的内存结构"><a href="#类的内存结构" class="headerlink" title="类的内存结构"></a>类的内存结构</h2><p>我们这个时候需要借助指针平移来探索，而对于类的内存结构我们先看下面这张表格:</p><table><thead><tr><th>类的内存结构</th><th>大小(字节)</th></tr></thead><tbody><tr><td>isa</td><td>8</td></tr><tr><td>superclass</td><td>8</td></tr><tr><td>cache</td><td>16</td></tr></tbody></table><p>前两个大小很好理解，因为 <code>isa</code> 和 <code>superclass</code> 都是结构体指针，而在 <code>arm64</code> 环境下，一个结构体指针的内存占用大小为 8 字节。而第三个属性 <code>cache</code> 则需要我们进行抽丝剥茧了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cache_t</span> cache;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span> <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;  <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">mask_t</span> _occupied; <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">mask_t</span>;</span><br></pre></td></tr></table></figure><p>从上面的代码我们可以看出，<code>cache</code> 属性其实是 <code>cache_t</code> 类型的结构体，其内部有一个 8 字节的结构体指针，有 2 个各为 4 字节的 <code>mask_t</code>。所以加起来就是 16 个字节。也就是说前三个属性总共的内存偏移量为 8 + 8 + 16 = 32 个字节，32 是 10 进制的表示，在 16 进制下就是 20。</p><h2 id="探索-bits-属性"><a href="#探索-bits-属性" class="headerlink" title="探索 bits 属性"></a>探索 <code>bits</code> 属性</h2><p>我们刚才在控制台打印输出了 <code>pClass</code> 类对象的内容，我们简单画个图如下所示:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022603.jpg" alt></p><p>那么，类的 <code>bits</code> 属性的内存地址顺理成章的就是在 <code>isa</code> 的初始偏移量地址处进行 16 进制下的 20 递增。也就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1000021c8 + 0x20 = 0x1000021e8</span><br></pre></td></tr></table></figure><p>我们尝试打印这个地址，注意这里需要强转一下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022621.jpg" alt></p><p>这里报错了，问题其实是出在我们的 <code>target</code> 没有关联上 <code>libobjc.A.dylib</code> 这个动态库，我们关联上重新运行项目</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022633.jpg" alt></p><p>我们重复一遍上面的流程:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022639.jpg" alt></p><p>这一次成功了。在 <code>objc_class</code> 源码中有:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">    <span class="keyword">return</span> bits.data();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不妨打印一下里面的内容：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022649.jpg" alt></p><p>返回了一个 <code>class_rw_t</code> 指针对象。我们在 <code>objc4-756</code> 源码中搜索 <code>class_rw_t</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;</span><br><span class="line">    <span class="keyword">property_array_t</span> properties;</span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    </span><br><span class="line">    ...省略代码...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然的，<code>class_rw_t</code> 也是一个结构体类型，其内部有 <code>methods</code>、<code>properties</code>、<code>protocols</code> 等我们十分熟悉的内容。我们先猜想一下，我们的属性应该存放在 <code>class_rw_t</code> 的 <code>properties</code> 里面。为了验证我们的猜想，我们接着进行 <code>LLDB</code> 打印:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022702.jpg" alt></p><p>我们再接着打印 <code>properties</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022708.jpg" alt></p><p><code>properties</code> 居然是空的，难道是 bug?其实不然，这里我们还漏掉了一个非常重要的属性 <code>ro</code>。我们来到它的定义:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line"></span><br><span class="line">    ...隐藏代码...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ro</code> 的类型是 <code>class_ro_t</code> 结构体，它包含了 <code>baseMethodList</code>、<code>baseProtocols</code>、<code>ivars</code>、<code>baseProperties</code> 等属性。我们刚才在 <code>class_rw_t</code> 中没有找到我们声明在 <code>Person</code> 类中的实例变量 <code>hobby</code> 和属性 <code>nickName</code>，那么希望就在 <code>class_ro_t</code> 身上了，我们打印看看它的内容:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022719.jpg" alt></p><p>根据名称我们猜测属性应该在 <code>baseProperties</code> 里面，我们打印看看:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022728.jpg" alt></p><p>Bingo! 我们的属性 <code>nickName</code> 被找到了，那么我们的实例变量 <code>hobby</code> 呢？我们从 $8 的 count 为 1 可以得知肯定不在 <code>baseProperites</code> 里面。根据名称我们猜测应该是在 <code>ivars</code> 里面。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022739.jpg" alt></p><p>哈哈，<code>hobby</code> 实例变量也被我们找到了，不过这里的 <code>count</code> 为什么是 2 呢？我们打印第二个元素看看:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022750.jpg" alt></p><p>结果为 <code>_nickName</code>。这一结果证实了编译器会帮助我们给属性 <code>nickName</code> 生成一个带下划线前缀的实例变量 <code>_nickName</code>。</p><p>至此，我们可以得出以下结论:</p><blockquote><p><code>class_ro_t</code> 是在编译时就已经确定了的，存储的是类的成员变量、属性、方法和协议等内容。<br><code>class_rw_t</code> 是可以在运行时来拓展类的一些属性、方法和协议等内容。</p></blockquote><h1 id="类的方法存在哪？"><a href="#类的方法存在哪？" class="headerlink" title="类的方法存在哪？"></a>类的方法存在哪？</h1><p>研究完了类的属性是怎么存储的，我们再来看看类的方法。</p><p>我们先给我们的 <code>Person</code> 类增加一个 <code>sayHello</code> 的实例方法和一个 <code>sayHappy</code> 的类方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.h</span></span><br><span class="line">- (<span class="keyword">void</span>)sayHello;</span><br><span class="line">+ (<span class="keyword">void</span>)sayHappy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person.m</span></span><br><span class="line">- (<span class="keyword">void</span>)sayHello</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sayHappy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上面的思路，我们直接读取 <code>class_ro_t</code> 中的 <code>baseMethodList</code> 的内容:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022801.jpg" alt></p><p><code>sayHello</code> 被打印出来了，说明 <code>baseMethodList</code> 就是存储实例方法的地方。我们接着打印剩下的内容:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022806.jpg" alt></p><p>可以看到 <code>baseMethodList</code> 中除了我们的实例方法 <code>sayHello</code> 外，还有属性 <code>nickName</code> 的 <code>getter</code> 和 <code>setter</code> 方法以及一个 <code>C++</code> 析构方法。但是我们的类方法 <code>sayHappy</code> 并没有被打印出来。</p><h1 id="类的类方法存在哪？"><a href="#类的类方法存在哪？" class="headerlink" title="类的类方法存在哪？"></a>类的类方法存在哪？</h1><p>我们上面已经得到了属性，实例方法的是怎么样存储，还留下了一个疑问点，就是类方法是怎么存储的，接下来我们用 <code>Runtime</code> 的 API 来实际测试一下。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="keyword">void</span> testInstanceMethod_classToMetaclass(Class pClass)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *className = class_getName(pClass);</span><br><span class="line">    Class metaClass = objc_getMetaClass(className);</span><br><span class="line">    </span><br><span class="line">    Method method1 = class_getInstanceMethod(pClass, <span class="keyword">@selector</span>(sayHello));</span><br><span class="line">    Method method2 = class_getInstanceMethod(metaClass, <span class="keyword">@selector</span>(sayHello));</span><br><span class="line"></span><br><span class="line">    Method method3 = class_getInstanceMethod(pClass, <span class="keyword">@selector</span>(sayHappy));</span><br><span class="line">    Method method4 = class_getInstanceMethod(metaClass, <span class="keyword">@selector</span>(sayHappy));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p-%p-%p-%p"</span>,method1,method2,method3,method4);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        Class pClass = object_getClass(p);</span><br><span class="line">        </span><br><span class="line">        testInstanceMethod_classToMetaclass(pClass);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后打印结果如下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022824.jpg" alt></p><p>首先 <code>testInstanceMethod_classToMetaclass</code> 方法测试的是分别从类和元类去获取实例方法、类方法的结果。由打印结果我们可以知道：</p><ul><li>对于类对象来说，<code>sayHello</code> 是实例方法，存储于类对象的内存中，不存在于元类对象中。而 <code>sayHappy</code> 是类方法，存储于元类对象的内存中，不存在于类对象中。</li><li>对于元类对象来说，<code>sayHello</code> 是类对象的实例方法，跟元类没关系；<code>sayHappy</code> 是元类对象的实例方法，所以存在元类中。</li></ul><p>我们再接着测试:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="keyword">void</span> testClassMethod_classToMetaclass(Class pClass)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *className = class_getName(pClass);</span><br><span class="line">    Class metaClass = objc_getMetaClass(className);</span><br><span class="line">    </span><br><span class="line">    Method method1 = class_getClassMethod(pClass, <span class="keyword">@selector</span>(sayHello));</span><br><span class="line">    Method method2 = class_getClassMethod(metaClass, <span class="keyword">@selector</span>(sayHello));</span><br><span class="line"></span><br><span class="line">    Method method3 = class_getClassMethod(pClass, <span class="keyword">@selector</span>(sayHappy));</span><br><span class="line">    Method method4 = class_getClassMethod(metaClass, <span class="keyword">@selector</span>(sayHappy));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p-%p-%p-%p"</span>,method1,method2,method3,method4);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        Class pClass = object_getClass(p);</span><br><span class="line">        </span><br><span class="line">        testClassMethod_classToMetaclass(pClass);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后打印结果如下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022834.jpg" alt></p><p>从结果我们可以看出，对于类对象来说，通过 <code>class_getClassMethod</code> 获取 <code>sayHappy</code> 是有值的，而获取 <code>sayHello</code> 是没有值的；对于元类对象来说，通过 <code>class_getClassMethod</code> 获取 <code>sayHappy</code> 也是有值的，而获取 <code>sayHello</code> 是没有值的。这里第一点很好理解，但是第二点会有点让人糊涂，不是说类方法在元类中是体现为对象方法的吗？怎么通过 <code>class_getClassMethod</code> 从元类中也能拿到 <code>sayHappy</code>，我们进入到 <code>class_getClassMethod</code> 方法内部可以解开这个疑惑:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Method <span class="title">class_getClassMethod</span><span class="params">(Class cls, SEL sel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls  ||  !sel) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> class_getInstanceMethod(cls-&gt;getMeta(), sel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Class <span class="title">getMeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isMetaClass()) <span class="keyword">return</span> (Class)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>-&gt;ISA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很清楚的看到，<code>class_getClassMethod</code> 方法底层其实调用的是 <code>class_getInstanceMethod</code>，而 <code>cls-&gt;getMeta()</code> 方法底层的判断逻辑是如果已经是元类就返回，如果不是就返回类的 <code>isa</code>。这也就解释了上面的 <code>sayHappy</code> 为什么会出现在最后的打印中了。</p><p>除了上面的 <code>LLDB</code> 打印，我们还可以通过 <code>isa</code> 的方式来验证类方法存放在元类中。</p><ul><li>通过 isa 在类对象中找到元类</li><li>打印元类的 baseMethodsList</li></ul><p>具体的过程笔者不再赘述。</p><h1 id="类和元类的创建时机"><a href="#类和元类的创建时机" class="headerlink" title="类和元类的创建时机"></a>类和元类的创建时机</h1><p>我们在探索类和元类的时候，对于其创建时机还不是很清楚，这里我们先抛出结论：</p><ul><li>类和元类是在编译期创建的，即在进行 alloc 操作之前，类和元类就已经被编译器创建出来了。</li></ul><p>那么如何来证明呢，我们有两种方式可以来证明:</p><ul><li><code>LLDB</code> 打印类和元类的指针</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022845.jpg" alt></p><ul><li>编译项目后，使用 <code>MachoView</code> 打开程序二进制可执行文件查看:</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022852.jpg" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>类和元类创建于编译时，可以通过 <code>LLDB</code> 来打印类和元类的指针，或者 <code>MachOView</code> 查看二进制可执行文件</li><li>万物皆对象：类的本质就是对象</li><li>类在 <code>class_ro_t</code> 结构中存储了编译时确定的属性、成员变量、方法和协议等内容。</li><li>实例方法存放在类中</li><li>类方法存放在元类中</li></ul><p>我们完成了对 <code>iOS</code> 中类的底层探索，下一章我们将对类的缓存进行深一步探索，敬请期待~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在前面探索了 &lt;code&gt;iOS&lt;/code&gt; 中的对象原理，面向对象编程中有一句名言:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;万物皆对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么对象又是从哪来的呢？有过面向对象编程基础的同学肯定都知道是类派生出对象的，那么今天我们就一起来探索一下类的底层原理吧。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - calloc&amp;isa</title>
    <link href="http://leejunhui.com/2020/01/05/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-calloc-isa/"/>
    <id>http://leejunhui.com/2020/01/05/iOS-底层探索-calloc-isa/</id>
    <published>2020-01-05T03:37:49.000Z</published>
    <updated>2020-01-18T18:22:01.589Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章主要我们探索了 <code>iOS</code>  对象的 <code>alloc</code> 和 <code>init</code> 以及对象是怎么开辟内存以及初始化的，如果在对象身上增加一些属性，是否会影响内存开辟呢？还有一个遗留问题就是通过 <code>calloc</code> ，我们的对象有了内存地址，但是对象结构里面的 <code>isa</code> 是怎么关联到我们的对象的内存地址的呢。</p><a id="more"></a><h1 id="calloc-底层探索"><a href="#calloc-底层探索" class="headerlink" title="calloc 底层探索"></a><code>calloc</code> 底层探索</h1><p>在探索 <code>calloc</code> 底层前，我们先补充一下内存对齐相关的知识点。</p><h2 id="内存对齐三原则"><a href="#内存对齐三原则" class="headerlink" title="内存对齐三原则"></a>内存对齐三原则</h2><p>在 <code>iOS</code> 中，对象的属性需要进行内存对齐，而对象本身也需要进行内存对齐。<br>内存对齐有三原则</p><ul><li>数据成员对齐原则: 结构( <code>struct</code> )(或联合( <code>union</code> ))的数据成员，第<br><br>一个数据成员放在 offset 为 0 的地方，以后每个数据成员存储的起始位置要<br><br>从该成员大小或者成员的子成员大小</li><li>结构体作为成员: 如果一个结构里有某些结构体成员,则结构体成员要从<br><br>其内部最大元素大小的整数倍地址开始存储</li><li>收尾工作: 结构体的总大小,也就是 <code>sizeof</code> 的结果,.必须是其内部最大<br><br>成员的整数倍.不足的要补⻬。<br><br>翻译一下就是：</li><li><strong>前面的地址必须是后面的地址正数倍,不是就补齐</strong></li><li>结构体里面的嵌套结构体大小要以该<strong>嵌套结构体最大元素大小的整数倍</strong></li><li><strong>整个 **`</strong>Struct<strong>` **的地址必须是最大字节的整数倍</strong></li></ul><h2 id="对象申请内存和系统开辟内存"><a href="#对象申请内存和系统开辟内存" class="headerlink" title="对象申请内存和系统开辟内存"></a>对象申请内存和系统开辟内存</h2><p>我们通过打印下面的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%lu - %lu"</span>,class_getInstanceSize([p <span class="keyword">class</span>]),malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(p)));</span><br></pre></td></tr></table></figure><p>可以发现对象自己申请的内存大小与系统实际给我们开辟的大小时不一样的，这里对象申请的内存大小是 <strong>40</strong> 个字节，而系统开辟的是 <strong>48</strong> 个字节。</p><p>40 个字节不难理解，是因为当前对象有 4 个属性，有三个属性为 8 个字节，有一个属性为 4个字节，再加上 isa 的 8 个字节，就是 32 + 4 = 36 个字节，然后根据内存对齐原则，36 不能被 8 整除，36 往后移动刚好到了 40 就是 8 的倍数，所以内存大小为 40。</p><p>48 个字节的话需要我们探索 <code>calloc</code> 的底层原理。</p><p>这里还有一个注意点，就是 <code>class_getInstanceSize</code> 和 <code>malloc_size</code> 对同一个对象返回的结果不一样的，原因是 <code>malloc_size</code> 是直接返回的 <code>calloc</code> 之后的指针的大小，回忆上一节课，这里有一步在调用 <code>calloc</code> 之前的操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">    size_t size = alignedInstanceSize() + extraBytes;</span><br><span class="line">    // CF requires all objects be at least 16 bytes.</span><br><span class="line">    if (size &lt; 16) size = 16;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>class_getInstanceSize</code> 内部实现是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t class_getInstanceSize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return 0;</span><br><span class="line">    return cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 <code>class_getInstanceSize</code> 会输出 8 个字节，<code>malloc_size</code> 会输出 16 个字节，当然前提是该对象没有任何属性。</p><h2 id="探索-calloc-底层"><a href="#探索-calloc-底层" class="headerlink" title="探索 calloc 底层"></a>探索 calloc 底层</h2><p>我们从 <code>calloc</code> 函数出发，但是我们直接在 <code>libObjc</code> 的源码中是找不到其对应实现的，通过观察 Xcode 我们知道其实应该找 <code>libMalloc</code> 源码才对:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021547.jpg" alt></p><p>这里有个小技巧，其实我们研究的是 <code>calloc</code> 的底层原理，而 <code>libObjc</code> 和 <code>libMalloc</code> 是相互独立的，所以在 <code>libMalloc</code> 源码里面，我们没必要去走 <code>calloc</code> 前面的流程了。我们通过断点调试 <code>libObjc</code> 源码可以知道第二个参数是 40: (这是因为当前发送 <code>alloc</code> 消息的对象有 4 个属性，每个属性 8 个字节，再加上 isa 的 8 个字节，所以就是 40 个字节)</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021606.jpg" alt></p><p>接下来我们打开 <code>libMalloc</code> 的源码，在新建的 target 中直接手动声明如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *p = calloc(1, 40);</span><br><span class="line">NSLog(@&quot;%lu&quot;,malloc_size(p));</span><br></pre></td></tr></table></figure><p>但 <code>Command + Run</code> 之后我们会看到报错信息:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021741.jpg" alt></p><p>这个时候我们会使用搜索大法，直接 <code>Command + Shift + F</code> 进行全局搜索对应的符号，但是会发现找不到，我们再仔细观察，这些符号都是位于 <code>.o</code> 文件里面的，所以我们可以去掉符号前面的下划线再进行搜索，这个时候就可以把对应的代码注释然后重新运行了。</p><p>运行之后我们一直沿着源码断点下去，会来到这么一段代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = zone-&gt;calloc(zone, num_items, size);</span><br></pre></td></tr></table></figure><p>我们如果直接去找 <code>calloc</code>，就会递归了，所以我们需要点进去，然后我们会发现一个很复杂的东西出现了:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021755.jpg" alt></p><p>这里我们可以直接在断点处使用 <code>LLDB</code> 命令打印这行代码来看具体实现是位于哪个文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p zone-&gt;calloc</span><br><span class="line">输出: (void *(*)(_malloc_zone_t *, size_t, size_t)) $1 = 0x00000001003839c7 (.dylib`default_zone_calloc at malloc.c:249)</span><br></pre></td></tr></table></figure><p>也就是说 <code>zone-&gt;alloc</code> 的真正实现是在 <code>malloc.c</code> 源文件的249行处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">default_zone_calloc(<span class="keyword">malloc_zone_t</span> *zone, <span class="keyword">size_t</span> num_items, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">zone = runtime_default_zone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> zone-&gt;<span class="built_in">calloc</span>(zone, num_items, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们发现这里又是一次 <code>zone-&gt;calloc</code>，我们接着再次使用 <code>LLDB</code> 打印内存地址:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p zone-&gt;calloc</span><br><span class="line">输出: (void *(*)(_malloc_zone_t *, size_t, size_t)) $0 = 0x0000000100384faa (.dylib`nano_calloc at nano_malloc.c:884)</span><br></pre></td></tr></table></figure><p>我们再次来到 <code>nano_calloc</code> 方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">nano_calloc(nanozone_t *nanozone, size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">size_t total_bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (calloc_get_size(num_items, size, <span class="number">0</span>, &amp;total_bytes)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (total_bytes &lt;= NANO_MAX_SIZE) &#123;</span><br><span class="line"><span class="keyword">void</span> *p = _nano_malloc_check_clear(nanozone, total_bytes, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* FALLTHROUGH to helper zone */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">malloc_zone_t *zone = (malloc_zone_t *)(nanozone-&gt;helper_zone);</span><br><span class="line"><span class="keyword">return</span> zone-&gt;calloc(zone, <span class="number">1</span>, total_bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们简单分析一下，应该往 <code>_nano_malloc_check_clear</code> 里面继续走，然后我们发现 <code>_nano_malloc_check_clear</code> 里面内容非常多，这个时候我们要明确一点，我们的目的是找出 48 是怎么算出来的，经过分析之后，我们来到 <code>segregated_size_to_fit</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MALLOC_INLINE <span class="keyword">size_t</span></span><br><span class="line">segregated_size_to_fit(<span class="keyword">nanozone_t</span> *nanozone, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> *pKey)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// size = 40</span></span><br><span class="line"><span class="keyword">size_t</span> k, slot_bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == size) &#123;</span><br><span class="line">size = NANO_REGIME_QUANTA_SIZE; <span class="comment">// Historical behavior</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 40 + 16-1 &gt;&gt; 4 &lt;&lt; 4</span></span><br><span class="line"><span class="comment">// 40 - 16*3 = 48</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 16</span></span><br><span class="line">k = (size + NANO_REGIME_QUANTA_SIZE - <span class="number">1</span>) &gt;&gt; SHIFT_NANO_QUANTUM; <span class="comment">// round up and shift for number of quanta</span></span><br><span class="line">slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM;<span class="comment">// multiply by power of two quanta size</span></span><br><span class="line">*pKey = k - <span class="number">1</span>;<span class="comment">// Zero-based!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slot_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出进行的是 16 字节对齐，那么也就是说我们传入的 <code>size</code> 是 40，在经过 (40 + 16 - 1) &gt;&gt; 4 &lt;&lt; 4 操作后，结果为48，也就是16的整数倍。</p><p>总结:</p><ul><li>对象的属性是进行的 8 字节对齐</li><li>对象自己进行的是 16 字节对齐<ul><li>因为内存是连续的，通过 16 字节对齐规避风险和容错，防止访问溢出</li><li>同时，也提高了寻址访问效率，也就是<strong>空间换时间</strong></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021811.jpg" alt></p><h1 id="isa-底层探索"><a href="#isa-底层探索" class="headerlink" title="isa 底层探索"></a><code>isa</code> 底层探索</h1><h2 id="联合体位域"><a href="#联合体位域" class="headerlink" title="联合体位域"></a>联合体位域</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"><span class="meta">#if defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们探索 <code>isa</code> 的时候，会发现 <code>isa</code> 其实是一个联合体，而这其实是从内存管理层面来设计的，因为联合体是所有成员共享一个内存，联合体内存的大小取决于内部成员内存大小最大的那个元素，对于 <code>isa</code> 指针来说，就不用额外声明很多的属性，直接在内部的 <code>ISA_BITFIELD</code> 保存信息。同时由于联合体属性间是互斥的，所以 <code>cls</code> 和 <code>bits</code> 在 <code>isa</code> 初始化流程时是在两个分支中被赋值的。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021845.jpg" alt></p><h2 id="isa-结构"><a href="#isa-结构" class="headerlink" title="isa 结构"></a>isa 结构</h2><p><code>isa</code> 作为一个联合体，有一个结构体属性为 <code>ISA_BITFIELD</code>，其大小为 8 个字节，也就是 64 位。<br>下面的代码是基于 <code>arm64</code> 架构的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                      \</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span><br><span class="line">      <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span></span><br></pre></td></tr></table></figure><ul><li><code>nonpointer</code>: 表示是否对 <code>isa</code> 指针开启指针优化<ul><li>0: 纯 <code>isa</code> 指针</li><li>1: 不止是类对象地址, <code>isa</code> 中包含了类信息、对象的引用计数等</li></ul></li><li>has_assoc: 关联对象标志位，0 没有，1 存在</li><li>has_cxx_dtor: 该对象是否有 C++ 或者 Objc 的析构器,如果有析构函数,则需要做析构逻辑, 如果没有,则可以更快的释放对象</li><li>shiftcls: 存储类指针的值。开启指针优化的情况下，在 arm64 架构中有 33 位用来存储类指针。</li><li>magic: 用于调试器判断当前对象是真的对象还是没有初始化的空间</li><li>weakly_referenced: 标志对象是否被指向或者曾经指向一个 ARC 的弱变量，<br><br>没有弱引用的对象可以更快释放。</li><li>deallocating: 标志对象是否正在释放内存</li><li>has_sidetable_rc: 当对象引用技术大于 10 时，则需要借用该变量存储进位</li><li>extra_rc: 当表示该对象的引用计数值，实际上是引用计数值减 1， 例如，如果对象的引用计数为 10，那么 extra_rc 为 9。如果引用计数大于 10， 则需要使用到下面的 has_sidetable_rc。</li></ul><h2 id="isa-关联对象和类"><a href="#isa-关联对象和类" class="headerlink" title="isa 关联对象和类"></a>isa 关联对象和类</h2><p><code>isa</code> 是对象中的第一个属性，因为这一步是在继承的时候发生的，要早于对象的成员变量，属性列表，方法列表以及所遵循的协议列表。</p><p>我们在探索 <code>alloc</code> 底层原理的时候，有一个方法叫做 <code>initIsa</code>。</p><p>这个方法的作用就是初始化 <code>isa</code> 联合体位域。其中有这么一行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newisa.shiftcls = (<span class="keyword">uintptr_t</span>)cls &gt;&gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>通过这行代码，我们知道 <code>shiftcls</code> 这个位域其实存储的是类的信息。这个类就是实例化对象所指向的那个类。</p><p>通过 <code>LLDB</code> 进行调试打印，我们可以知道一个对象的 <code>isa</code> 会关联到这个对象所属的类。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021910.jpg" alt></p><p>这里的左移右移操作其实很好理解，首先我们先观察 <code>isa</code> 的 <code>ISA_BITFIELD</code> 位域的结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注：这里是x64架构</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                        \</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \</span><br><span class="line">      <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span></span><br></pre></td></tr></table></figure><p>我们可以看到，<code>ISA_BITFIELD</code> 的前 3 位是 <code>nonpointer</code>，<code>has_assoc</code>，<code>has_cxx_dtor</code>，中间 44 位是 <code>shiftcls</code> ，后面 17 位是剩余的内容，同时因为 iOS 是小端模式，那么我们就需要去掉右边的 3 位和左边的 17位，所以就会采用 &gt;&gt;3&lt;&lt;3 然后 &lt;&lt;17&gt;&gt;17 的操作了。</p><p>通过这个测试，我们就知道了 <code>isa</code> 实现了对象与类之间的关联。</p><p>我们还可以探索 <code>object_getClass</code> 底层，可以发现有这样一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return (Class)(isa.bits &amp; ISA_MASK);</span><br></pre></td></tr></table></figure><p>这行代码就是将 <code>isa</code> 中的联合体位域与上一个蒙版，这个蒙版定义是怎么样的呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br></pre></td></tr></table></figure><p><code>0x00007ffffffffff8ULL</code> 这个值我们转成二进制表示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> </span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>结果一目了然，这个蒙版就是帮我们去过滤掉除 <code>shiftcls</code> 之外的内容。</p><p>我们直接将对象的 <code>isa</code> 地址与上这个mask之后，就会得到 <code>object.class</code> 一样的内存地址。</p><h2 id="isa-走位分析"><a href="#isa-走位分析" class="headerlink" title="isa 走位分析"></a>isa 走位分析</h2><h3 id="类与元类"><a href="#类与元类" class="headerlink" title="类与元类"></a>类与元类</h3><p>我们都知道对象可以创建多个，但是类是否可以创建多个呢?<br>答案很简单，一个。那么如果来验证呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//MARK: - 分析类对象内存存在个数</span><br><span class="line">void lgTestClassNum()&#123;</span><br><span class="line">    Class class1 = [LGPerson class];</span><br><span class="line">    Class class2 = [LGPerson alloc].class;</span><br><span class="line">    Class class3 = object_getClass([LGPerson alloc]);</span><br><span class="line">    Class class4 = [LGPerson alloc].class;</span><br><span class="line">    NSLog(@&quot;\n%p-\n%p-\n%p-\n%p&quot;,class1,class2,class3,class4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印输出如下:</span><br><span class="line"></span><br><span class="line">0x100002108-</span><br><span class="line">0x100002108-</span><br><span class="line">0x100002108-</span><br><span class="line">0x100002108</span><br></pre></td></tr></table></figure><p>所以我们就知道了类在内存中只会存在一份。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/4gx LGTeacher.class</span><br><span class="line">0x100001420: 0x001d8001000013f9 0x0000000100b38140</span><br><span class="line">0x100001430: 0x00000001003db270 0x0000000000000000</span><br><span class="line">(lldb) po 0x001d8001000013f9</span><br><span class="line">17082823967917874</span><br><span class="line"></span><br><span class="line">(lldb) p 0x001d8001000013f9</span><br><span class="line">(long) $2 = 8303516107936761</span><br><span class="line">(lldb) po 0x100001420</span><br><span class="line">LGTeacher</span><br></pre></td></tr></table></figure><p>我们通过上面的打印，就发现 类的内存结构里面的第一个结构打印出来还是 <code>LGTeacher</code>，那么是不是就意味着 对象-&gt;类-&gt;类 这样的死循环呢？这里的第二个类其实是 <code>元类</code>。是由系统帮我们创建的。这个元类也无法被我们实例化。</p><p>也就是下面的这种关系:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021925.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x 0x001d8001000013f9 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $4 = 0x00000001000013f8</span><br><span class="line">(lldb) po 0x00000001000013f8</span><br><span class="line">LGTeacher</span><br><span class="line"></span><br><span class="line">(lldb) x/4gx 0x00000001000013f8</span><br><span class="line">0x1000013f8: 0x001d800100b380f1 0x0000000100b380f0</span><br><span class="line">0x100001408: 0x0000000101c30230 0x0000000100000007</span><br><span class="line">(lldb) p/x 0x001d800100b380f1 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $6 = 0x0000000100b380f0</span><br><span class="line">(lldb) po 0x0000000100b380f0</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure><h3 id="isa-走位"><a href="#isa-走位" class="headerlink" title="isa 走位"></a>isa 走位</h3><p>我们在 Xcode 中测试有以下结果：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021938.jpg" alt></p><p>由此可以给出官方的经典 <code>isa</code> 走位图</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022003.jpg" alt></p><h2 id="isa-初始化流程图"><a href="#isa-初始化流程图" class="headerlink" title="isa 初始化流程图"></a>isa 初始化流程图</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022016.jpg" alt></p><h1 id="对象的本质"><a href="#对象的本质" class="headerlink" title="对象的本质"></a>对象的本质</h1><p>在我们认知里面，<code>OC</code> 对象的本质就是一个结构体，这个结论在 <code>libObjc</code> 源码的 <code>objc-private.h</code> 源文件中可以得到证实。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    ...省略其他的内容...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于对象所属的类来说，我们也可以在 <code>objc-runtime-new.h</code> 源文件中找到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">    </span><br><span class="line">    ...省略其他的内容...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 <code>objc_class</code> 内存中第一个位置是 <code>isa</code>，第二个位置是 <code>superclass</code>。</p><p>不过我们本着求真的态度可以用 <code>clang</code> 来重写我们的 <code>OC</code> 源文件来查看是不是这么回事。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure><p>这行命令会把我们的 <code>main.m</code> 文件编译成 <code>C++</code> 格式，输出为 <code>main.cpp</code>。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022040.jpg" alt></p><p>我们可以看到 <code>LGPerson</code> 对象在底层其实是一个结构体 <code>objc_object</code> 。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022051.jpg" alt></p><p>而我们的 <code>Class</code> 在底层也是一个结构体 <code>objc_class</code> 。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此， <code>iOS</code> 底层探索之对象篇更新完毕，现在来回顾一下我们所探索的内容。</p><ul><li>alloc &amp; init 流程剖析</li><li>内存开辟</li><li>字节对齐算法</li><li>isa 初始化和走位</li><li>对象的本质</li></ul><p>下一篇章我们要探索篇章的是类，敬请期待~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章主要我们探索了 &lt;code&gt;iOS&lt;/code&gt;  对象的 &lt;code&gt;alloc&lt;/code&gt; 和 &lt;code&gt;init&lt;/code&gt; 以及对象是怎么开辟内存以及初始化的，如果在对象身上增加一些属性，是否会影响内存开辟呢？还有一个遗留问题就是通过 &lt;code&gt;calloc&lt;/code&gt; ，我们的对象有了内存地址，但是对象结构里面的 &lt;code&gt;isa&lt;/code&gt; 是怎么关联到我们的对象的内存地址的呢。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - alloc&amp;init</title>
    <link href="http://leejunhui.com/2020/01/05/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-alloc-init/"/>
    <id>http://leejunhui.com/2020/01/05/iOS-底层探索-alloc-init/</id>
    <published>2020-01-05T03:17:38.000Z</published>
    <updated>2020-01-18T18:09:31.744Z</updated>
    
    <content type="html"><![CDATA[<p>作为 <code>iOS</code> 开发者，我们每天打交道最多的应该就是对象了，从面向对象设计的角度来说，对象的创建以及初始化是最基础的内容。那么，今天我们就一起来探索一下 <code>iOS</code> 中最常用的 <code>alloc</code> 和 <code>init</code>  的底层是怎么实现的吧。</p><a id="more"></a><h1 id="如何进行底层探索"><a href="#如何进行底层探索" class="headerlink" title="如何进行底层探索"></a>如何进行底层探索</h1><p>对于第三方开源框架来说，我们去剖析内部原理和细节是有一定的方法和套路可以掌握的。而对于 <code>iOS</code>  底层，特别是 <code>OC</code> 底层，我们可能就需要用到一些开发中不是很常用的方法。</p><p>我们这个系列主要的目的是为了进行底层探索，那么我们作为 <code>iOS</code> 开发者，需要关注应该就是从应用启动到应用被 <code>kill</code> 掉这一整个生命周期的内容。我们不妨从我们最熟悉的 <code>main</code> 函数开始，一般来说，我们在 <code>main.m</code> 文件中打一个断点，左侧的调用堆栈视图应该如下图所示:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200118231019.jpg" alt></p><blockquote><p>要得到这样的调用堆栈有两个注意点:</p><ul><li>需要关闭 <code>Xcode</code> 左侧 <code>Debug</code> 区域最下面的 <code>show only stack frames with debug symbols and between libraries</code></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200118231041.jpg" alt></p><blockquote><ul><li>需要增加一个 <code>_objc_init</code> 的符号端点</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200118234802.jpg" alt></p><p>我们通过上面的调用堆栈信息不难得出一个简单粗略的加载流程结构</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200118231138.jpg" alt></p><p>我们现在心中建立这么一个简单的流程结构，在后期分析底层的时候我们会回过头来梳理整个启动的流程。</p><p>接下来，让我们开始实际的探索过程。</p><p>我们直接打开 <code>Xcode</code> 新建一个 <code>Single View App</code> 工程，然后我们在 <code>ViewController.m</code> 文件中调用 <code>alloc</code> 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *p = [<span class="built_in">NSObject</span> alloc];</span><br></pre></td></tr></table></figure><p>我们按照常规探索源码的方式，直接按住 <code>Command</code> + <code>Control</code> 来进入到 <code>alloc</code> 内部实现，但结果并非如我们所愿，我们来到的是一个头文件，只有 <code>alloc</code> 方法的声明，并没有对应的实现。这个时候，我们会陷入深深的怀疑中，其实这个时候我们只要记住下面三种常用探索方式就能迎刃而解：</p><h2 id="直接下代码断点"><a href="#直接下代码断点" class="headerlink" title="直接下代码断点"></a>直接下代码断点</h2><p>具体操作方式为 <code>Control</code> + <code>in</code> </p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119014943.jpg" alt><br> 这里的 <code>in</code> 指的是左侧图片中红色部分的按钮，其实这里的操作叫做 <code>Step into instruction</code> 。我们可以来到下图这里</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119014959.jpg" alt></p><p>我们观察不难得出我们想要找的就是 <code>libobjc.A.dylib</code> 这个动态链接库了。</p><h2 id="打开反汇编显示"><a href="#打开反汇编显示" class="headerlink" title="打开反汇编显示"></a>打开反汇编显示</h2><p>具体操作方式为打开 <code>Debug</code> 菜单下的 <code>Debug Workflow</code> 下的 <code>Always Show Disassembly</code> </p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119015038.jpg" alt></p><p>接着我们还是下代码断点，然后一步一步调试也会来到下图这里:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119015127.jpg" alt></p><h2 id="下符号断点"><a href="#下符号断点" class="headerlink" title="下符号断点"></a>下符号断点</h2><p>我们先选择 <code>Symbolic Breakpoint</code>，然后输入 <code>objc_alloc</code> ，如下图所示：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119015148.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119015201.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119015214.jpg" alt></p><p>至此，我们得到了 <code>alloc</code> 实现位于 <code>libObjc</code> 这个动态库，而刚好苹果已经开源了这部分的代码，所以我们可以在 <a href="https://opensource.apple.com/release/macos-10145.html" target="_blank" rel="noopener">苹果开源官网 最新版本 10.14.5</a> 上下载即可。最新的 <code>libObc</code> 为 756。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119015229.jpg" alt></p><h1 id="探索-libObjc-源码"><a href="#探索-libObjc-源码" class="headerlink" title="探索 libObjc 源码"></a>探索 <code>libObjc</code> 源码</h1><p>我们下载了 <code>libObjc</code> 的源码到我们的电脑上后是不能直接运行的，我们需要进行一定的配置才能实现源码追踪流程。这一块内容不在本文范围内，读者可参考 <a href="https://juejin.im/post/5d9c829df265da5ba46f49c9" target="_blank" rel="noopener">iOS_objc4-756.2 最新源码编译调试</a>。</p><p>配置好 <code>libObjc</code> 之后，我们新建一个命令行的项目，然后运行如下代码:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *myObj = [<span class="built_in">NSObject</span> alloc];</span><br></pre></td></tr></table></figure><h2 id="objc-alloc"><a href="#objc-alloc" class="headerlink" title="objc_alloc"></a>objc_alloc</h2><p>然后我们直接下符号断点 <code>objc_alloc</code> ，然后一步步调试，先来到的是 <code>objc_alloc</code> </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calls [cls alloc].</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_alloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> callAlloc(cls, <span class="literal">true</span><span class="comment">/*checkNil*/</span>, <span class="literal">false</span><span class="comment">/*allocWithZone*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第一次-callAlloc"><a href="#第一次-callAlloc" class="headerlink" title="第一次 callAlloc"></a>第一次 callAlloc</h2><p>然后会来到 <code>callAlloc</code> 方法，注意这里第三个参数传的是 <code>false</code> </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span></span><br><span class="line">callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断传入的 checkNil 是否进行判空操作</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前编译环境为 OC 2.0</span></span><br><span class="line"><span class="meta">#if __OBJC2__</span></span><br><span class="line">    <span class="comment">// 当前类没有自定义的 allocWithZone</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        <span class="comment">// No alloc/allocWithZone implementation. Go straight to the allocator.</span></span><br><span class="line">        <span class="comment">// 既没有实现 alloc，也没有实现 allocWithZone 就会来到这里，下面直接进行内存开辟操作。</span></span><br><span class="line">        <span class="comment">// fixme store hasCustomAWZ in the non-meta class and </span></span><br><span class="line">        <span class="comment">// add it to canAllocFast's summary</span></span><br><span class="line">        <span class="comment">// 修复没有元类的类，用人话说就是没有继承于 NSObject</span></span><br><span class="line">        <span class="comment">// 判断当前类是否可以快速开辟内存，注意，这里永远不会被调用，因为 canAllocFast 内部</span></span><br><span class="line">        <span class="comment">// 返回的是false</span></span><br><span class="line">        <span class="keyword">if</span> (fastpath(cls-&gt;canAllocFast())) &#123;</span><br><span class="line">            <span class="comment">// No ctors, raw isa, etc. Go straight to the metal.</span></span><br><span class="line">            <span class="keyword">bool</span> dtor = cls-&gt;hasCxxDtor();</span><br><span class="line">            <span class="keyword">id</span> obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, cls-&gt;bits.fastInstanceSize());</span><br><span class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</span><br><span class="line">            obj-&gt;initInstanceIsa(cls, dtor);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Has ctor or raw isa or something. Use the slower path.</span></span><br><span class="line">            <span class="keyword">id</span> obj = class_createInstance(cls, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) <span class="keyword">return</span> [cls allocWithZone:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> [cls alloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="objc-rootAlloc"><a href="#objc-rootAlloc" class="headerlink" title="_objc_rootAlloc"></a>_objc_rootAlloc</h2><p>因为我们在 <code>objc_init</code>  中传入的第三个参数 <code>allocWithZone</code> 是 <code>true</code> ，并且我们的 <code>cls</code> 为 <code>NSObject</code> ，那么也就是说会这里直接来到 <code>return [cls alloc]</code> 。我们接着往下走会来到 <code>alloc</code> 方法：<br> </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)alloc &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAlloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们接着进入 <code>_objc_rootAlloc</code> 方法内部:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base class implementation of +alloc. cls is not nil.</span></span><br><span class="line"><span class="comment">// Calls [cls allocWithZone:nil].</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> callAlloc(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二次-callAlloc"><a href="#第二次-callAlloc" class="headerlink" title="第二次 callAlloc"></a>第二次 callAlloc</h2><p>是不是有点似曾相似，没错，我们第一步进入的 <code>objc_init</code> 也是调用的 <code>callAlloc</code> 方法，但是这里有两个参数是不一样的，第二个参数 <code>checkNil</code> 是否需要判空直接传的是 <code>false</code> ，站在系统角度，前面已经在第一次调用 <code>callAlloc</code>  的时候进行了判空了，所以这里没必要再次进行判空的了。第三个参数 <code>allocWithZone</code> 传的是 <code>true</code> ，关于这个方法，我查阅了苹果开发者文档，文档解释如下:</p><blockquote><p>Do not override <code>allocWithZone:</code> to include any initialization code. Instead, class-specific versions of <code>init...</code> methods.<br>This method exists for historical reasons; memory zones are no longer used by Objective-C.<br>译：不要去重载 <code>allocWithZone</code> 并在其内部填充任何初始化代码，相反的，应该在 <code>init...</code> 里面进行类的初始化操作。<br>这个方法的存在是有历史原因的，内存 <code>zone</code> 已经不再被 <code>Objective-C</code> 所使用的。</p></blockquote><p>按照苹果开发者文档的说法，其实 <code>allocWithZone</code> 本质上和 <code>alloc</code> 是没有区别的，只是在 <code>Objective-C</code> 远古时代，程序员需要使用诸如 <code>allocWithZone</code> 来优化对象的内存结构，而在当下，其实你写 <code>alloc</code> 和 <code>allocWithZone</code> 在底层是一模模一样样的。</p><p>好的，话题扯远了，我们接着再次进入到 <code>callAlloc</code> 方法内部，第二次来到 <code>callAlloc</code> 的话，在 <code>!cls-&gt;ISA()-&gt;hasCustomAWZ()</code> 这里判断 <code>cls</code> 没有自定义的 <code>allocWithZone</code> 实现，这里的判断实质上是对 <code>cls</code> 也就是 <code>object_class</code> 这一结构体内部的 <code>class_rw_t</code> 的 <code>flags</code> 与上一个宏 <code>RW_HAS_DEFAULT_AWZ</code> 。经过笔者测试，在第一次进入 <code>callAlloc</code> 方法内部的时候， <code>flags</code> 值为 1 ，然后  <code>flags</code> 与上 <code>1&lt;&lt;16</code> 结果就是 0 ，返回过去也就是 <code>false</code> ，然后在 <code>hasCustomAWZ</code> 这里取反之后，返回的就是 <code>true</code> ，然后再一取反，自然就会跳过 <code>if</code> 里面的逻辑；而第二次进入 <code>callAlloc</code> 方法内部的时候， <code>flags</code> 值是一个很大的整数，与上 <code>1&lt;&lt;16</code> 后结果并不为0 ，所以 <code>hasDefaultAWZ</code> 会返回 <code>true</code> ，那么 <code>hasCustomAWZ</code> 这里就会返回 <code>false</code> ，那么返回到 <code>callAlloc</code> 的时候自然就会进入 <code>if</code> 里面的逻辑了。</p><blockquote><p>这里插一句，在我们 OC 的类的结构中，有一个结构叫 <code>class_rw_t</code> ，有一个结构叫 <code>class_ro_t</code> 。其中 <code>class_rw_t</code> 是可以在运行时去拓展类的，包括属性，方法、协议等等，而 <code>class_ro_t</code> 则存储了成员变量，属性和方法等，不过这些是在编译时就确定了的，不能在运行时去修改。</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> hasCustomAWZ() &#123;</span><br><span class="line">   <span class="keyword">return</span> ! bits.hasDefaultAWZ();</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> hasDefaultAWZ() &#123;</span><br><span class="line"><span class="keyword">return</span> data()-&gt;flags &amp; RW_HAS_DEFAULT_AWZ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们会来到 <code>canAllocFast</code> 的判断，我们继续进入该方法内部</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fastpath(cls-&gt;canAllocFast()))</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> canAllocFast() &#123;</span><br><span class="line">    assert(!isFuture());</span><br><span class="line">    <span class="keyword">return</span> bits.canAllocFast();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> canAllocFast() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果很显然，这里 <code>canAllocFast</code> 是一直返回 <code>false</code> 的，也就是说会直接来到下面的逻辑</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = class_createInstance(cls, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</span><br><span class="line"><span class="keyword">return</span> obj;</span><br></pre></td></tr></table></figure><p>我们再次进入 <code>class_createInstance</code> 方法内部</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> </span><br><span class="line">class_createInstance(Class cls, size_t extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __attribute__((always_inline)) </span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="keyword">void</span> *zone, </span><br><span class="line">                              <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>, </span><br><span class="line">                              size_t *outAllocatedSize = <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对 cls 进行判空操作</span></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">// 断言 cls 是否实现了</span></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read class's info bits all at once for performance</span></span><br><span class="line">    <span class="comment">// cls 是否有 C++ 的初始化构造器</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxCtor = cls-&gt;hasCxxCtor();</span><br><span class="line">    <span class="comment">// cls 是否有 C++ 的析构器</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class="line">    <span class="comment">// cls 是否可以分配 Nonpointer，如果是，即代表开启了内存优化 </span></span><br><span class="line">    <span class="keyword">bool</span> fast = cls-&gt;canAllocNonpointer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里传入的 extraBytes 为0，然后获取 cls 的实例内存大小</span></span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="comment">// 这里 outAllocatedSize 是默认值 nil，跳过</span></span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> obj;</span><br><span class="line">    <span class="comment">// 这里 zone 传入的也是nil，而 fast 拿到的是 true，所以会进入这里的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">        <span class="comment">// 根据 size 开辟内存</span></span><br><span class="line">        obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, size);</span><br><span class="line">        <span class="comment">// 如果开辟失败，返回 nil</span></span><br><span class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">// 将 cls 和是否有 C++ 析构器传入给 initInstanceIsa，实例化 isa</span></span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 zone 不为空，经过笔者测试，一般来说调用 alloc 不会来到这里，只有 allocWithZone</span></span><br><span class="line">        <span class="comment">// 或 copyWithZone 会来到下面的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">            <span class="comment">// 根据给定的 zone 和 size 开辟内存</span></span><br><span class="line">            obj = (<span class="keyword">id</span>)malloc_zone_calloc ((malloc_zone_t *)zone, <span class="number">1</span>, size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根据 size 开辟内存</span></span><br><span class="line">            obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果开辟失败，返回 nil</span></span><br><span class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be </span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">        <span class="comment">// 初始化 isa</span></span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有 C++ 初始化构造器和析构器，进行优化加速整个流程</span></span><br><span class="line">    <span class="keyword">if</span> (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span><br><span class="line">        obj = _objc_constructOrFree(obj, cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最终的结果</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们的 <code>alloc</code> 流程就探索完毕，但在这其中我们还是有一些疑问点，比如，对象的内存大小时怎么确定出来的， <code>isa</code> 是怎么初始化出来的呢，没关系，我们下一篇接着探索。这里，先给出笔者自己画的一个 <code>alloc</code> 流程图:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119015244.jpg" alt></p><h2 id="init-简略分析"><a href="#init-简略分析" class="headerlink" title="init 简略分析"></a>init 简略分析</h2><p>分析完了 <code>alloc</code> 的流程，我们接着分析 <code>init</code> 的流程。相比于 <code>alloc</code> 来说， <code>init</code> 内部实现十分简单，先来到的是 <code>_objc_rootInit</code> ，然后就直接返回 <code>obj</code> 了。其实这里是一种抽象工厂设计模式的体现，对于 <code>NSObject</code> 自带的 <code>init</code> 方法来说，其实啥也没干，但是如果你继承于 <code>NSObject</code> 的话，然后就可以去重写 <code>initWithXXX</code> 之类的初始化方法来做一些初始化操作。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootInit(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">_objc_rootInit(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// In practice, it will be hard to rely on this function.</span></span><br><span class="line">    <span class="comment">// Many classes do not properly chain -init calls.</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>先秦荀子的劝学中有言:</p><blockquote><p>不积跬步，无以至千里；不积小流，无以成江海。</p></blockquote><p>我们在探索 <code>iOS</code> 底层原理的时候，应该也是抱着这样的学习态度，注意点滴的积累，从小做起，积少成多。下一篇笔者将对本文留下的两个疑问进行解答:</p><ul><li>对象初始化内存是如何分配的？</li><li>isa 是如何初始化的?</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为 &lt;code&gt;iOS&lt;/code&gt; 开发者，我们每天打交道最多的应该就是对象了，从面向对象设计的角度来说，对象的创建以及初始化是最基础的内容。那么，今天我们就一起来探索一下 &lt;code&gt;iOS&lt;/code&gt; 中最常用的 &lt;code&gt;alloc&lt;/code&gt; 和 &lt;code&gt;init&lt;/code&gt;  的底层是怎么实现的吧。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>WWDC2012 iOS App Performance:Responsiveness 笔记</title>
    <link href="http://leejunhui.com/2019/12/10/WWDC2012-iOS-App-Performance-Responsiveness/"/>
    <id>http://leejunhui.com/2019/12/10/WWDC2012-iOS-App-Performance-Responsiveness/</id>
    <published>2019-12-10T03:55:32.000Z</published>
    <updated>2020-01-05T03:41:03.412Z</updated>
    
    <content type="html"><![CDATA[<p>如果观看过 <a href="https://developer.apple.com/videos/play/wwdc2012/235/" target="_blank" rel="noopener">WWDC 2012 Session 305 - iOS App Performance: Responsiveness</a> 可以略过本文。</p><p>首先，该篇 WWDC Session 有两个主题</p><ul><li>响应式：app 如何更快的响应用户操作</li><li>性能优化：让 app 高效的运行<a id="more"></a><h2 id="一、应用启动"><a href="#一、应用启动" class="headerlink" title="一、应用启动"></a>一、应用启动</h2></li><li>app 启动时间是第一指标</li><li>app 启动时会有一段过渡动画<ul><li>iPhone 上有 400 毫秒</li><li>iPad 上有 500 毫秒</li></ul></li><li>力争更快的启动 app</li></ul><p>iOS 系统会有一个 watchdog 来监测 app 的启动时间是否过长，根据 app 的生命周期，对应的时间阈值如下表所示：</p><table><thead><tr><th>场景</th><th>Watchdog 时间阈值</th></tr></thead><tbody><tr><td>启动 Launch</td><td>20 秒</td></tr><tr><td>重载 Resume</td><td>10 秒</td></tr><tr><td>挂起 Suspend</td><td>10 秒</td></tr><tr><td>退出 Quit</td><td>6 秒</td></tr><tr><td>后台任务 Background Task</td><td>10 分钟</td></tr></tbody></table><p>值得注意的是，如果是在 Xcode 中以 Debug 模式运行你的 app，这个 watchdog 机制是默认禁用的。也就是说在 Release 模式下才会激活这个机制。</p><h3 id="1-计算-app-的启动时间"><a href="#1-计算-app-的启动时间" class="headerlink" title="1.计算 app 的启动时间"></a>1.计算 app 的启动时间</h3><p><strong>选择一个合适的节点</strong></p><ul><li>Watchdog 会监听第一次 <code>CATranscation</code> 事务的结束<ul><li>第一次布局与渲染</li><li><code>CoreAnimation</code> 的内部方法 <code>-[UIApplication _reportAppLaunchFinshed]</code> </li></ul></li><li>用户可能关心的其它指标<ul><li>相机类 app 应该计算好快门开启的时间</li></ul></li></ul><h3 id="2-记录第一次渲染的开始和结束时间"><a href="#2-记录第一次渲染的开始和结束时间" class="headerlink" title="2.记录第一次渲染的开始和结束时间"></a>2.记录第一次渲染的开始和结束时间</h3><ul><li>在 main() 中获取渲染开始时间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    StartTime = CFAbsoluteTimeGetCurrent();</span><br></pre></td></tr></table></figure><ul><li>在 applicationDidFinishLaunching 中获得渲染结束时间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidFinishLaunching:(UIApplication *)app &#123;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;Launched in %f sec&quot;, CFAbsoluteTimeGetCurrent() - StartTime);    </span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里使用 GCD 的原因是在 <code>applicationDidFinishLaunching</code> 回调方法返回前，并不能确保 app 渲染完成了，所以需要使用异步的方式来在主线程上获取时间差。</p></blockquote><h3 id="3-使用-Time-Profiler-来计算第一次渲染所耗费的时间"><a href="#3-使用-Time-Profiler-来计算第一次渲染所耗费的时间" class="headerlink" title="3.使用 Time Profiler 来计算第一次渲染所耗费的时间"></a>3.使用 Time Profiler 来计算第一次渲染所耗费的时间</h3><h3 id="4-App-启动的流程"><a href="#4-App-启动的流程" class="headerlink" title="4.App 启动的流程"></a>4.App 启动的流程</h3><ul><li>链接和装载 Linking and loading</li><li>UIKit 初始化 </li><li>Application 回调</li><li>第一次 Core Animation 事务完成</li></ul><h3 id="5-App-启动总结"><a href="#5-App-启动总结" class="headerlink" title="5.App 启动总结"></a>5.App 启动总结</h3><blockquote><p>Launch is the first user interaction - it should be responsive<br>App 启动是用户的第一层交互，这个过程应该是顺滑的</p></blockquote><hr><blockquote><p>Measure launch time<br>计算启动耗费的时间</p></blockquote><hr><blockquote><p>Profile with Time Profiler<br>使用 Time Profiler 工具来调试</p></blockquote><hr><blockquote><p>Observe best practices<br>遵守最佳实践</p></blockquote><h2 id="二、性能优化策略"><a href="#二、性能优化策略" class="headerlink" title="二、性能优化策略"></a>二、性能优化策略</h2><h3 id="2-1-避免不必要的工作"><a href="#2-1-避免不必要的工作" class="headerlink" title="2.1 避免不必要的工作"></a>2.1 避免不必要的工作</h3><ul><li>对 App 进行 Profile 后，通常会揭露出 App 中一些不必要的模块</li><li>例子<ul><li>不必要的阴影和遮罩</li><li>对同一数据的多次请求</li><li>启动时过多的日志打印会耗费很多时间</li></ul></li></ul><h3 id="2-2-重用而不是重新创建"><a href="#2-2-重用而不是重新创建" class="headerlink" title="2.2 重用而不是重新创建"></a>2.2 重用而不是重新创建</h3><ul><li>特定的一些类的初始化是代价很高的<ul><li>TableView 的 cell</li><li>日期/数字 格式化器</li><li>正则表达式</li><li>SQLite 语句</li></ul></li><li>重用这些对象而不是重新创建</li></ul><h4 id="2-2-1-日期格式化-Date-Formatter"><a href="#2-2-1-日期格式化-Date-Formatter" class="headerlink" title="2.2.1 日期格式化 Date Formatter"></a>2.2.1 日期格式化 Date Formatter</h4><ul><li>使用日期格式化的大多数场景<ul><li>对于一种日期格式缓存对应的一个日期格式化器 (Date Formatter)</li><li>当收到 <code>NSLocaleDidChangeNotification</code> 通知时，让缓存失效</li></ul></li><li>设置格式和重新创建都是性能高昂的操作 </li></ul><h4 id="2-2-2-日历-Calendars"><a href="#2-2-2-日历-Calendars" class="headerlink" title="2.2.2 日历 Calendars"></a>2.2.2 日历 Calendars</h4><ul><li>每一句 <code>NSLog</code> 的调用都会创建一个新的 <code>calendar</code> 实例<ul><li>避免 <code>NSLog</code> 的过度使用</li></ul></li><li>通过调用 <code>+[NSCalendar currentCalendar]</code> 对于每个 cell 都返回一个新的实例出来<ul><li>如果重复使用的话应该保存这个实例</li></ul></li></ul><h4 id="2-2-3-SQLite-语句"><a href="#2-2-3-SQLite-语句" class="headerlink" title="2.2.3 SQLite 语句"></a>2.2.3 SQLite 语句</h4><ul><li>每一条 SQLite 语句都是一个可编译程序<ul><li>使用 <code>sqlite3_prepare</code> 将 SQL 查询语句转换为字节码</li></ul></li><li>使用绑定参数并重用语句</li></ul><h3 id="2-3-高效的开发"><a href="#2-3-高效的开发" class="headerlink" title="2.3 高效的开发"></a>2.3 高效的开发</h3><ul><li>选择合适的数据结构和算法</li><li>选择更快的算法</li></ul><h3 id="2-4-提前计算结果"><a href="#2-4-提前计算结果" class="headerlink" title="2.4 提前计算结果"></a>2.4 提前计算结果</h3><h3 id="2-5-异步加载"><a href="#2-5-异步加载" class="headerlink" title="2.5 异步加载"></a>2.5 异步加载</h3><h3 id="2-6-大量数据测试"><a href="#2-6-大量数据测试" class="headerlink" title="2.6 大量数据测试"></a>2.6 大量数据测试</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果观看过 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2012/235/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WWDC 2012 Session 305 - iOS App Performance: Responsiveness&lt;/a&gt; 可以略过本文。&lt;/p&gt;
&lt;p&gt;首先，该篇 WWDC Session 有两个主题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应式：app 如何更快的响应用户操作&lt;/li&gt;
&lt;li&gt;性能优化：让 app 高效的运行
    
    </summary>
    
      <category term="WWDC 笔记" scheme="http://leejunhui.com/categories/WWDC-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="WWDC" scheme="http://leejunhui.com/tags/WWDC/"/>
    
      <category term="翻译" scheme="http://leejunhui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS 最佳实践[译]（一）起步</title>
    <link href="http://leejunhui.com/2019/08/10/iOS-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E8%AF%91/"/>
    <id>http://leejunhui.com/2019/08/10/iOS-最佳实践-译/</id>
    <published>2019-08-10T03:07:46.000Z</published>
    <updated>2020-01-05T03:41:19.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-最佳实践（一）起步"><a href="#iOS-最佳实践（一）起步" class="headerlink" title="iOS 最佳实践（一）起步"></a>iOS 最佳实践（一）起步</h1><h2 id="为什么整理这篇文档"><a href="#为什么整理这篇文档" class="headerlink" title="为什么整理这篇文档?"></a>为什么整理这篇文档?</h2><p>刚开始从事 iOS 开发会有一点让人心生畏惧。<code>Swift</code>和<code>Objective-C</code>并不是被广泛使用的语言，这个平台几乎所有内容都有自己特有的名称，将你所编写的代码运行到一台设备上的过程可能是很坎坷的。这份文档就是来帮助你的，不论你是开始迈出你在<code>Cocoa王国</code>中的第一步还是对于<code>以正确的方式</code>编程。下面所有的内容都仅仅是建议，所以如果你有一个很好地理由用不同的方式来实现，那就去做吧!</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>如果您正在寻找特定的内容，您可以从这里直接跳到相关部分。</p><ol><li><a href="#1">起步</a></li><li><a href>常用库</a></li><li><a href>架构</a></li><li><a href>存储</a></li><li><a href>资源</a></li><li><a href>编码风格</a></li><li><a href>安全</a></li><li><a href>诊断</a></li><li><a href>分析</a></li><li><a href>编译</a></li><li><a href>分发</a></li><li><a href>内购(IAP)</a></li><li><a href>证书</a></li></ol><h2 id="1">起步</h2><h3>人机交互指南</h3><p>如果你来自其它平台，请花一些时间来熟悉苹果的<a href="https://developer.apple.com/ios/human-interface-guidelines/" target="_blank" rel="noopener">人机交互指南</a>。iOS 的世界非常强调要有一个良好的设计，你的app也不应例外。该指南还为设计人员提供了一个关于原生UI元素、以及如 3D Touch 或 Wallet 等 app 以及图标大小的实用概述。</p><h3 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h3><p><a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener">Xcode</a>是大多数iOS开发者所选择的IDE，同时也是苹果官方指定的唯一平台。除了<code>Xcode</code>外，还有一些替换方案，其中<a href="https://www.jetbrains.com/objc/" target="_blank" rel="noopener">AppCode</a>可以说是最出名的了，但除非你是经验丰富的iOS开发者，否则还是请使用<code>Xcode</code>吧。虽然它有一些缺点，但它现在确实很实用！</p><p>如需安装<code>Xcode</code>，直接在Mac的<a href="https://itunes.apple.com/us/app/xcode/id497799835" target="_blank" rel="noopener">App Store</a>上下载即可。它提供了最新的SDK和模拟器，您可以在首选项&gt;下载中安装更多的东西。</p><!-- more --><h3 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h3><p>当开始开发一个iOS项目的时候，一个常见的问题就是纯代码还是通过<code>Storyboards</code>或<code>XIB</code>文件来使用<code>Interface Builder</code>。众所周知两种方法都能完成工作。然而，这里有几点需要考虑的：</p><h4 id="为什么使用纯代码"><a href="#为什么使用纯代码" class="headerlink" title="为什么使用纯代码?"></a>为什么使用纯代码?</h4><ul><li><code>Storyboards</code>由于其复杂的XML结构，更容易发生版本冲突。这使得比纯代码更难完成合并。</li><li>纯代码更容易构造和重用视图，从而保持代码库的<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">DRY</a>。</li><li>所有的信息都在一个地方。在<code>Interface Builder</code>中，你必须单击所有检查器才能找到您要查找的内容。</li><li><code>Storyboards</code>引入了代码和UI之间的耦合，这可能导致崩溃，例如当<code>outlet</code>或<code>Action</code>没有正确被设置时。编译器不会检测到这些问题。</li></ul><h4 id="为什么使用Storyboards"><a href="#为什么使用Storyboards" class="headerlink" title="为什么使用Storyboards?"></a>为什么使用<code>Storyboards</code>?</h4><ul><li>对于不太倾向于技术的人来说，<code>Storyboards</code>是直接为项目做出贡献的好方法。例如，调整颜色和布局约束。然而，这是需要一个可行的项目设置并且花时间学习基础知识的过程。</li><li>由于可以在不构建项目的情况下预览更改，对于迭代开发来说更有优势。</li><li>自定义字体和UI元素都是以图形化的方式展现在<code>Storyboards</code>中，当在设计时对最终的外观有一个更好的了解。</li><li>对于<a href="http://futurice.com/blog/adaptive-views-in-ios-8" target="_blank" rel="noopener">size classes</a>, Interface Builder 能将你所选择的设备提供实时布局预览，包括iPad分屏多任务处理。</li></ul><h4 id="为什么不两者兼用呢"><a href="#为什么不两者兼用呢" class="headerlink" title="为什么不两者兼用呢?"></a>为什么不两者兼用呢?</h4><p>为了两全其美，你可以采取混用的方案：首先用<code>Storyboards</code>勾勒出最初的设计，对修补和快速更改非常有用。你甚至可以邀请设计师加入到这个流程中。随着UI的成熟和可靠性变得更加重要，你将过渡到更容易维护和协作的基于代码的方式开发。</p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>将版本控制引入项目的第一步就是要有一个正确的<code>.gitignore</code>文件。这样，不需要的文件（用户设置文件，临时文件等）将永远不会被纳入版本库。幸运的是，GitHub 已经提供了 <a href="https://github.com/github/gitignore/blob/master/Objective-C.gitignore" target="_blank" rel="noopener">OC</a> 和 <a href="https://github.com/github/gitignore/blob/master/Swift.gitignore" target="_blank" rel="noopener">Swift</a> 的<code>.gitignore</code>文件。</p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><h4 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h4><p>如果你打算在项目中引入第三方库的话，<a href="https://cocoapods.org/" target="_blank" rel="noopener">CocoaPods</a> 提供了简单快速的集成。安装它很简单，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p>初始化时，跳转到项目路径下，执行如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod init</span><br></pre></td></tr></table></figure><p>这会自动生成一个<code>Podfile</code>文件，这个文件用来管理项目的所有依赖。在<code>Podfile</code>中添加好依赖后，执行如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure><p>执行后会安装所依赖的第三方库，并且作为工程的一部分，这个工程当然也包含了你自己的项目。由于<a href="https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control" target="_blank" rel="noopener">这里</a>和<a href="https://www.dzombak.com/blog/2014/03/including-pods-in-source-control.html" target="_blank" rel="noopener">这里</a>的原因，我们推荐将<code>Pods</code>里面的内容也提交到版本库里面，而不是在每次新的代码签出后依赖于开发人员执行<code>pod install</code>。</p><blockquote><p>这里的原因大概可以这么来解释，通过将<code>Pods</code>文件夹加入版本库。当有新的开发人员克隆版本库的时候，只需要编译运行项目，不需要运行<code>pod install</code>这种需要长时间命令</p></blockquote><p>注意从现在开始，你需要打开<code>.xcworkspace</code>文件，而不是<code>.xcproject</code>文件，否则代码将无法编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update</span><br></pre></td></tr></table></figure><p>上面的命令将会更新所有的pods到<code>Podfile</code>文件上所允许的最新的版本。你可以使用<a href="http://guides.cocoapods.org/syntax/podfile.html#pod" target="_blank" rel="noopener">运算符</a>来指明你想要的版本。</p><h4 id="Carthage"><a href="#Carthage" class="headerlink" title="Carthage"></a>Carthage</h4><p><a href="https://github.com/Carthage/Carthage" target="_blank" rel="noopener">Carthage</a> 采用<a href="http://www.infoq.com/presentations/Simple-Made-Easy" target="_blank" rel="noopener">简约而不简单</a>的方式将你所依赖的代码打包成二进制库文件，而不是以神奇地将它们以各种方式集成到你的项目中。这会大大的减少编译时间，因为你的依赖在项目开始构建的时候就已经被编译好了。<br>由于没有集中式的项目仓库，这意味任何可以编译成框架的代码库都支持开箱即用的<code>Carthage</code>。<br>要开始引入<code>Carthage</code>到你的项目中的话，请遵循<code>Carthage</code>文档中的<a href="https://github.com/Carthage/Carthage#installing-carthage" target="_blank" rel="noopener">说明</a>。</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>为了避免将数以百计的源文件放置在同一个目录下，最好根据项目自身的架构设置一些文件夹结构层级。例如，你可以使用如下的划分方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├─ Models</span><br><span class="line">├─ Views</span><br><span class="line">├─ Controllers (或者是ViewModels, 如果你的项目是MVVM架构)</span><br><span class="line">├─ Stores</span><br><span class="line">├─ Helpers</span><br></pre></td></tr></table></figure><p>首先，在 Xcode 的项目导航器中的项目名称目录下创建组(黄色的小文件夹)，然后，对于每个组，通过点击 Xcode 的文件检查器下的灰色文件夹小图标，来到分组对应的真实物理路径，并创建对应名称的文件夹，并与 Xcode 中的组相关联。</p><h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><p>项目伊始将所有的字符串都存储到本地化文件，不仅为翻译提供了便利，同时为快速查找字符串提供了便利。你可以在<code>build scheme</code>中加入启动参数来指定app的语言：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-AppleLanguages (Finnish)</span><br></pre></td></tr></table></figure><p>而对于更加复杂的翻译场景，如取决于数量的复数形式(例如: “1 person” vs “3 people”)，你应该使用<a href="https://developer.apple.com/library/prerelease/ios/documentation/MacOSX/Conceptual/BPInternational/StringsdictFileFormat/StringsdictFileFormat.html" target="_blank" rel="noopener">.stringsdict</a>格式文件而不是常规的格式化字符串文件。一旦你将视线转移到这个疯狂的语法上，你就拥有了一个知道如何为 <code>one</code>，<code>some</code>，<code>few</code> 和 <code>many</code> 应用复数化的强大工具，<a href="http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html" target="_blank" rel="noopener">例如在俄语和阿拉伯语中</a>。</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>保持常量的作用域尽可能的小，例如，当你只需要在一个类中使用常量的时候，那么这个常量作用域应仅限于这个类。需要在全局作用域保存的常量应当统一存放在一个地方。在<code>Swift</code>中，你可以使用枚举来定义常量然后生成<code>Constants.swift</code>文件来组织、存储和获取全局作用域的常量，这是一种非常干净的方式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> baseURL = <span class="type">NSURL</span>(string: <span class="string">"http://www.example.org/"</span>)!</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> splineReticulatorName = <span class="string">"foobar"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> primaryColor = <span class="type">UIColor</span>(red: <span class="number">0.22</span>, green: <span class="number">0.58</span>, blue: <span class="number">0.29</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> secondaryColor = <span class="type">UIColor</span>.lightGray</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A visual way to define colours within code files is to use #colorLiteral</span></span><br><span class="line">    <span class="comment">// This syntax will present you with colour picker component right on the code line</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> tertiaryColor = #colorLiteral(red: <span class="number">0.22</span>, green: <span class="number">0.58</span>, blue: <span class="number">0.29</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你使用<code>Objective-C</code>时，将全局作用域常量存储在<code>Constant.h</code>文件中，该文件是被<code>Prefix Header</code>头文件所引用了的。<br>通过静态常量来代替预处理宏定义常量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">CGFloat</span> const <span class="type">XYZBrandingFontSizeSmall</span> = <span class="number">12</span>.0f;</span><br><span class="line"><span class="keyword">static</span> <span class="type">NSString</span> * const <span class="type">XYZAwesomenessDeliveredNotificationName</span> = @<span class="string">"foo"</span>;</span><br></pre></td></tr></table></figure><p>静态常量是类型安全的，有着更加显式的作用域(在未定义之前，它们不能在所有导入/包含的文件中使用)，在后续开发中不能被重定义或者未定义，并且是在调试器中可用的。</p><h3 id="分支模型"><a href="#分支模型" class="headerlink" title="分支模型"></a>分支模型</h3><p>特别是在向公众发布应用程序时（例如通过 App Store），使用适当的标签将发布版本与其他分支隔离是一个好主意。此外，涉及大量提交的新特性开发工作应该在它自己的分支上完成。<a href="https://github.com/nvie/gitflow" target="_blank" rel="noopener"><code>git-flow</code></a>是一个可以帮助你遵循这些约定的工具。它只是<code>Git</code>分支和标签命令的一个便捷的封装，但能帮助团队或个人维护一个适当的分支结构。<br>所有的开发都是基于<code>feature</code>分支(或针对较小的工作基于<code>Dev</code>分支)、基于app版本的标签的发布以及提交都要通过下列代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release finish &lt;version&gt;</span><br></pre></td></tr></table></figure><h3 id="最小的iOS兼容版本"><a href="#最小的iOS兼容版本" class="headerlink" title="最小的iOS兼容版本"></a>最小的iOS兼容版本</h3><p>尽早的决定你的项目所支持的最小iOS版本是十分有用的：明确需要基于哪个系统版本进行开发，测试以及哪些系统API可以使用可以帮助你评估工作量，并让你知道哪些是可用的，哪些是不安全的。</p><p>利用这些资源所收集的资料做出选择：</p><ul><li><p>官方第一手资源</p><ul><li><a href="https://developer.apple.com/support/app-store/" target="_blank" rel="noopener">苹果iOS设备占有率</a><br>版本渗透数据的主要统计渠道，如果可能的话，更倾向于本地化和特定领域的统计信息。</li></ul></li><li><p>第三方资源</p><ul><li><a href="http://iossupportmatrix.com/" target="_blank" rel="noopener">iOS Support Matrix</a> </li><li><a href="https://david-smith.org/iosversionstats/" target="_blank" rel="noopener">DavidSmith: iOS Version Stats</a></li><li><a href="https://mixpanel.com/trends/#report/ios_frag" target="_blank" rel="noopener">Mixpanel Trends: iOS versions</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS-最佳实践（一）起步&quot;&gt;&lt;a href=&quot;#iOS-最佳实践（一）起步&quot; class=&quot;headerlink&quot; title=&quot;iOS 最佳实践（一）起步&quot;&gt;&lt;/a&gt;iOS 最佳实践（一）起步&lt;/h1&gt;&lt;h2 id=&quot;为什么整理这篇文档&quot;&gt;&lt;a href=&quot;#为什么整理这篇文档&quot; class=&quot;headerlink&quot; title=&quot;为什么整理这篇文档?&quot;&gt;&lt;/a&gt;为什么整理这篇文档?&lt;/h2&gt;&lt;p&gt;刚开始从事 iOS 开发会有一点让人心生畏惧。&lt;code&gt;Swift&lt;/code&gt;和&lt;code&gt;Objective-C&lt;/code&gt;并不是被广泛使用的语言，这个平台几乎所有内容都有自己特有的名称，将你所编写的代码运行到一台设备上的过程可能是很坎坷的。这份文档就是来帮助你的，不论你是开始迈出你在&lt;code&gt;Cocoa王国&lt;/code&gt;中的第一步还是对于&lt;code&gt;以正确的方式&lt;/code&gt;编程。下面所有的内容都仅仅是建议，所以如果你有一个很好地理由用不同的方式来实现，那就去做吧!&lt;/p&gt;
    
    </summary>
    
      <category term="iOS最佳实践" scheme="http://leejunhui.com/categories/iOS%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="翻译" scheme="http://leejunhui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="最佳实践" scheme="http://leejunhui.com/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>拥抱变化</title>
    <link href="http://leejunhui.com/2019/08/05/%E6%8B%A5%E6%8A%B1%E5%8F%98%E5%8C%96/"/>
    <id>http://leejunhui.com/2019/08/05/拥抱变化/</id>
    <published>2019-08-05T05:30:33.000Z</published>
    <updated>2019-08-14T13:08:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的厚度决定明天的高度，拥抱当下的变化，做时间的朋友。</p><p>近期书单:</p><ul><li>《态度》</li><li>《见识》</li><li>《浪潮之巅》</li><li>《数学之美》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天的厚度决定明天的高度，拥抱当下的变化，做时间的朋友。&lt;/p&gt;
&lt;p&gt;近期书单:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《态度》&lt;/li&gt;
&lt;li&gt;《见识》&lt;/li&gt;
&lt;li&gt;《浪潮之巅》&lt;/li&gt;
&lt;li&gt;《数学之美》&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="感悟" scheme="http://leejunhui.com/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="拥抱变化" scheme="http://leejunhui.com/tags/%E6%8B%A5%E6%8A%B1%E5%8F%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
