<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>leejunhui&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://leejunhui.com/"/>
  <updated>2020-01-19T04:21:06.374Z</updated>
  <id>http://leejunhui.com/</id>
  
  <author>
    <name>leejunhui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 底层探索 - 分类的加载</title>
    <link href="http://leejunhui.com/2020/01/19/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
    <id>http://leejunhui.com/2020/01/19/iOS-底层探索-分类的加载/</id>
    <published>2020-01-19T03:59:18.000Z</published>
    <updated>2020-01-19T04:21:06.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、初探懒加载类"><a href="#一、初探懒加载类" class="headerlink" title="一、初探懒加载类"></a>一、初探懒加载类</h1><p>上一章我们探索了 <code>iOS</code> 中类的加载，让我们简单回顾一下大概的流程。</p><h2 id="1-1-类的加载回顾"><a href="#1-1-类的加载回顾" class="headerlink" title="1.1 类的加载回顾"></a>1.1 类的加载回顾</h2><ul><li><code>libObjc</code> 向 <code>dyld</code> 注册了回调 <code>_dyld_objc_notify_register</code>，当 <code>dyld</code> 把 <code>App</code> 以及 <code>App</code> 所依赖的一系列 <code>Mach-O</code> 镜像加载到当前 <code>App</code> 被分配的内存空间之后，<code>dyld</code> 会通过 <code>_dyld_objc_notify_mapped</code> 也就是 <code>map_images</code> 来通知 <code>libObjc</code> 来完成具体的加载工作，<code>map_images</code> 被调用之后会来到 <code>_read_images</code></li><li><code>_read_images</code><ul><li>主要会进行类的加载工作，会插入 <strong>所有的类</strong> 到 <code>gdb_objc_realized_classes</code> 哈希表中（插入方式为 类名为 <code>key</code>，类对象为<code>value</code>, 不包括通过 <em>共享缓存</em> 里面的类），同时还会把类插入到 <code>allocatedClasses</code> 这个集合里面，注意，<code>allocatedClasses</code> 的类型为 <code>NXHashTable</code>，可以类比为 <code>NSSet</code>，而 <code>gdb_objc_realized_classes</code> 的类型为 <code>NXMapTable</code>，可以类比为 <code>NSDictionary</code></li><li>对所有的类进行重映射</li><li>将所有的 <code>SEL</code> 插入到 <code>namedSelectors</code> 哈希表中(插入方式为：<code>SEL</code> 名称为 <code>key</code>，<code>SEL</code> 为<code>value</code>)</li><li>修复函数指针遗留</li><li>将所有的 <code>Protocol</code> 插入到 <code>readProtocol</code> 哈希表中(插入方式为：<code>Protocol</code> 名称为 <code>key</code>，<code>Protocol</code> 为 <code>value</code>)</li><li>对所有的 <code>Protocol</code> 做重映射</li><li>初始化所有的<strong>非懒加载类</strong>，包括 <code>rw</code> 和 <code>ro</code> 的初始化操作</li><li>处理所有的分类(包括类的分类和元类的分类)</li></ul></li></ul><h2 id="1-2-验证类的加载流程"><a href="#1-2-验证类的加载流程" class="headerlink" title="1.2 验证类的加载流程"></a>1.2 验证类的加载流程</h2><p>我们大致明白了类的加载流程，接下来，让我们在 <code>_read_images</code> 源码中打印一下类加载之后的结果验证一下是否加载了我们自己创建的类。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119120206.jpg" alt></p><p>如上图所示，我们增加一行代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"_getObjc2NonlazyClassList Class:%s\n"</span>,cls-&gt;mangledName());</span><br></pre></td></tr></table></figure><p>接着我们观察打印结果:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119120352.jpg" alt></p><p>忘了提一句，我们这一个有三个类： <code>LGPerson</code> 、 <code>LGStudent</code> 、 <code>LGTeacher</code> </p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121650.jpg" alt></p><p>但是打印出来的结果没有 <code>LGPerson</code> ，这是为什么呢？答案看这里，我们其实是在 <code>LGStudent</code> 和 <code>LGTeacher</code> 内部实现了 <code>+load</code> 方法。而 <code>LGPerson</code> 则是没有实现 <code>+load</code> 方法。</p><h2 id="1-3-懒加载类的发现"><a href="#1-3-懒加载类的发现" class="headerlink" title="1.3 懒加载类的发现"></a>1.3 懒加载类的发现</h2><p>我们这个时候观察 <code>_read_images</code> 源码这部分的注释:</p><blockquote><p>Realize non-lazy classes (for +load methods and static instances)</p><p>实现<strong>非懒加载</strong>类(实现了 <code>+load</code> 方法和静态实例)</p></blockquote><p>什么意思呢，我们这里其实打印的都是所谓的<strong>非懒加载类</strong>，这里除了我们自己实现了 <code>+load</code> 方法的两个类之外，其他的内容都是系统内置的类，包括我们十分熟悉的 <code>NSObject</code> 类。通过这里其实反过来推论，我们没有实现 <code>+load</code> 方法就是所谓的<strong>懒加载类，这种类并不会在 **`</strong>_read_images**<code>环节被加载，那么应该是在哪里加载呢？我们稍微思考一下，我们一般第一次操作一个类是不是在初始化这个类的时候，而初始化类不就是发送</code>alloc<code>消息吗，而根据我们前面探索消息查找的知识，在第一次发送某个消息的时候，是没有缓存的，所以会来到一个非常重要的方法叫</code>lookUpImpOrForward<code>，我们在</code>main.m<code>中</code>LGPerson<code>类初始化的地方和</code>lookUpImpOrForward` 入口处打上断点:</p><blockquote><p>Tips: 这里有个小技巧，我们先打开 <code>main.m</code> 文件中的断点，等断点来到了我们想要探索的 <code>LGPerson</code> 初始化的位置的时候，我们再打开 <code>lookUpImpOrForward</code> 处的断点，这样才能确保当前执行 <code>lookUpImpOrForward</code> 的是我们的研究对象 <code>LGPerson</code> </p></blockquote><p>因为我们断点的位置是 <code>LGPerson</code> 类发送 <code>alloc</code> 消息，而显然 <code>alloc</code> 作为类方法是存储在元类上的，也就是说 <code>lookUpImpOrForward</code> 的 <code>cls</code> 其实是 <code>LGPerson</code> 元类。那么 <code>inst</code> 就应该是真正的对象，可实际如下图所示：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121717.jpg" alt></p><p>此时的 <code>inst</code> 只是一个地址，说明还没有初始化。我们让程序接着下面走，会来到这样一行代码:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121724.jpg" alt></p><p>这里的 <code>if</code> 判断通过方法名我们不难看出是只有当 <code>cls</code> 未实现的时候才会走里面的 <code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法，那也就是说 <code>LGPerson</code> 元类没有被实现，也就是 <code>LGPerson</code> 类没有实现或者说没有被加载。</p><p>我们就顺着 <code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法往下面走走看，看到底是在哪把我们这个懒加载类给加载出来的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class</span><br><span class="line">realizeClassMaybeSwiftMaybeRelock(Class cls, <span class="keyword">mutex_t</span>&amp; lock, <span class="keyword">bool</span> leaveLocked)</span><br><span class="line">&#123;</span><br><span class="line">    lock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isSwiftStable_ButAllowLegacyForNow()) &#123;</span><br><span class="line">        <span class="comment">// Non-Swift class. Realize it now with the lock still held.</span></span><br><span class="line">        <span class="comment">// fixme wrong in the future for objc subclasses of swift classes</span></span><br><span class="line">        realizeClassWithoutSwift(cls);</span><br><span class="line">        <span class="keyword">if</span> (!leaveLocked) lock.unlock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Swift class. We need to drop locks and call the Swift</span></span><br><span class="line">        <span class="comment">// runtime to initialize it.</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">        cls = realizeSwiftClass(cls);</span><br><span class="line">        assert(cls-&gt;isRealized());    <span class="comment">// callback must have provoked realization</span></span><br><span class="line">        <span class="keyword">if</span> (leaveLocked) lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一路跟随断点来到了 <code>realizeClassMaybeSwiftMaybeRelock</code> 方法，然后我们看到了我们熟悉的一个方法 <code>realizeClassWithoutSwift</code> ，这个方法内部会进行 <code>ro/rw</code> 的赋值操作以及 <code>category</code> 的 <code>attatch</code> ，关于这个方法更多内容可以查看上一篇文章。</p><p>接着我们返回到 <code>lookUpImpOrForward</code> 方法中来，然后进行一下 <code>LLDB</code> 打印，看一下当前这个 <code>inst</code> 也就是 <code>LGPerson</code> 对象是否已经被加载了。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121740.jpg" alt></p><p>通过上面的打印，我们可以看到 <code>rw</code> 已经有值了，也就是说 <code>LGPerson</code> 类被加载了。</p><p>我们总结一下，如果类没有实现 <code>load</code> 方法，那么这个类就是<strong>懒加载类</strong>，其调用堆栈如下图所示：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121758.jpg" alt></p><p>反之、这个类如果实现了 <code>load</code> 方法，那么这个类就是<strong>非懒加载类</strong>，其调用堆栈如下图所示：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121804.jpg" alt></p><h2 id="1-4-懒加载类的流程"><a href="#1-4-懒加载类的流程" class="headerlink" title="1.4 懒加载类的流程"></a>1.4 懒加载类的流程</h2><p>关于<strong>非懒加载类</strong>的加载流程我们已经很熟悉了，我们总结下<strong>懒加载类</strong>的流程：</p><ul><li>类第一次发送消息的时候是没有缓存的，所以会来到 <code>_class_lookupMethodAndLoadCache3</code> ，关于这个方法我们在前面的消息查找章节已经介绍过了，不熟悉的同学可以去查阅一下。</li><li><code>_class_lookupMethodAndLoadCache3</code> 会调用 <code>lookUpImpOrForward</code> ，这个方法的重要性在我们学习 <code>Runtime</code> 的过程中不言而喻</li><li><code>lookUpImpOrForward</code> 内部会进行一下判断，如果 <code>cls</code> 没有被实现，会调用 <code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法</li><li><code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法又会调用 <code>realizeClassMaybeSwiftMaybeRelock</code> 方法</li><li><code>realizeClassMaybeSwiftMaybeRelock</code> 方法内部会进行一下是否是 <code>Swift</code> 的判断，如果不是 <code>Swift</code> 环境的话，就会来到 <code>realizeClassWithoutSwift</code> ，也就是最终的类的加载的地方</li></ul><h1 id="二、分类的底层实现"><a href="#二、分类的底层实现" class="headerlink" title="二、分类的底层实现"></a>二、分类的底层实现</h1><p>分类作为 <code>Objective-C</code> 中常见的特性，相信大家都不会陌生，不过在底层它是怎么实现的呢？</p><h2 id="2-1-重写分类源文件"><a href="#2-1-重写分类源文件" class="headerlink" title="2.1 重写分类源文件"></a>2.1 重写分类源文件</h2><p>为了探究分类的底层实现，我们只需要用 <code>clang</code> 的重写命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc LGTeacher+test.m -o category.cpp</span><br></pre></td></tr></table></figure><p>我们查看 <code>category.cpp</code> 这个文件，来到文件尾部可以看到:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_LGTeacher_</span>$_<span class="title">test</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>,__<span class="title">objc_const</span>"))) = </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="string">"LGTeacher"</span>,</span><br><span class="line"><span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_LGTeacher,</span></span><br><span class="line">(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_LGTeacher_$_test,</span><br><span class="line">(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_LGTeacher_$_test,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">(<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_LGTeacher_$_test,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到 <code>LGTeacher+test</code> 分类在底层的实现是一个结构体，其名字为 <code>_OBJC_$_CATEGORY_LGTeacher_$_test</code> ，很明显这是一个按规则生成的符号，中间的 <code>LGTeacher</code> 是类名，后面的 <code>test</code> 是分类的名字。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121826.jpg" alt></p><p>我们的分类如上图所示，定义了属性、实例方法和类方法，刚好在底层对应了 </p><ul><li><code>_OBJC_$_PROP_LIST_LGTeacher_$_test</code></li><li><code>_OBJC_$_CATEGORY_INSTANCE_METHODS_LGTeacher_$_test</code></li><li><code>_OBJC_$_CATEGORY_CLASS_METHODS_LGTeacher_$_test</code></li></ul><p>同时，我们在后面可以看到如下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> *<span class="title">L_OBJC_LABEL_CATEGORY_</span>$ [1] __<span class="title">attribute__</span>((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>, __<span class="title">objc_catlist</span>,<span class="title">regular</span>,<span class="title">no_dead_strip</span>")))= &#123;</span></span><br><span class="line">&amp;_OBJC_$_CATEGORY_LGTeacher_$_test,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这表明分类是存储在 <code>__DATA</code> 段的 <code>__objc_catlist</code> section 里面的。</p><h2 id="2-2-分类的定义"><a href="#2-2-分类的定义" class="headerlink" title="2.2 分类的定义"></a>2.2 分类的定义</h2><p>我们根据 <code>_category_t</code> 来到 <code>libObjc</code> 源码中进行查找，不过我们需要去掉一下 <code>_category_t</code> 的下划线，然后不难找到分类真正的定义所在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_list_t</span> *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">property_list_t</span> *propertiesForMeta(<span class="keyword">bool</span> isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据刚才 <code>clang</code> 重写之后的内容，我们不难看出</p><ul><li><code>name</code> : 是分类所关联的类，也就是类的名字，而不是分类的名字</li><li><code>cls</code> : 我们在前面可以看到 <code>clang</code> 重写后这个值为 0，但是后面有注释为 <code>&amp;OBJC_CLASS_$_LGTeacher</code> ，也就是我们的类对象的定义，所以这里其实就是我们要扩展的类对象，只是在编译期这个值并不存在</li><li><code>instanceMethods</code> : 分类上存储的实例方法</li><li><code>classMethods</code> ：分类上存储的类方法</li><li><code>protocols</code> ：分类所实现的协议</li><li><code>instanceProperties</code> ：分类所定义的实例属性，不过我们一般在分类中添加属性都是通过关联对象来实现的</li><li><code>_classProperties</code> ：分类所定义的类属性。这里有一行注释：<blockquote><p>Fields below this point are not always present on disk.<br>下面的内容并不是一直在磁盘上保存</p></blockquote></li></ul><p>也就是说 <code>_classProperties</code> 其实是一个私有属性，但并不是一直都存在的。</p><h1 id="三、分类的加载"><a href="#三、分类的加载" class="headerlink" title="三、分类的加载"></a>三、分类的加载</h1><p>我们现在知道了类分为了 <code>懒加载类</code> 和 <code>非懒加载类</code> ，它们的加载时机是不一样的，那么分类的加载又是怎么样的呢？我们还是同样的先分析没有实现 <code>load</code> 方法的分类的情况:</p><p>但是我们在分析前，还要搞清楚一点，分类必须依附于类而存在，如果只有分类，没有类，那么从逻辑上是说不通的，就算实现了，编译器也会忽略掉。而关于类是懒加载还是非懒加载的，所以这里我们还要再细分一次。</p><ul><li>懒加载分类与懒加载类</li><li>懒加载分类和非懒加载类</li></ul><h2 id="3-1-没有实现-load-的分类"><a href="#3-1-没有实现-load-的分类" class="headerlink" title="3.1 没有实现 load 的分类"></a>3.1 没有实现 load 的分类</h2><h3 id="3-1-1-与懒加载类配合加载"><a href="#3-1-1-与懒加载类配合加载" class="headerlink" title="3.1.1 与懒加载类配合加载"></a>3.1.1 与懒加载类配合加载</h3><p>我们先分析第一种情况，也就是类和分类都不实现 <code>load</code> 方法的情况。<br>首先，非懒加载类的流程上面我们已经探索过了，在向类<strong>第一次发送消息</strong>的时候，非懒加载类才会开始加载，而根据我们上一章类的加载探索内容，在 <code>realizeClassWithoutSwift</code> 方法的最后有一个 <code>methodizeClass</code> 方法，在这个方法里面会有一个 <code>Attach categories</code> 的地方：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121859.jpg" alt></p><p>但是我们断点之后发现这个时候通过 <code>unattachedCategoriesForClass</code> 方法并没有取到分类，我们此时不妨通过 <code>LLDB</code> 打印一下当前类里面是否已经把分类的内容附加上了。<br>前面的流程大家都很熟悉了，我们直接看 <code>cls</code> 的 <code>rw</code> 中的 <code>methods</code> 是否有内容：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121906.jpg" alt></p><p>此时 <code>LGTeacher</code> 类里面是没有方法的，这里读取 <code>rw</code> 却有一个结果，我们不难看出这是位于 <code>LGTeacher+test</code> 分类中的一个 <code>initialize</code> 方法，这个方法是我手动加个这个分类的。这样进一步证明了，如果是懒加载类，并且分类也是懒加载，那么分类的加载并不会来到 <code>unattachedCategoriesForClass</code> ，而是直接在编译时加载到了类的 <code>ro</code> 里面，然后在运行时被拷贝到了类的 <code>rw</code> 里面。这一点可以通过下面的 <code>LLDB</code> 打印来证明。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121919.jpg" alt></p><p>如果细心的读者可能会发现，不是在 <code>_read_images</code> 的最后那块有一个 <code>Discover categories</code> 吗，万一懒加载分类是在这里加载的呢？我们一试便知：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121925.jpg" alt></p><p>这里在 <code>Discover categories</code> 内部做了一下判断，如果是 <code>LGTeacher</code> 类进来了，就打印一下，结果发现并没有打印，说明分类也不是在这里被加载的。  </p><h3 id="3-1-2-与非懒加载类配合加载"><a href="#3-1-2-与非懒加载类配合加载" class="headerlink" title="3.1.2 与非懒加载类配合加载"></a>3.1.2 与非懒加载类配合加载</h3><p>   同样的道理，当类为非懒加载类的时候，走的是 <code>_read_images</code> 里面的流程，这个时候我们的懒加载分类是在哪加载的呢？ </p><p>我们直接在 <code>methodizeClass</code> 方法中打上断点，并做了一下简单的判断:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cname = ro-&gt;name;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *oname = <span class="string">"LGTeacher"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(cname, oname) == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"methodizeClass :%s \n"</span>,cname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果可以看到：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121934.jpg" alt></p><p>分类还是不在这，同时通过 <code>LLDB</code> 打印，发现分类的方法已经在类的 <code>ro</code> 里面了，所以说分类的加载其实跟类的懒加载与否并没有关系，也就是说懒加载的分类都是在编译时期被加载的。</p><h2 id="3-2-实现了-load-的分类"><a href="#3-2-实现了-load-的分类" class="headerlink" title="3.2 实现了 load 的分类"></a>3.2 实现了 load 的分类</h2><p>我们再接着分下下面两种情况：</p><ul><li>非懒加载分类与懒加载类</li><li>非懒加载分类和非懒加载类</li></ul><h3 id="3-2-1-与懒加载类配合加载"><a href="#3-2-1-与懒加载类配合加载" class="headerlink" title="3.2.1 与懒加载类配合加载"></a>3.2.1 与懒加载类配合加载</h3><p>其实懒加载和非懒加载的最大区别就是加载是否提前，而实现了 <code>+load</code> 方法的分类，面对的是懒加载的类，<br>而懒加载的类我们前面已经知道了，是在第一次发送消息的时候才会被加载的，那我们直接在<br><code>lookupImpOrForward</code>  =&gt; <code>realizeClassMaybeSwiftAndLeaveLocked</code> =&gt; <code>realizeClassMaybeSwiftMaybeRelock</code> =&gt; <code>realizeClassWithoutSwift</code> =&gt; <code>methodizeClass</code> 流程中的 <code>methodizeClass</code> 打上断点，看下在这里分类会不会被加载：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121942.jpg" alt></p><p>这一次通过 <code>unattachedCategoriesForClass</code> 取出来值了，并且在这之前 <code>cls</code> 的 <code>ro</code> 中并没有分类的 <code>initialize</code> 方法：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121949.jpg" alt></p><p>但是我们注意观察此时的调用堆栈：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119121955.jpg" alt></p><p>为什么走的不是发送消息的流程，而走的是 <code>load_images</code> 里面的 <code>prepare_load_methods</code> 方法呢？我们来到 <code>prepare_load_methods</code> 方法处：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119122001.jpg" alt></p><p>可以看到，其实是在这里调用了 <code>realizeClassWithoutSwift</code> 方法来加载类的。而上面的 <code>_getObjc2NonlazyCategoryList</code> 方法显示就是获取的所有的非懒加载分类，然后遍历这些非懒加载分类，然后去加载这些分类所依赖的类。这个逻辑很好理解，非懒加载分类让我们的懒加载类实现提前了，所以说懒加载类<strong>并不一定</strong>只会在第一次消息发送的时候加载，还要取决于有没有非懒加载的分类，如果有非懒加载的分类，那么就走的是 <code>load_images</code> 里面的 <code>prepare_load_methods</code> 的 <code>realizeClassWithoutSwift</code> 。</p><h3 id="3-2-2-与非懒加载类配合加载"><a href="#3-2-2-与非懒加载类配合加载" class="headerlink" title="3.2.2 与非懒加载类配合加载"></a>3.2.2 与非懒加载类配合加载</h3><p>非懒加载类的流程我们也十分熟悉了，在 <code>_read_images</code> 里面进行加载，而此时，分类也是非懒加载。我们还是在 <code>methodizeClass</code> 里面进行断点：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119122009.jpg" alt></p><p>结果如上图所示，这次从 <code>unattachedCategoriesForClass</code> 方法取出来的是 <code>NULL</code> 值，显然分类不是在这个地方被加载的，我们回到 <code>_read_images</code> 方法，还记得那个 <code>Discover categories</code> 流程吗，我们打开里面的断点：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119122014.jpg" alt></p><p>因为当前类已经在前面的非懒加载类加载流程中被加载完成，所以这里会来到 <code>remethodizeClass</code> 方法，我们进入其内部实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remethodizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="keyword">bool</span> isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="literal">false</span><span class="comment">/*not realizing*/</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: attaching categories to class '%s' %s"</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        attachCategories(cls, cats, <span class="literal">true</span> <span class="comment">/*flush caches*/</span>);        </span><br><span class="line">        <span class="built_in">free</span>(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有一个 <code>attachCategories</code> 方法，断点也确实来到了这个地方， <code>attachCategories</code> 方法有一段注释:</p><blockquote><p>// Attach method lists and properties and protocols from categories to a class.<br>// Assumes the categories in cats are all loaded and sorted by load order,<br>// oldest categories first.</p><p>将分类的方法、属性和协议添加到类上<br>假设传入的分类列表都是按加载顺序加载完毕了<br>先加载的分类排在前面</p></blockquote><p>其实 <code>attachCategories</code> 这个方法只会在实现了 <code>load</code> 方法的分类下才会被调用，而来到 <code>attachCategories</code> 之前又取决于类是否为懒加载，如果是懒加载，那么就在 <code>load_images</code> 里面去处理，如果是非懒加载，那么就在 <code>map_images</code> 里面去处理。</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>我们今天探索的内容可能会有点绕，不过其实探索下来，我们只需要保持研究重点就很简单。分类的加载其实可以笼统的分为实现 <code>load</code> 方法和没有实现 <code>load</code> 方法：</p><ul><li>没有实现 <code>load</code> 方法的分类由编译时确定</li><li>实现了 <code>load</code> 方法的分类由运行时去确定</li></ul><p>这也说明分类的加载和类的加载是不一样的，而结合着类的懒加载与否，我们有以下的结论：</p><ul><li>懒加载分类 + 懒加载类</li></ul><blockquote><p>类的加载在<strong>第一次消息发送</strong>的时候，而分类的加载则在<strong>编译时</strong></p></blockquote><ul><li>懒加载分类 + 非懒加载类</li></ul><blockquote><p>类的加载在 <code>_read_images</code> 处，分类的加载还是在<strong>编译时</strong></p></blockquote><ul><li>非懒加载分类 + 懒加载类</li></ul><blockquote><p>类的加载在 <code>load_images</code> 内部，分类的加载在类加载之后的 <code>methodizeClass</code> </p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119122041.jpg" alt></p></blockquote><ul><li>非懒加载分类 + 非懒加载类<blockquote><p>类的加载在 <code>_read_images</code> 处，分类的加载在类加载之后的 <code>reMethodizeClass</code></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119122050.jpg" alt></p></blockquote></li></ul><p>分类的加载探索完了，我们下一章将探索类拓展和关联对象，敬请期待~</p><h1 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h1><p><a href="http://blog.sunnyxx.com/2014/03/05/objc_category_secret/" target="_blank" rel="noopener">objc category的秘密 - sunnyxx</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、初探懒加载类&quot;&gt;&lt;a href=&quot;#一、初探懒加载类&quot; class=&quot;headerlink&quot; title=&quot;一、初探懒加载类&quot;&gt;&lt;/a&gt;一、初探懒加载类&lt;/h1&gt;&lt;p&gt;上一章我们探索了 &lt;code&gt;iOS&lt;/code&gt; 中类的加载，让我们简单回顾一下大概的流程
      
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - 类的加载</title>
    <link href="http://leejunhui.com/2020/01/11/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
    <id>http://leejunhui.com/2020/01/11/iOS-底层探索-类的加载/</id>
    <published>2020-01-10T16:20:05.000Z</published>
    <updated>2020-01-19T03:54:55.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、应用加载回顾"><a href="#一、应用加载回顾" class="headerlink" title="一、应用加载回顾"></a>一、应用加载回顾</h1><p>上一章我们对应用的加载有了初步的认识，我们知道了</p><ul><li>系统调用 <code>exec()</code> 会我们的应用<strong>映射</strong>到新的地址空间</li><li>然后通过 <code>dyld</code> 进行加载、链接、初始化主程序和主程序所依赖的各种动态库</li><li>最后在 <code>initializeMainExecutable</code> 方法中经过一系列初始化调用 <code>notifySingle</code> 函数，该函数会执行一个 <code>load_images</code> 的回调</li><li>然后在 <code>doModinitFuntions</code> 函数内部会调用 <code>__attribute__((constructor))</code> 的 <code>c</code> 函数</li><li>然后 <code>dyld</code> 返回主程序的入口函数，开始进入主程序的 <code>main</code> 函数<a id="more"></a>在 <code>main</code> 函数执行执行，其实 <code>dyld</code> 还会在流程中初始化 <code>libSystem</code>，而 <code>libSystem</code> 又会去初始化 <code>libDispatch</code>，在 <code>libDispatch</code> 初始化方法里面又会有一步 <code>_os_object_init</code>，在 <code>_os_object_init</code> 内部就会调起 <code>_objc_init</code>。而对于 <code>_objc_init</code> 我们还需要继续探索，因为这里面会进行类的加载等一系列重要的工作。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113501.jpg" alt></p><h1 id="二、探索-objc-init"><a href="#二、探索-objc-init" class="headerlink" title="二、探索 _objc_init"></a>二、探索 <code>_objc_init</code></h1><p>首先来到 <code>libObjc</code> 源码的 <code>_objc_init</code> 方法处，你可以直接添加一个符号断点 <code>_objc_init</code> 或者全局搜索关键字来到这里：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着进行分析:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113515.jpg" alt></p><ul><li>判断是否已经初始化了，如果初始化过了，直接返回。</li></ul><h2 id="2-1-environ-init"><a href="#2-1-environ-init" class="headerlink" title="2.1 environ_init"></a>2.1 environ_init</h2><p>接着来到 <code>environ_init</code> 方法内部:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113523.jpg" alt></p><p>我们可以看到，这里主要是读取影响 <code>Runtime</code> 的一些环境变量，如果需要，还可以打印环境变量帮助提示。</p><p>我们可以在终端上测试一下，直接输入 <code>export OBJC_HELP=1</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113531.jpg" alt></p><p>可以看到不同的环境变量对应的内容都被打印出来了。</p><h2 id="2-2-tls-init"><a href="#2-2-tls-init" class="headerlink" title="2.2 tls_init"></a>2.2 tls_init</h2><p>接着来到 <code>tls_init</code> 方法内部:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tls_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    _objc_pthread_key = TLS_DIRECT_KEY;</span><br><span class="line">    pthread_key_init_np(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _objc_pthread_key = tls_create(&amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里执行的是关于线程 <code>key</code> 的绑定，比如每线程数据的析构函数。</p><h2 id="2-3-static-init"><a href="#2-3-static-init" class="headerlink" title="2.3 static_init"></a>2.3 static_init</h2><p>接着来到 <code>static_init</code> 方法内部:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* static_init</span></span><br><span class="line"><span class="comment">* Run C++ static constructor functions.</span></span><br><span class="line"><span class="comment">* libc calls _objc_init() before dyld would call our static constructors, </span></span><br><span class="line"><span class="comment">* so we have to do it ourselves.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        inits[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会运行 <code>C++</code> 的静态构造函数，在 <code>dyld</code> 调用我们的静态构造函数之前，<code>libc</code> 会调用 <code>_objc_init</code>，所以这里我们必须自己来做，并且这里只会初始化系统内置的 <code>C++</code> 静态构造函数，我们自己代码里面写的并不会在这里初始化。</p><h2 id="2-4-lock-init"><a href="#2-4-lock-init" class="headerlink" title="2.4 lock_init"></a>2.4 lock_init</h2><p>接着来到 <code>lock_init</code> 方法内部:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这是一个空的实现。也就是说 <code>objc</code> 的锁是完全采用的 <code>C++</code> 那一套的锁逻辑。</p><h2 id="2-5-exception-init"><a href="#2-5-exception-init" class="headerlink" title="2.5 exception_init"></a>2.5 exception_init</h2><p>接着来到 <code>exception_init</code> 方法内部:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* exception_init</span></span><br><span class="line"><span class="comment">* Initialize libobjc's exception handling system.</span></span><br><span class="line"><span class="comment">* Called by map_images().</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exception_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    old_terminate = <span class="built_in">std</span>::set_terminate(&amp;_objc_terminate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是初始化 <code>libobjc</code> 的异常处理系统，我们程序触发的异常都会来到：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113552.jpg" alt></p><p>我们可以看到 <code>_objc_terminate</code> 是未处理异常的回调函数，其内部逻辑如下:</p><ul><li>检查是否是一个活跃的异常</li><li>如果是活跃的异常，检查是否是 <code>OC</code> 抛出的异常</li><li>如果是 <code>OC</code> 抛出的异常，调用 <code>uncaught_handeler</code> 回调函数指针</li><li>如果不是 <code>OC</code> 抛出的异常，则继续 <code>C++</code> 终止操作</li></ul><h2 id="2-6-dyld-objc-notify-register"><a href="#2-6-dyld-objc-notify-register" class="headerlink" title="2.6 _dyld_objc_notify_register"></a>2.6 _dyld_objc_notify_register</h2><p>接下来使我们今天探索的重点了： <code>_dyld_objc_notify_register</code> ，我们先看下它的定义:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113601.jpg" alt></p><blockquote><p>注意：仅供 <code>objc</code> 运行时使用<br>当 <code>objc</code> 镜像被<strong>映射（mapped）</strong>、<strong>卸载（unmapped）</strong>和<strong>初始化（initialized）</strong>的时候，注册的回调函数就会被调用。<br>这个方法是 <code>dlyd</code> 中声明的，一旦调用该方法，调用结果会作为该函数的参数回传回来。比如，当所有的 <code>images</code> 以及 <code>section</code> 为 <code>objc-image-info</code> 被加载之后会回调 <code>mapped</code> 方法。<br><code>load</code> 方法也将在这个方法中被调用。</p></blockquote><p><code>_dyld_objc_notify_register</code>  方法的三个参数 <code>map_images</code> 、 <code>load_images</code> 、 <code>unmap_image</code>  其实都是函数指针：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113615.jpg" alt></p><p>这三个函数指针是在 <code>dyld</code> 中回调的，我们打开 <code>dyld</code> 的源码即可一探究竟，我们直接搜索 <code>_dyld_objc_notify_register</code> :</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113626.jpg" alt></p><p>接着来到 <code>dyld</code> 的 <code>registerObjCNotifiers</code> 方法内部：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113634.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113641.jpg" alt></p><p>通过上面两张截图的内容说明在 <code>registerObjCNotifiers</code> 内部， <code>libObjc</code> 传过来的这三个函数指针被 <code>dyld</code> 保存在了本地静态变量中。换句话来说，最终函数指针是否能被调用，取决于这三个静态变量：</p><ul><li><code>sNotifyObjCMapped</code> </li><li><code>sNotifyObjCInit</code> </li><li><code>sNotifyObjCUnmapped</code> </li></ul><p>我们注意到 <code>registerObjCNotifiers</code> 的 <code>try-catch</code> 语句中的 <code>try</code> 分支注释如下：</p><blockquote><p>call ‘mapped’ function with all images mapped so far<br>调用 <code>mapped</code> 函数来映射所有的镜像</p></blockquote><p>那么也就是说 <code>notifyBatchPartial</code> 里面会进行真正的函数指针的调用，我们进入这个方法内部：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113650.jpg" alt></p><p>我们可以看到，在 <code>notifyBatchPartial</code> 方法内部，这里的注释:</p><blockquote><p>tell objc about new images 告诉 <code>objc</code> 镜像已经映射完成了</p></blockquote><p>而图中箭头所指的地方正是 <code>sNotifyObjCMapped</code> 函数指针真正调用的地方。</p><p>弄清楚了三个函数指针是怎么调用的还不够，接下来我们要深入各个函数的内部看里面究竟做了什么样的事情。</p><h1 id="三、探索-map-images"><a href="#三、探索-map-images" class="headerlink" title="三、探索 map_images"></a>三、探索 map_images</h1><p>首先是 <code>map_images</code> ，我们来到它的实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* map_images</span></span><br><span class="line"><span class="comment">* Process the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">* Calls ABI-agnostic code after taking ABI-specific locks.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;C</span><br></pre></td></tr></table></figure><blockquote><p>Process the given images which are being mapped in by dyld.<br>Calls ABI-agnostic code after taking ABI-specific locks.</p></blockquote><blockquote><p>处理由 <code>dyld</code> 映射的给定镜像<br>取得特定于 <code>ABI</code> 的锁后，调用与 <code>ABI</code> 无关的代码。</p></blockquote><p>这里会继续往下走到 <code>map_images_nolock</code> </p><p><code>map_images_nolock</code> 内部代码十分冗长，我们经过分析之后，前面的工作基本上都是进行镜像文件信息的提取与统计，所以可以定位到最后的 <code>_read_images</code> ：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113711.jpg" alt></p><blockquote><p>这里进入 <code>_read_images</code> 的条件是 <code>hCount</code> 大于 0， <code>hCount</code> 表示的是 <code>Mach-O</code> 中 <code>header</code> 的数量</p></blockquote><p>OK，我们的主角登场了， <code>_read_images</code> 和 <code>lookupImpOrForward</code> 可以说是我们学习 <code>Runtime</code> 和 <code>iOS</code> 底层里面非常重要的两个概念了， <code>lookUpImpOrForward</code> 已经探索过了，剩下的 <code>_read_images</code> 我们也不能落下。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113721.jpg" alt></p><h2 id="3-1-read-images-定义"><a href="#3-1-read-images-定义" class="headerlink" title="3.1 _read_images 定义"></a>3.1 _read_images 定义</h2><blockquote><p>Perform initial processing of the headers in the linked list beginning with headerList.<br>从 <code>headerList</code> 开始，对已经链接了的 <code>Mach-O</code> 镜像表中的头部进行初始化处理</p></blockquote><p>我们可以看到，整个 <code>_read_images</code> 有接近 400 行代码。我们不妨折叠一下里面的分支代码，然后总览一下：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113734.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113742.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113749.jpg" alt></p><p>通过折叠代码，以及日志打印提示信息，我们大致可以将 <code>_read_images</code> 分为下面几个流程:</p><h2 id="3-2-read-images-具体流程"><a href="#3-2-read-images-具体流程" class="headerlink" title="3.2 _read_images 具体流程"></a>3.2 _read_images 具体流程</h2><hr><p><strong>doneOnce 流程</strong></p><p>我们从第一个分支 <code>doneOnce</code> 开始，这个名词顾名思义，只会执行一次：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113811.jpg" alt></p><ul><li>通过宏 <code>SUPPORT_NONPOINTER_ISA</code> 判断当前是否支持开启内存优化的 <code>isa</code> <ul><li>如果支持，则在某些条件下需要禁用这个优化</li></ul></li><li>通过宏 <code>SUPPORT_INDEXED_ISA</code> 判断当前是否是将类存储在 <code>isa</code> 作为类表索引<ul><li>如果是的话，再递归遍历所有的 <code>Mach-O</code> 的头部，并且判断如果是 <code>Swift 3.0</code> 之前的代码，就需要禁用对 <code>isa</code> 的内存优化</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113824.jpg" alt></p><ul><li>通过宏 <code>TARGET_OS_OSX</code> 判断是否是 <code>macOS</code> 执行环境</li><li>判断 <code>macOS</code> 的系统版本，如果小于 <code>10.11</code> 则说明 <code>app</code> 太陈旧了，需要禁用掉 <code>non-pointer isa</code> </li><li>然后再遍历所有的 <code>Mach-O</code> 的头部，判断如果有 <code>__DATA__,__objc_rawisa</code> 段的存在，则禁用掉 <code>non-pointer isa</code> ，因为很多新的 <code>app</code> 加载老的扩展的时候会需要这样的判断操作。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113854.jpg" alt></p><blockquote><p>预先优化过的类不会加入到 <code>gdb_objc_realized_classes</code> 这个哈希表中来， <code>gdb_objc_realized_classes</code> 哈希表的装载因子为 0.75，这是一个经过验证的效率很高的扩容临界值。</p></blockquote><ul><li>加载所有类到类的 <code>gdb_objc_realized_classes</code> 表中来<br></li></ul><p>我们查看这个表的定义：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113952.jpg" alt></p><blockquote><p>// This is a misnomer: gdb_objc_realized_classes is actually a list of<br>// named classes not in the dyld shared cache, whether realized or not.</p></blockquote><blockquote><p>这是一个误称：gdb_objc_realized_classes 表实际上存储的是不在 <code>dyld</code> 共享缓存里面的命名类，无论这些类是否实现</p></blockquote><p>除了 <code>gdb_objc_realized_classes</code> 表之外，还有一张表 <code>allocatedClasses</code> :</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114000.jpg" alt></p><ul><li>通过 <code>objc_allocateClassPair</code> 开辟之后的类和元类存储的表（也就是说需要 <code>alloc</code> ）</li></ul><p>其实 <code>gdb_objc_realized_classes</code> 对 <code>allocatedClasses</code> 是一种包含的关系，一张是类的总表，一张是已经开辟了内存的类表，</p><hr><p><strong>Discover classes 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114029.jpg" alt></p><blockquote><p>Discover classes. Fix up unresolved future classes. Mark bundle classes.<br>发现类。修正未解析的 <code>future</code> 类，标记 <code>bundle</code> 类。</p></blockquote><ul><li>先通过 <code>_getObjc2ClassList</code> 来获取到所有的类，我们可以通过 <code>MachOView</code> 来验证：</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114038.jpg" alt></p><ul><li>接着还是遍历所有的 <code>Mach-O</code> 的 <code>header</code> 部分，然后通过 <code>mustReadClasses</code> 来判断哪些条件可以跳过读取类这一步骤</li><li>读取 <code>header</code> 是否是 <code>Bundle</code> </li><li>读取 <code>header</code> 是否开启了 <strong>预优化</strong></li><li>遍历 <code>_getObjc2ClassList</code> 取出的所有的类<ul><li>通过 <code>readClass</code> 来读取类信息</li><li>判断如果不相等并且 <code>readClass</code> 结果不为空，则需要重新为类开辟内存</li></ul></li></ul><hr><p><strong>Fix up remapped classes 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114058.jpg" alt></p><blockquote><p>修复 重映射类<br>类表和非懒加载类表没有被重映射 (也就是 <strong>_objc_classlist</strong>)<br>由于消息转发，类引用和父类引用会被重映射 (也就是 <strong>_objc_classrefs</strong>)</p></blockquote><ul><li>通过 <code>noClassesRemapped</code> 方法判断是否有类引用(<strong>_objc_classrefs</strong>)需要进行重映射<ul><li>如果需要，则遍历 <code>EACH_HEADER</code> </li><li>通过 <code>_getObjc2ClassRefs</code> 和 <code>_getObjc2SuperRefs</code> 取出当前遍历到的 <code>Mach-O</code> 的类引用和父类引用，然后调用 <code>remapClassRef</code> 进行重映射  </li></ul></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114114.jpg" alt></p><hr><p><strong>Fix up @selector references 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114341.jpg" alt></p><blockquote><p>修正 <code>SEL</code> 引用</p></blockquote><ul><li>操作前先加一个 <code>selLock</code> 锁</li><li>然后遍历 <code>EACH_HEADER</code> <ul><li>如果开启了<strong>预优化</strong>，contiue 到下一个 <code>Mach-O</code> </li><li>通过 <code>_getObjc2SelectorRefs</code> 拿到所有的 <code>SEL</code> 引用</li><li>然后对所有的 <code>SEL</code> 引用调用 <code>sel_registerNameNoLock</code> 进行注册</li></ul></li></ul><p>也就是说这一流程最主要的目的就是注册 <code>SEL</code> ，我们注册真正发生的地方: <code>__sel_registerName</code> ，这个函数如果大家经常玩 <code>Runtime</code> 肯定不会陌生：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114358.jpg" alt></p><p>我们简单分析一下 <code>__sel_registerName</code> 方法的流程：</p><ul><li>判断是否要加锁</li><li>如果 <code>sel</code> 为空，则返回一个空的 <code>SEL</code> </li><li>从 <code>builtins</code> 中搜索，看是否已经注册过，如果找到，直接返回结果</li><li>从 <code>namedSelectors</code> 哈希表中查询，找到了就返回结果</li><li>如果 <code>namedSelectors</code> 未初始化，则创建一下这个哈希表</li><li>如果上面的流程都没有找到，则需要调用 <code>sel_alloc</code> 来创建一下 <code>SEL</code> ，然后把新创建的 <code>SEL</code> 插入哈希表中进行缓存的填充</li></ul><hr><p><strong>Fix up old objc_msgSend_fixup call sites 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114428.jpg" alt></p><blockquote><p>修正旧的 <code>objc_msgSend_fixup</code> 调用</p></blockquote><p>这个流程的执行前提是 <code>FIXUP</code> 被开启。</p><ul><li>还是老套路，遍历 <code>EACH_HEADER</code> <ul><li>通过 <code>_getObjc2MessageRefs</code> 方法来获取当前遍历到的 <code>Mach-O</code> 镜像的所有消息引用</li><li>然后遍历这些消息引用，然后调用 <code>fixupMessageRef</code> 进行修正</li></ul></li></ul><hr><p><strong>Discover protocols 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114506.jpg" alt></p><blockquote><p>发现协议，并修正协议引用</p></blockquote><hr><p><strong>Fix up @protocol references 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114534.jpg" alt></p><blockquote><p>对所有的协议做重映射</p></blockquote><hr><p><strong>Realize non-lazy classes 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114757.jpg" alt></p><blockquote><p>初始化<strong>非懒加载类( **`</strong>+load<strong>` 方法和静态实例</strong>)**</p></blockquote><hr><p><strong>Realize newly-resolved future classes 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114821.jpg" alt></p><blockquote><p>初始化新解析出来的 <code>future</code> 类</p></blockquote><hr><p><strong>Discover categories 流程</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114844.jpg" alt></p><blockquote><p><strong>处理所有的分类，包括类和元类</strong></p></blockquote><hr><p>到这里， <code>_read_images</code> 的流程就分析完毕，我们可以新建一个文件来去掉一些干扰的信息，只保留核心的逻辑，这样从宏观的角度来分析更直观:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114851.jpg" alt></p><blockquote><p>Q &amp; A 环节<br>Q： <code>dyld</code> 主要逻辑是加载库，也就是镜像文件，但是加载完是怎么读取的呢？<br>A： <code>_read_images</code> 是真正读取的地方</p><p>Q: <code>SEL</code> 方法编号何时加载？<br>A: <code>_read_images</code></p></blockquote><h2 id="3-3-read-class-分析"><a href="#3-3-read-class-分析" class="headerlink" title="3.3 read_class 分析"></a>3.3 read_class 分析</h2><p>我们探索了 <code>_read_images</code> 方法的流程，接下来让我们把目光放到本文的主题 - <strong>类的加载</strong><br>既然是类的加载，那么我们在前面所探索的类的结构中出现的内容都会一一重现。<br>所以我们不妨直接进行断点调试，让我们略过其它干扰信息，聚焦于类的加载。</p><ul><li>根据上一小节我们探索的结果， <code>doneOnce</code> 流程中会创建两个哈希表，并没有涉及到类的加载，所以我们跳过</li><li>我们来到第二个流程 - <strong>类处理</strong></li></ul><p><strong>我们在下图所示的位置处打上断点：</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114933.jpg" alt></p><p>如上图所示，从 <code>classList</code> 中取出的 <code>cls</code> 只是一个内存地址，我们尝试通过 <code>LLDB</code> 打印 <code>cls</code> 的 <code>class_rw_t</code> :</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119114946.jpg" alt></p><p>可以看到 <code>cls</code> 的属性、方法、协议以及类名都为空，说明这里类并没有被真正加载完成，我们接着聚焦到 <code>read_class</code> 函数上面，我们进入其内部实现，我们大致浏览之后会定位到如下图所示的代码：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115011.jpg" alt></p><p>看起来类的信息在这里完成了加载，那么为了验证我们的猜想，直接断点调试一下但发现断点根本走不进来，原因在于这里的判断语句 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Class newCls = popFutureNamedClass(mangledName))</span><br></pre></td></tr></table></figure><p>判断当前传入的类的类名是否有 <code>future</code> 类的实现，但是我们刚才已经打印了，类名是空的，所以肯定不会执行这里。我们接着往下走：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115022.jpg" alt></p><ul><li>addNamedClass 内部其实是将 <code>cls</code>  插入到 <code>gdb_objc_realized_classes</code> 表 </li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115035.jpg" alt></p><ul><li>addclassTableEntry 内部是将 <code>cls</code> 插入到 <code>allocatedClasses</code> 表</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115044.jpg" alt></p><p>分析完 <code>read_class</code> ，我们回到 <code>_read_images</code> 方法</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115054.jpg" alt></p><p>我们可以看到 <code>read_class</code> 返回的 <code>newCls</code> 会进行一个判断，判断与传入 <code>read_class</code> 之前的 <code>cls</code> 是否相等，而在 <code>read_class</code> 内部只有一个地方对类的内容进行了改动，但是我们刚才测试了是进不去的，所以这个 <code>if</code> 里面的内容我们可以略过，也就是说 <code>resolvedFutureClasses</code> 的内容我们都可以暂时略过。</p><p>总结一下 <code>readClass</code> ：</p><ul><li>判断是不是要后期处理的类<ul><li>如果是的话，就取出后期处理的类，读取这个类的 <code>data()</code> 类设置 <code>ro/rw</code> </li></ul></li><li>addNamedClass 插入总表</li><li>addClassTableEntry 插入已开辟内存的类的表  </li></ul><h2 id="3-4-realizeClassWithoutSwift-分析"><a href="#3-4-realizeClassWithoutSwift-分析" class="headerlink" title="3.4 realizeClassWithoutSwift 分析"></a>3.4 realizeClassWithoutSwift 分析</h2><p>通过分析 <code>read_class</code> ，我们可以得知，类已经被注册到两个哈希表中去了，那么现在一切时机都已经成熟了。但是我们还是要略过像 <code>Fix up remapped classes</code> 、 <code>Fix up @selector references</code> 、 <code>fix up old objc_msgSend_fixup call sites</code> 、 <code>Discover protocols. Fix up protocol refs</code> 、 <code>Fix up @protocol references</code> ，因为我们的重点是类的加载，我们最终来到了 <code>Realize non-lazy classes (for +load methods and static instances)</code> ，略去无关信息之后，我们可以看到我们的<br>主角 <code>realizeClassWithoutSwift</code> 闪亮登场了：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115106.jpg" alt></p><p>从方法的名称以及方法注释我们可以知道， <code>realizeClassWithoutSwift</code> 是进行类的第一次初始化操作，包括分配读写数据也就是我们常说的 <code>rw</code> ，但是并不会进行任何的 <code>Swift</code> 端初始化。我们直接聚焦下面的代码：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115150.jpg" alt></p><ul><li>通过 <code>calloc</code> 开辟内存空间，返回一个新的 <code>rw</code> </li><li>把 <code>cls</code> 取出来的 <code>ro</code> 赋值给这个 <code>rw</code> </li><li>将 <code>rw</code> 设置到 <code>cls</code> 身上</li></ul><p>那么是不是说在这里 <code>rw</code> 就有值了呢，我们 <code>LLDB</code> 打印大法走起:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115158.jpg" alt></p><p>可以清楚地看到，此时 <code>rw</code> 还是为空，说明这里只是对 <code>rw</code> 进行了初始化，但是方法、属性、协议这些都没有被添加上。</p><p>我们接着往下走:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115206.jpg" alt></p><p>这里可以看到父类和元类都会递归调用 <code>realizeClassWithoutSwift</code> 来初始化各自的 <code>rw</code> 。为什么在类的加载操作里面要去加载类和元类呢？回忆一下类的结构，答案很简单，要保证 <code>superclass</code> 和 <code>isa</code> 的完整性，也就是保证类的完整性，</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115218.jpg" alt></p><p>上面的截图就是最好的证明，初始化完毕的父类和元类被赋值到了类的 <code>superclass</code> 和 <code>isa</code> 上面。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115226.jpg" alt></p><p>接着往下走可以看到，不光要把父类关联到类上面，还要让父类知道子类的存在。</p><p>最后一行代码是 <code>methodizeClass(cls)</code> ，注释显示的是 <code>attach categories</code> ，附加分类到类？我们进入其内部实现一探究竟。</p><p>在探索 <code>methodizeClass</code> 前，我们先总结一下 <code>realizeClassWithoutSwift</code> :</p><ul><li>读取 <code>class</code>  的 <code>data()</code> </li><li><code>ro/rw</code>  赋值</li><li>父类和元类实现<ul><li>supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass))</li><li>metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()))</li></ul></li><li>父类和元类归属关系<ul><li>cls-&gt;superclass = supercls</li><li>cls-&gt;initClassIsa(metacls)</li></ul></li><li>将当前类链接到其父类的子类列表 addSubclass(supercls, cls)</li></ul><h2 id="3-5-methodizeClass-分析"><a href="#3-5-methodizeClass-分析" class="headerlink" title="3.5 methodizeClass 分析"></a>3.5 methodizeClass 分析</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115239.jpg" alt></p><blockquote><p>对类的方法列表、协议列表和属性列表进行修正<br>附加 <code>category</code>  到类上面来</p></blockquote><p>我们直接往下面走：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Install methods and properties that the class implements itself.</span></span><br><span class="line"><span class="keyword">method_list_t</span> *<span class="built_in">list</span> = ro-&gt;baseMethods();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">    prepareMethodLists(cls, &amp;<span class="built_in">list</span>, <span class="number">1</span>, YES, isBundleClass(cls));</span><br><span class="line">    rw-&gt;methods.attachLists(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从 <code>ro</code> 中取出<strong>方法列表</strong>附加到 <code>rw</code> 上</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line"><span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">    rw-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从 <code>ro</code> 中取出<strong>属性列表</strong>附加到 <code>rw</code> 上</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line"><span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">    rw-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从 <code>ro</code> 中取出<strong>协议列表</strong>附加到 <code>rw</code> 上</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing*/</span>);</span><br><span class="line">attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*don't flush caches*/</span>);</span><br></pre></td></tr></table></figure><ul><li>从 <code>cls</code> 中取出未附加的分类进行附加操作</li></ul><p>我们可以看到，这里有一个操作叫 <code>attachLists</code> ，为什么方法、属性、协议都能调用这个方法呢？</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115313.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115322.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115327.jpg" alt></p><p>我们可以看到，方法、属性、协议的数据结构都是一个二维数组，我们深入 <code>attachLists</code> 方法内部实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;<span class="comment">//10</span></span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;<span class="comment">//4</span></span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;<span class="comment">// 10+4</span></span><br><span class="line">   </span><br><span class="line">        memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists,</span><br><span class="line">                oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">        <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">        List* oldList = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断要添加的数量是否为 0，如果为 0，直接返回</li><li>判断当前调用 <code>attachLists</code> 的 <code>list_array_tt</code> 二维数组有多个一维数组<ul><li>如果是，说明是<strong>多对多</strong>的关系</li><li>这里会通过 <code>realloc</code> 对容器进行重新分配，大小为原来的大小加上新增的大小</li><li>然后通过 <code>memmove</code> 把原来的数据移动到容器的末尾</li><li>最后把新的数据拷贝到容器的起始位置</li></ul></li><li>如果调用 <code>attachLists</code> 的 <code>list_array_tt</code> 二维数组为空且新增大小数目为 1，则直接取 <code>addedList</code> 的第一个 <code>list</code> 返回</li><li>如果当前调用 <code>attachLists</code> 的 <code>list_array_tt</code> 二维数组只有一个一维数组<ul><li>如果是，说明是<strong>一对多</strong>的关系</li><li>这里会通过 <code>realloc</code> 对容器进行重新分配，大小为原来的大小加上新增的大小</li><li>因为原来只有一个一维数组，所以直接赋值到新 <code>Array</code> 的最后一个位置</li><li>然后把新数据拷贝到容器的起始位置</li></ul></li></ul><h1 id="四、探索-load-images"><a href="#四、探索-load-images" class="headerlink" title="四、探索 load_images"></a>四、探索 load_images</h1><p>我们接着探索 <code>_dyld_objc_notify_register</code> 的第二个参数 <code>load_images</code> ，这个函数指针是在什么时候调用的呢，同样的，我们接着在 <code>dyld</code> 源码中搜索对应的函数指针 <code>sNotifyObjCInit</code> :</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115339.jpg" alt></p><p>可以看到，在 <code>notifySingle</code> 方法内部， <code>sNotifyObjCInit</code> 函数指针被调用了。根据我们上一篇文章探索 <code>dyld</code> 底层可以知道， <code>_load_images</code> 应该是对于每一个加载进来的 <code>Mach-O</code> 镜像都会递归调用一次。</p><p>我们来到 <code>libObjc</code> 源码中 <code>load_images</code> 的定义处:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119115441.jpg" alt></p><blockquote><p>处理由 <code>dyld</code> 映射的给定镜像中的 <code>+load</code>  方法</p></blockquote><ul><li>判断是否有 <code>load</code> 方法，如果没有，直接返回</li><li>搜索 <code>load</code> 方法，具体实现通过 <code>prepare_load_methods</code> </li><li>调用 <code>load</code> 方法，具体实现通过 <code>call_load_methods</code> </li></ul><h2 id="4-1-prepare-load-methods-分析"><a href="#4-1-prepare-load-methods-分析" class="headerlink" title="4.1 prepare_load_methods 分析"></a>4.1 prepare_load_methods 分析</h2><p>从这个方法名称，我们猜测这里应该做的是 <code>load</code> 方法的一些预处理工作，让我们来到源码进行分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">classref_t</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Swift class extensions and categories on Swift "</span></span><br><span class="line">                        <span class="string">"classes are not allowed to have +load methods"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* prepare_load_methods</span></span><br><span class="line"><span class="comment">* Schedule +load for classes in this image, any un-+load-ed </span></span><br><span class="line"><span class="comment">* superclasses in other images, and any categories in this image.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="comment">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span></span><br><span class="line"><span class="comment">// cls must already be connected.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* add_class_to_loadable_list</span></span><br><span class="line"><span class="comment">* Class cls has just become connected. Schedule it for +load if</span></span><br><span class="line"><span class="comment">* it implements a +load method.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先通过 <code>_getObjc2NonlazyClassList</code> 获取所有已经加载进去的类列表</li><li>然后通过 <code>schedule_class_load</code> 遍历这些类<ul><li>递归调用遍历父类的 <code>load</code> 方法，确保父类的 <code>load</code> 方法顺序排在子类的前面</li><li>通过 <code>add_class_to_loadable_list</code> , 把类的 <code>load</code> 方法存在 <code>loadable_classes</code> 里面</li><li><img src="https://upload-images.jianshu.io/upload_images/95471-11cae8927cfdf166?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul></li><li>完成 <code>schedule_class_load</code> 之后，通过 <code>_getObjc2NonlazyCategoryList</code> 取出所有分类数据</li><li>然后遍历这些分类<ul><li>通过 <code>realizeClassWithoutSwift</code> 来防止类没有初始化，如果已经初始化了则不影响</li><li>通过 <code>add_category_to_loadable_list</code> ，加载分类中的 <code>load</code> 方法到 <code>loadable_categories</code> 里面</li><li><img src="https://upload-images.jianshu.io/upload_images/95471-74f44fde4b425ea7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul></li></ul><h2 id="4-2-call-load-methods-分析"><a href="#4-2-call-load-methods-分析" class="headerlink" title="4.2 call_load_methods 分析"></a>4.2 call_load_methods 分析</h2><p><br>通过名称我们可以知道 <code>call_load_methods</code> 应该就是 <code>load</code> 方法被调用的地方了。我们直接看源码：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>call_load_methods<br>调用类和类别中所有未决的 <code>+load</code> 方法<br>类里面 <code>+load</code> 方法是父类优先调用的<br>而在父类的 <code>+load</code> 之后才会调用分类的 <code>+load</code> 方法</p></blockquote><ul><li>通过 <code>objc_autoreleasePoolPush</code> 压栈一个自动释放池</li><li><code>do-while</code> 循环开始<ul><li>循环调用类的 <code>+load</code> 方法直到找不到为止</li><li>调用一次分类中的 <code>+load</code> 方法</li></ul></li><li>通过 <code>objc_autoreleasePoolPop</code> 出栈一个自动释放池</li></ul><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>至此， <code>_objc_init</code> 和 <code>_dyld_objc_notify_register</code> 我们就分析完了，我们对类的加载有了更细致的认知。 <code>iOS</code> 底层有时候探索起来确实很枯燥，但是如果能找到高效的方法以及明确自己的所探索的方向，会让自己从宏观上重新审视这门技术。是的，技术只是工具，我们不能被技术所绑架，我们要做到有的放矢的去探索，这样才能事半功倍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、应用加载回顾&quot;&gt;&lt;a href=&quot;#一、应用加载回顾&quot; class=&quot;headerlink&quot; title=&quot;一、应用加载回顾&quot;&gt;&lt;/a&gt;一、应用加载回顾&lt;/h1&gt;&lt;p&gt;上一章我们对应用的加载有了初步的认识，我们知道了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统调用 &lt;code&gt;exec()&lt;/code&gt; 会我们的应用&lt;strong&gt;映射&lt;/strong&gt;到新的地址空间&lt;/li&gt;
&lt;li&gt;然后通过 &lt;code&gt;dyld&lt;/code&gt; 进行加载、链接、初始化主程序和主程序所依赖的各种动态库&lt;/li&gt;
&lt;li&gt;最后在 &lt;code&gt;initializeMainExecutable&lt;/code&gt; 方法中经过一系列初始化调用 &lt;code&gt;notifySingle&lt;/code&gt; 函数，该函数会执行一个 &lt;code&gt;load_images&lt;/code&gt; 的回调&lt;/li&gt;
&lt;li&gt;然后在 &lt;code&gt;doModinitFuntions&lt;/code&gt; 函数内部会调用 &lt;code&gt;__attribute__((constructor))&lt;/code&gt; 的 &lt;code&gt;c&lt;/code&gt; 函数&lt;/li&gt;
&lt;li&gt;然后 &lt;code&gt;dyld&lt;/code&gt; 返回主程序的入口函数，开始进入主程序的 &lt;code&gt;main&lt;/code&gt; 函数
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - 应用加载</title>
    <link href="http://leejunhui.com/2020/01/10/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://leejunhui.com/2020/01/10/iOS-底层探索-应用加载/</id>
    <published>2020-01-09T16:45:45.000Z</published>
    <updated>2020-01-19T03:30:43.074Z</updated>
    
    <content type="html"><![CDATA[<p><code>App</code> 从被用户在主屏幕上点击之后就开启了它的生命周期，那么在这之中，究竟发生了什么呢?让我们从 <code>App</code> 启动开始探索。在探索之前，我们需要熟悉一些前导知识点。</p><a id="more"></a><h1 id="一、前导知识"><a href="#一、前导知识" class="headerlink" title="一、前导知识"></a>一、前导知识</h1><p>以下参考自 <code>WWDC 2016 Optimizing App Startup Time</code> ：</p><h2 id="1-1-Mach-O"><a href="#1-1-Mach-O" class="headerlink" title="1.1 Mach-O"></a>1.1 Mach-O</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104621.jpg" alt></p><blockquote><p>Mach-O is a bunch of file types for different run time executables.<br><code>Mach-O</code> 是 <code>iOS</code> 系统不同运行时期<strong>可执行的文件</strong>的文件类型统称。</p></blockquote><p>维基百科上关于 <code>Mach-O</code> 的描述：</p><blockquote><p>Mach-O 是 Mach object 文件格式的缩写，它是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。作为 a.out 格式的替代品，Mach-O 提供了更好的扩展性，并提升了符号表中信息的访问速度。<br>大多数基于 Mach 内核的操作系统都使用 Mach-O。NeXTSTEP、OS X 和 iOS 是使用这种格式作为本地可执行文件、库和对象代码的例子。</p></blockquote><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104635.jpg" alt></p><p><code>Mach-O</code> 有三种文件类型: <code>Executable</code>、<code>Dylib</code>、<code>Bundle</code></p><ul><li><code>Executable</code> 类型</li></ul><blockquote><p>So the first executable, that’s the main binary in an app, it’s also the main binary in an app extension.<br><code>executable</code> 是 <code>app</code> 的二进制主文件，同时也是 <code>app extension</code> 的二进制主文件</p></blockquote><p>我们一般可以在 <code>Xcode</code> 项目中的 <code>Products</code> 文件夹中找到它：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104647.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104653.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104659.jpg" alt></p><p>如上图箭头所示，<code>App加载流程</code> 就是我们 <code>App</code> 的二进制主文件。</p><ul><li><code>Dylib</code> 类型</li></ul><blockquote><p>A dylib is a dynamic library, on other platforms meet, you may know those as DSOs or DLLs.<br><code>dylib</code> 是动态库，在其他平台也叫 <code>DSO</code> 或者 <code>DLL</code>。</p></blockquote><p>对于接触 <code>iOS</code> 开发比较早的同学，可能知道我们在 <code>Xcode 7</code> 之前添加一些比如 <code>sqlite</code> 的库的时候，其后缀名为 <code>dylib</code>，而 <code>Xcode 7</code> 之后后缀名都改成了 <code>tbd</code>。</p><p>这里引用 <a href="https://stackoverflow.com/questions/31450690/why-xcode-7-shows-tbd-instead-of-dylib" target="_blank" rel="noopener">StackoverFlow</a> 上的一篇回答。</p><blockquote><p>So it appears that the .dylib file is the actual library of binary code that your project is using and is located in the /usr/lib/ directory on the user’s device. The .tbd file, on the other hand, is just a text file that is included in your project and serves as a link to the required .dylib binary. Since this text file is much smaller than the binary library, it makes the SDK’s download size smaller.<br>看起来 <code>.dylib</code> 文件是项目中真正使用到的二进制库文件，它位于用户设备上的 <code>/usr/lib</code> 目录下。而 <code>.tbd</code> 文件，只是位于你项目中的一个文本文件，它扮演的是链接到真正的 <code>.dylib</code> 二进制文件的角色。因为文本文件的大小远远小于二进制文件的大小，所以让 <code>Xcode 的</code>SDK` 的下载大小更小。</p></blockquote><p>这里再插一句，那么有动态库，肯定就有静态库，它们的区别是什么呢？</p><p>我们先梳理一下整个的编译过程。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104715.jpg" alt></p><p>当然，这个过程中间其实还设计到编译器前端的 <code>词法分析</code>、<code>语法分析</code>、<code>语义分析</code>、<code>优化</code> 等流程，我们在后面探索 <code>LLVM</code> 和 <code>Clang</code> 的时候会详细介绍。</p><p>回到刚才的话题，静态库和动态库的区别：</p><blockquote><p>Static frameworks are linked at <strong>compile time</strong>. Dynamic frameworks are linked <strong>at runtime</strong>.</p></blockquote><p>静态库和动态库都是编译好的二进制文件，只是用法不同。那为什么要分动态和静态库呢？</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104729.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104736.jpg" alt></p><p>通过上面两幅图我们可以知道：</p><ul><li>静态库表现为：在链接阶段会将汇编生成的目标文件与引用的库一起链接打包进可执行文件中。</li><li>动态库表现为：程序编译并不会链接到目标代码中，在程序可执行文件里面会保留对动态库的引用。其中，动态库分为动态链接库和动态加载库。<ul><li><strong>动态链接库</strong>：在没有被加载到内存的前提下，当可执行文件被加载，动态库也随着被加载到内存中。在 <code>Linked Framework and Libraries</code> 设置的一些 <code>share libraries</code>。【随着程序启动而启动】</li><li><strong>动态加载库</strong>：当需要的时候再使用 <code>dlopen</code> 等通过代码或者命令的方式来加载。【在程序启动之后】</li></ul></li><li><code>Bundle</code> 类型</li></ul><blockquote><p>Now a bundle’s a special kind of dylib that you cannot link against, all you can do is load it at run time by an dlopen and that’s used on a Mac OS for plug-ins.<br>现阶段 <code>Bundle</code> 是一种特殊类型的 <code>dylib</code>，你是无法对其进行链接的。你所能做的是在 <code>Runtime</code> 运行时去通过 <code>dlopen</code> 来加载它，它可以在 <code>macOS</code> 上用于插件。</p></blockquote><ul><li><code>Image</code> 和 <code>Framework</code></li></ul><blockquote><p>Image refers to any of these three types.<br>镜像文件包含了上述的三种文件类型</p></blockquote><blockquote><p>a framework is a dylib with a special directory structure around it to holds files needed by that dylib.<br>有很多东西都叫做 <code>Framework</code>，但在本文中，<code>Framework</code> 指的是一个 <code>dylib</code>，它周围有一个特殊的目录结构来保存该 <code>dylib</code> 所需的文件。</p></blockquote><h3 id="1-1-1-Mach-O-结构分析"><a href="#1-1-1-Mach-O-结构分析" class="headerlink" title="1.1.1 Mach-O 结构分析"></a>1.1.1 Mach-O 结构分析</h3><h4 id="1-1-1-1-segment-段"><a href="#1-1-1-1-segment-段" class="headerlink" title="1.1.1.1 segment 段"></a>1.1.1.1 segment 段</h4><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104753.jpg" alt></p><p><code>Mach-O</code> 镜像文件是由 <code>segments</code> 段组成的。</p><ul><li>段的名称为大写格式<br><br>所有的段都是 <code>page size</code> 的倍数。</li><li>arm64 上段大小为 <code>16</code> 字节</li><li>其它架构为 <code>4</code> 字节</li></ul><p>这里再普及一下<strong>虚拟内存</strong>和<strong>内存页</strong>的知识：</p><blockquote><p>具有 <code>VM</code> 机制的操作系统，会对每个运行的进程创建一个逻辑地址空间 <code>logical address space</code> 或者叫虚拟地址空间 <code>virtual address space</code>；该空间的大小由操作系统位数决定：<code>32</code> 位的操作系统，其逻辑地址空间的大小为 <code>4GB</code>，64位的操作系统为 <code>18 exabyes</code>（其计算方式是 <code>2^32</code> || <code>2^64</code>）。</p></blockquote><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104805.jpg" alt></p><blockquote><p>虚拟地址空间(或者逻辑地址空间)会被分为相同大小的块，这些块被称为内存页（page）。计算机处理器和它的内存管理单元（MMU - memory management uinit）维护着一张将程序的逻辑地址空间映射到物理地址上的分页表 <code>page table</code>。</p></blockquote><blockquote><p>在 <code>masOS</code> 和早版本的 <code>iOS</code> 中，分页的大小为 <code>4kB</code>。在之后的基于 <code>A7</code> 和 <code>A8</code> 的系统中，虚拟内存（<code>64</code> 位的地址空间）地址空间的分页大小变为了 <code>16KB</code>，而物理RAM上的内存分页大小仍然维持在 <code>4KB</code>；基于A9及之后的系统，虚拟内存和物理内存的分页都是<code>16KB</code>。</p></blockquote><h4 id="1-1-1-2-section"><a href="#1-1-1-2-section" class="headerlink" title="1.1.1.2 section"></a>1.1.1.2 section</h4><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104814.jpg" alt></p><p>在 <code>segment</code> 段内部还有许多的 <code>section</code> 区。<code>section</code> 名称为小写格式。</p><blockquote><p>But sections are really just a subrange of a segment, they don’t have any of the constraints of being page size, but they are non-overlapping.<br>但是 <code>sections</code> 节实际上只是一个 <code>segment</code> 段的子范围，它们没有页面大小的任何限制，但是它们是不重叠的。</p></blockquote><p>通过 <code>MachOView</code> 工具查看 <code>app</code> 的二进制可执行文件可以查看到:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104825.jpg" alt></p><h4 id="1-1-1-3-常见的-segments"><a href="#1-1-1-3-常见的-segments" class="headerlink" title="1.1.1.3 常见的 segments"></a>1.1.1.3 常见的 <code>segments</code></h4><ul><li><code>__TEXT</code>：代码段，包括头文件、代码和常量。只读不可修改</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104838.jpg" alt></p><ul><li><code>__DATA</code>：数据段，包括全局变量, 静态变量等。可读可写。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104849.jpg" alt></p><ul><li><code>__LINKEDIT</code>：如何加载程序, 包含了方法和变量的元数据（位置，偏移量），以及代码签名等信息。只读不可修改。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104902.jpg" alt></p><h3 id="1-1-2-Mach-O-Universal-Files"><a href="#1-1-2-Mach-O-Universal-Files" class="headerlink" title="1.1.2 Mach-O Universal Files"></a>1.1.2 Mach-O Universal Files</h3><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119104912.jpg" alt></p><p><code>Mach-O</code> 通用文件，将多种架构的 <code>Mach-O</code> 文件合并而成。它通过 <code>header</code> 来记录不同架构在文件中的偏移量，<code>segement</code> 占多个分页，<code>header</code>占一页的空间。可能有人会觉得 <code>header</code> 单独占一页会浪费空间，但这有利于虚拟内存的实现。</p><h2 id="1-2-虚拟内存"><a href="#1-2-虚拟内存" class="headerlink" title="1.2 虚拟内存"></a>1.2 虚拟内存</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119105004.jpg" alt></p><p>虚拟内存是一层<strong>间接寻址</strong>。</p><p>虚拟内存解决的是管理所有进程使用<strong>物理 RAM</strong> 的问题。通过添加间接层来让每个进程使用<strong>逻辑地址空间</strong>，它可以映射到 RAM 上的某个物理页上。这种映射不是一对一的，逻辑地址可能映射不到 RAM 上，也可能有多个逻辑地址映射到同一个物理 RAM 上。</p><ul><li>针对第一种情况，当进程要存储逻辑地址内容时会触发 <code>page fault</code>。</li><li>而第二种情况就是多进程共享内存。</li><li>对于文件可以不用一次性读入整个文件，可以使用分页映射 <code>mmap()</code> 的方式读取。也就是把文件<strong>某个片段</strong>映射到进程逻辑内存的<strong>某个页</strong>上。当某个想要读取的页没有在内存中，就会触发 <code>page fault</code>，内核只会读入那一页，实现文件的<strong>懒加载</strong>。也就是说 <code>Mach-O</code> 文件中的 <code>__TEXT</code> 段可以映射到多个进程，并可以懒加载，且进程之间<strong>共享内存</strong>。</li><li><code>__DATA</code> 段是可读写的。这里使用到了 <code>Copy-On-Write</code> 技术，简称 <code>COW</code>。也就是多个进程共享一页内存空间时，一旦有进程要做写操作，它会先将这页内存内容<strong>复制</strong>一份出来，然后重新映射逻辑地址到新的 <code>RAM</code> 页上。也就是这个进程自己拥有了那页内存的拷贝。这就涉及到了 <code>clean/dirty page</code> 的概念。<code>dirty page</code> 含有进程自己的信息，而 <code>clean page</code> 可以被内核重新生成（重新读磁盘）。所以 <code>dirty page</code> 的代价大于 <code>clean page</code>。</li></ul><h2 id="1-3-多进程加载-Mach-O-镜像"><a href="#1-3-多进程加载-Mach-O-镜像" class="headerlink" title="1.3 多进程加载 Mach-O 镜像"></a>1.3 多进程加载 Mach-O 镜像</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119105025.jpg" alt></p><ul><li>所以在多个进程加载 <code>Mach-O</code> 镜像时 <code>__TEXT</code> 和 <code>__LINKEDIT</code> 因为只读，都是可以共享内存的，读取速度就会很快。</li><li>而 <code>__DATA</code> 因为可读写，就有可能会产生 <code>dirty page</code>，如果检测到有 <code>clean page</code> 就可以直接使用，反之就需要重新读取 <code>DATA page</code>。一旦产生了 <code>dirty page</code>，当 <code>dyld</code> 执行结束后，<code>__LINKEDIT</code> 需要通知内核当前页面不再需要了，当别人需要的使用时候就可以重新 <code>clean</code> 这些页面。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119105037.jpg" alt></p><h2 id="1-4-ASLR"><a href="#1-4-ASLR" class="headerlink" title="1.4 ASLR"></a>1.4 ASLR</h2><p><code>ASLR</code> (Address Space Layout Randomization) 地址空间布局随机化，镜像会在随机的地址上加载。</p><h2 id="1-5-Code-Signing"><a href="#1-5-Code-Signing" class="headerlink" title="1.5 Code Signing"></a>1.5 Code Signing</h2><p>可能我们认为 <code>Xcode</code> 会把整个文件都做加密 <code>hash</code> 并用做数字签名。其实为了在运行时验证 <code>Mach-O</code> 文件的签名，并不是每次重复读入整个文件，而是把每页内容都生成一个单独的加密散列值，并存储在 <code>__LINKEDIT</code> 中。这使得文件每页的内容都能及时被校验确并保不被篡改。</p><h2 id="1-6-exec"><a href="#1-6-exec" class="headerlink" title="1.6 exec()"></a>1.6 <code>exec()</code></h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119105102.jpg" alt></p><blockquote><p>Exec is a system call. When you trap into the kernel, you basically say I want to replace this process with this new program.</p></blockquote><blockquote><p><code>exec()</code> 是一个系统调用。系统内核把应用映射到新的地址空间，且每次起始位置都是随机的（因为使用 <code>ASLR</code>）。并将起始位置到 <code>0x000000</code> 这段范围的进程权限都标记为不可读写不可执行。如果是 <code>32</code> 位进程，这个范围至少是 <code>4KB</code>；对于 <code>64</code> 位进程则至少是 <code>4GB</code> 。<code>NULL</code> 指针引用和指针截断误差都是会被它捕获。这个范围也叫做 <code>PAGEZERO</code>。</p></blockquote><h2 id="1-7-dyld"><a href="#1-7-dyld" class="headerlink" title="1.7 dyld"></a>1.7 dyld</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111212.jpg" alt></p><blockquote><p>Unix 的前二十年很安逸，因为那时还没有发明动态链接库。有了动态链接库后，一个用于加载链接库的帮助程序被创建。在苹果的平台里是 <code>dyld</code>，其他 <code>Unix</code> 系统也有 <code>ld.so</code>。 当内核完成映射进程的工作后会将名字为 <code>dyld</code> 的 <code>Mach-O</code> 文件映射到进程中的随机地址，它将 <code>PC</code> 寄存器设为 <code>dyld</code> 的地址并运行。<code>dyld</code> 在应用进程中运行的工作是加载应用依赖的所有动态链接库，准备好运行所需的一切，它拥有的权限跟应用一样。</p></blockquote><h2 id="1-8-dyld-流程"><a href="#1-8-dyld-流程" class="headerlink" title="1.8 dyld 流程"></a>1.8 dyld 流程</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111227.jpg" alt></p><ul><li>Load dylibs</li></ul><blockquote><p>从主执行文件的 <code>header</code> 获取到需要加载的所依赖动态库列表，而 <code>header</code> 早就被内核映射过。然后它需要找到每个 <code>dylib</code>，然后打开文件读取文件起始位置，确保它是 <code>Mach-O</code> 文件。接着会找到代码签名并将其注册到内核。然后在 <code>dylib</code> 文件的每个 <code>segment</code> 上调用 <code>mmap()</code>。应用所依赖的 <code>dylib</code> 文件可能会再依赖其他 <code>dylib</code>，所以 <code>dyld</code> 所需要加载的是动态库列表一个递归依赖的集合。一般应用会加载 <code>100</code> 到 <code>400</code> 个 <code>dylib</code> 文件，但大部分都是系统 <code>dylib</code>，它们会被预先计算和缓存起来，加载速度很快。</p></blockquote><ul><li>Fix-ups</li></ul><blockquote><p>在加载所有的动态链接库之后，它们只是处在相互独立的状态，需要将它们<strong>绑定</strong>起来，这就是 <code>Fix-ups</code>。代码签名使得我们不能修改指令，那样就不能让一个 <code>dylib</code> 的调用另一个 <code>dylib</code>。这时需要加很多间接层。<br>现代 <code>code-gen</code> 被叫做动态 <strong>PIC（Position Independent Code）</strong>，意味着代码可以被加载到间接的地址上。当调用发生时，<code>code-gen</code> 实际上会在 <code>__DATA</code> 段中创建一个指向被调用者的指针，然后加载指针并跳转过去。所以 <code>dyld</code> 做的事情就是修正（<code>fix-up</code>）指针和数据。<code>Fix-up</code> 有两种类型，<code>rebasing</code> 和 <code>binding</code>。</p></blockquote><ul><li>Rebasing 和 Binding</li></ul><blockquote><p>Rebasing：在镜像内部<strong>调整</strong>指针的指向<br>Binding：将指针<strong>指向镜像外部</strong>的内容</p></blockquote><p><code>dyld</code> 的时间线由上图可知为：</p><p>Load dylibs -&gt; Rebase -&gt; Bind -&gt; ObjC -&gt; Initializers</p><h2 id="1-9-dyld2-amp-amp-dyld3"><a href="#1-9-dyld2-amp-amp-dyld3" class="headerlink" title="1.9 dyld2 &amp;&amp; dyld3"></a>1.9 dyld2 &amp;&amp; dyld3</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111245.jpg" alt></p><p>在 <code>iOS 13</code> 之前，所有的第三方 <code>App</code> 都是通过 <code>dyld 2</code> 来启动 <code>App</code> 的，主要过程如下：</p><ul><li>解析 <code>Mach-O</code> 的 <code>Header</code> 和 <code>Load Commands</code>，找到其依赖的库，并递归找到所有依赖的库</li><li>加载 <code>Mach-O</code> 文件</li><li>进行符号查找</li><li>绑定和变基</li><li>运行初始化程序</li></ul><p><code>dyld3</code> 被分为了<strong>三个组件</strong>：</p><ul><li>一个进程外的 <code>MachO</code> 解析器<ul><li>预先处理了所有可能影响启动速度的 <code>search path</code>、<code>@rpaths</code> 和环境变量</li><li>然后分析 <code>Mach-O</code> 的 <code>Header</code> 和依赖，并完成了所有符号查找的工作</li><li>最后将这些结果创建成了一个启动闭包</li><li>这是一个普通的 <code>daemon</code> 进程，可以使用通常的测试架构</li></ul></li><li>一个进程内的引擎，用来运行启动闭包<ul><li>这部分在进程中处理</li><li>验证启动闭包的安全性，然后映射到 <code>dylib</code> 之中，再跳转到 <code>main</code> 函数</li><li>不需要解析 <code>Mach-O</code> 的 <code>Header</code> 和依赖，也不需要符号查找。</li></ul></li><li>一个启动闭包缓存服务<ul><li>系统 <code>App</code> 的启动闭包被构建在一个 <code>Shared Cache</code> 中， 我们甚至不需要打开一个单独的文件</li><li>对于第三方的 <code>App</code>，我们会在 <code>App</code> 安装或者升级的时候构建这个启动闭包。</li><li>在 <code>iOS</code>、<code>tvOS</code>、<code>watchOS</code>中，这这一切都是 <code>App</code> 启动之前完成的。在 <code>macOS</code> 上，由于有 <code>Side Load App</code>，进程内引擎会在首次启动的时候启动一个 <code>daemon</code> 进程，之后就可以使用启动闭包启动了。</li></ul></li></ul><p>dyld 3 把很多耗时的查找、计算和 <code>I/O</code> 的事前都预先处理好了，这使得启动速度有了很大的提升。</p><p>好了，先导知识就总结到这里，接下来让我们调整呼吸进入下一章~</p><h1 id="二、App-加载分析"><a href="#二、App-加载分析" class="headerlink" title="二、App 加载分析"></a>二、App 加载分析</h1><p>我们在探索 <code>iOS</code> 底层的时候，对于对象、类、方法有了一定的认知哦，接下来我们就一起来探索一下应用是怎么加载的。</p><p>我们直接新建一个 <code>Single View App</code> 的项目，然后在 <code>main.m</code> 中打一个断点:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111300.jpg" alt></p><p>然后我们可以看到在 <code>main</code> 方法执行前有一步 <code>start</code>，而这一流程是由 <code>libdyld.dylib</code> 这个动态库来执行的。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111305.jpg" alt></p><p>这个现象说明了什么呢？说明我们的 <code>app</code> 在 <code>main</code> 函数执行之前其实还通过 <code>dyld</code> 做了很多事情。那为了搞清楚具体的流程，我们不妨从 <a href="https://opensource.apple.com/tarballs/" target="_blank" rel="noopener">Apple OpenSource</a> 上下载 <code>dyld</code> 的源码来进行探索。</p><p>我们选择最新的 <code>655.1.1</code> 版本：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111329.jpg" alt></p><h1 id="三、dyld-源码分析"><a href="#三、dyld-源码分析" class="headerlink" title="三、dyld 源码分析"></a>三、<code>dyld</code> 源码分析</h1><p>面对 <code>dyld</code> 的源码，我们不可能一行一行的去分析。我们不妨在刚才创建的项目中断点一下 <code>load</code> 方法，看下调用堆栈:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111343.jpg" alt></p><p>这一次我们发现，<code>load</code> 方法的调用要早于 <code>main</code> 函数的调用，其次，我们得到了一个非常有价值的线索: <code>_dyld_start</code>。</p><h2 id="3-1-dyld-start"><a href="#3-1-dyld-start" class="headerlink" title="3.1 _dyld_start"></a>3.1 _dyld_start</h2><p>我们直接在 <code>dyld 655.1.1</code> 中全局搜索这个 <code>_dyld_start</code>，我们可以来到 <code>dyldStartup.s</code> 这个汇编文件，然后我们聚焦于 <code>arm64</code> 架构下的汇编代码:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111418.jpg" alt></p><p>对于这里的汇编代码，我们肯定也没必要逐行分析，我们直接定位到 <code>bl</code> 语句后面(<code>bl</code> 在汇编层面是跳转的意思)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bl__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm</span><br></pre></td></tr></table></figure><p>我们可以看到这里有一行注释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)</span><br></pre></td></tr></table></figure><p>这行注释的意思是调用位于 <code>dyldbootstrap</code> 命名空间下的 <code>start</code> 方法，我们继续搜索一下这个 <code>start</code> 方法，结果位于 <code>dyldInitialization.cpp</code> 文件(从文件名我们可以看出该文件主要是用来初始化 <code>dyld</code>)，这里查找 <code>start</code> 的时候可能会有很多结果，我们其实可以先搜索命名空间，再搜索 <code>start</code> 方法。</p><h2 id="3-2-dyldbootstrap-start"><a href="#3-2-dyldbootstrap-start" class="headerlink" title="3.2 dyldbootstrap::start"></a>3.2 dyldbootstrap::start</h2><p><code>start</code> 方法源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</span></span><br><span class="line"><span class="comment">//  In dyld we have to do this manually.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">uintptr_t</span> start(<span class="keyword">const</span> struct macho_header* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], </span><br><span class="line"><span class="keyword">intptr_t</span> slide, <span class="keyword">const</span> struct macho_header* dyldsMachHeader,</span><br><span class="line"><span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class="line"><span class="comment">// we have to do this before using any global variables</span></span><br><span class="line">    slide = slideOfMainExecutable(dyldsMachHeader);</span><br><span class="line">    <span class="keyword">bool</span> shouldRebase = slide != <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(ptrauth_calls)</span></span><br><span class="line">    shouldRebase = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> ( shouldRebase ) &#123;</span><br><span class="line">        rebaseDyld(dyldsMachHeader, slide);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// allow dyld to use mach messaging</span></span><br><span class="line">mach_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line"><span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">++apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up random value for stack canary</span></span><br><span class="line">__guard_setup(apple);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line"><span class="comment">// run all C++ initializers inside dyld</span></span><br><span class="line">runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// now that we are done bootstrapping dyld, call dyld's main</span></span><br><span class="line"><span class="keyword">uintptr_t</span> appsSlide = slideOfMainExecutable(appsMachHeader);</span><br><span class="line"><span class="keyword">return</span> dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们刚才探索到了 <code>start</code> 方法，具体流程如下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111440.jpg" alt></p><ul><li>根据 <code>dyld</code> 的 <code>Mach-O</code> 文件的 <code>header</code> 判断是否需要对 <code>dyld</code> 这个 <code>Mach-O</code> 进行 <code>rebase</code> 操作</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111448.jpg" alt></p><ul><li>初始化 <code>mach</code>，使得 <code>dyld</code> 可以进行 <code>mach</code> 通讯。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111504.jpg" alt></p><ul><li>内核将 <code>env</code> 指针设置为刚好超出 <code>agv</code> 数组的末尾；内核将 <code>apple</code> 指针设置为刚好超出 <code>envp</code> 数组的末尾</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111511.jpg" alt></p><ul><li>栈溢出保护</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111519.jpg" alt></p><ul><li>读取 <code>app</code> 主二进制文件 <code>Mach-O</code> 的 <code>header</code> 来得到偏移量 <code>appSlide</code>，然后调用 <code>dyld</code> 命名空间下的 <code>_main</code> 方法。</li></ul><h2 id="3-3-dyldbootstrap-main"><a href="#3-3-dyldbootstrap-main" class="headerlink" title="3.3 dyldbootstrap::_main"></a>3.3 dyldbootstrap::_main</h2><p>我们通过搜索来到 <code>dyld.cpp</code> 文件下的 <code>_main</code> 方法：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111542.jpg" alt></p><p><code>_main方法</code> 官方的注释如下：</p><blockquote><p><code>dyld</code> 的入口。内核加载了 <code>dyld</code> 然后跳转到 <code>__dyld_start</code> 来设置一些寄存器的值然后调用到了这个方法。<br>返回 <code>__dyld_start</code> 所跳转到的目标程序的 <code>main</code> 函数地址。</p></blockquote><p>我们乍一看，这个方法有四五百行，所以我们不能老老实实的一行一行来看，这样太累了。我们应该着重于有注释的地方。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111551.jpg" alt></p><ul><li>我们首先可以看到这里是从环境变量中获取主要可执行文件的 <code>cdHash</code> 值。这个哈希值 <code>mainExecutableCDHash</code> 在后面用来校验 <code>dyld3</code> 的启动闭包。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111601.jpg" alt></p><ul><li>上图代码作用是追踪 <code>dyld</code> 的加载。然后判断当前是否为模拟器环境，如果不是模拟器，则追踪主二进制可执行文件的加载。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111608.jpg" alt></p><ul><li>显示宏定义判断是否为 <code>macOS</code> 执行环境，如果是则判断 <code>DYLD_ROOT_PATH</code> 环境变量是否存在，如果存在，然后判断模拟器是否有自己的 <code>dyld</code>，如果有就使用，如果没有，则返回错误信息。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111647.jpg" alt></p><ul><li>打印日志：<code>dyld 启动开始</code></li><li>根据传入 <code>dyldbootstrap::_main</code> 方法的参数来设置上下文</li><li>拾取指向 <code>exec</code> 路径的指针</li><li>从 <code>dyl</code> d移除临时 <code>apple [0]</code> 过渡代码</li><li>判断 <code>exec</code> 路径是否为绝对路径，如果为相对路径，使用 <code>cwd</code> 转化为绝对路径</li><li>为了后续的日志打印从 <code>exec</code> 路径中取出进程的名称 (<code>strrchr</code> 函数是获取第二个参数出现的最后的一个位置，然后返回从这个位置开始到结束的内容)</li><li>根据 <code>App</code> 主二进制可执行文件 <code>Mach-O</code> 的 <code>Header</code> 的内容配置进程的一些限制条件</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111938.jpg" alt></p><ul><li>判断是否为 <code>macOS</code> 执行环境，如果是的话，再判断上下文的一些配置属性是否被设置了，如果没有被设置，则再次进行一次 <code>setContext</code> 上下文配置操作。</li><li>根据传入的参数 <code>envp</code> 检查环境变量</li><li>默认未初始化的后备路径</li><li>判断是否为 <code>macOS</code> 执行环境，如果是的话，再判断当前 <code>app</code> 的 <code>Mach-O</code> 可执行文件是否为 <code>iOSMac</code> 类型且不为 <code>macOS</code> 类型的话，则重置上下文的根路径，然后再判断 <code>DYLD_FALLBACK_LIBRARY_PATH</code> 和 <code>DYLD_FALLBACK_FRAMEWORK_PATH</code> 这两个环境变量是否都是默认后备路径，如果是的话赋值为受限的后备路径。<br></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119111950.jpg" alt></p><ul><li>根据环境变量 <code>DYLD_PRINT_OPTS</code> 和 <code>DYLD_PRINT_ENV</code> 来判断是否需要打印</li><li>通过当前 <code>app</code> 的 <code>Mach-O</code> 可执行文件的 <code>header</code> 和 <code>ASLR</code> 之后的偏移量来获取架构信息。在这里会判断如果是 <code>GC</code> 的程序则会禁用掉共享缓存。<br></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112001.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112010.jpg" alt></p><ul><li>判断共享缓存是否开启，如果开启了就将共享缓存映射到当前进程的逻辑内存空间内</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112047.jpg" alt></p><ul><li>检查共享缓存这里会先判断 <code>app</code> 的 <code>Mach-O</code> 二进制可执行文件是否有段覆盖了共享缓存区域，如果覆盖了则禁用共享缓存。但是这里的前提是 <code>macOS</code>，在 <code>iOS</code> 中，共享缓存是必需的。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112057.jpg" alt></p><blockquote><p>这里为了方便查看，我们可以折叠一些分支条件。</p></blockquote><ul><li>通过共享缓存中的头的版本信息来判断是走 <code>dyld 2</code> 还是 <code>dyld 3</code> 的流程</li></ul><h2 id="3-4-dyld3-的处理"><a href="#3-4-dyld3-的处理" class="headerlink" title="3.4 dyld3 的处理"></a>3.4 dyld3 的处理</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112122.jpg" alt></p><ul><li>由于 <code>dyld3</code> 会创建一个启动闭包<img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112105.jpg" alt><br>，我们需要来读取它，这里会现在缓存中查找是否有启动闭包的存在，前面我们已经说过了，系统级的 <code>app</code> 的启动闭包是存在于共享缓存中，而我们自己开发的 <code>app</code> 的启动闭包是在 <code>app</code> 安装或者升级的时候构建的，所以这里检查 <code>dyld</code> 中的缓存是有意义的。</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112229.jpg" alt></p><ul><li>宏定义判断代码执行条件为真机。</li><li>如果 <code>dyld</code> 缓存中没有找到启动闭包或者找到了启动闭包但是验证失败（我们最开始提到的 <code>cdHash</code> 在这里出现了）<ul><li>从启动闭包缓存中查找<ul><li>如果还是没有找到，那就创建一个新的启动闭包</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112240.jpg" alt></p><ul><li>打印日志信息：<code>dyld3 启动开始</code></li><li>尝试通过启动闭包进行启动<ul><li>如果启动失败，则创建一个新的启动闭包尝试再次启动</li><li>如果启动成功，由于 <code>start()</code> 是以函数指针的方式调用 <code>_main</code> 方法的返回的指针，需要进行签名。</li></ul></li></ul><p>至此，<code>dyld3</code> 的流程就处理完毕，我们再接着往下分析 <code>dyld2</code> 的流程。</p><h2 id="3-5-dyld2-的处理"><a href="#3-5-dyld2-的处理" class="headerlink" title="3.5 dyld2 的处理"></a>3.5 dyld2 的处理</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112254.jpg" alt></p><ul><li>这里会添加 <code>dyld</code> 的镜像文件到 <code>UUID</code> 列表中，主要的目的是启用堆栈的符号化。<br></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112300.jpg" alt></p><hr><p><strong>reloadAllImages</strong></p><blockquote><p><code>ImageLoader</code> 是一个用于加载可执行文件的基类，它负责链接镜像，但不关心具体文件格式，因为这些都交给子类去实现。每个可执行文件都会对应一个 <code>ImageLoader</code>实例。<code>ImageLoaderMachO</code> 是用于加载 <code>Mach-O</code> 格式文件的 <code>ImageLoader</code> 子类，而 <code>ImageLoaderMachOClassic</code> 和 <code>ImageLoaderMachOCompressed</code> 都继承于 <code>ImageLoaderMachO</code>，分别用于加载那些 <code>__LINKEDIT</code> 段为传统格式和压缩格式的 <code>Mach-O</code> 文件。</p></blockquote><p>接下来就来到重头戏了 <code>reloadAllImages</code> 了：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112310.jpg" alt></p><hr><p><strong>实例化主程序</strong></p><p>这里我们看到有一行代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br></pre></td></tr></table></figure><p>显然，在这里我们的主程序被实例化了，我们进入这个方法内部：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112334.jpg" alt></p><p>这里相当于要为已经映射到主可执行文件中的文件创建一个 <code>ImageLoader*</code>。</p><p>从上面代码我们不难看出这里真正执行的逻辑是 <code>ImageLoaderMachO::instantiateMainExecutable</code> 方法：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112344.jpg" alt></p><p>我们再进入 <code>sniiffLoadCommands</code> 方法内部：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112354.jpg" alt></p><p>通过注释不难看出：<code>sniiffLoadCommands</code> 会确定此 <code>mach-o</code> 文件是否具有原始的或压缩的 <code>LINKEDIT</code> 以及 <code>mach-o</code> 文件的 <code>segement</code> 的个数。</p><p><code>sniiffLoadCommands</code> 完成后，判断 <code>LINKEDIT</code> 是压缩的格式还是传统格式，然后分别调用对应的 <code>instantiateMainExecutable</code> 方法来实例化主程序。</p><hr><p><strong>加载任何插入的动态库</strong><br></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112524.jpg" alt></p><hr><p><strong>链接库</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112533.jpg" alt></p><p>先是链接主二进制可执行文件，然后链接任何插入的动态库。这里都用到了 <code>link</code> 方法，在这个方法内部会执行递归的 <code>rebase</code> 操作来修正 <code>ASLR</code> 偏移量问题。同时还会有一个 <code>recursiveApplyInterposing</code> 方法来递归的将动态加载的镜像文件插入。</p><hr><p><strong>运行所有初始化程序</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112542.jpg" alt></p><p>完成链接之后需要进行初始化了，这里会来到 <code>initializeMainExecutable</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112548.jpg" alt></p><p>这里注意执行顺序：</p><ul><li>先为所有插入并链接完成的动态库执行初始化操作</li><li>然后再为主程序可执行文件执行初始化操作</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112555.jpg" alt></p><p>在 <code>runInitializers</code> 内部我们继续探索到 <code>processInitializers</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112602.jpg" alt></p><p>然后我们来到 <code>recursiveInitialization</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112609.jpg" alt></p><p>然后我们来到 <code>notifySingle</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112617.jpg" alt></p><p>箭头所示的地方是获取镜像文件的真实地址。</p><p>我们全局搜索一下 <code>sNotifyObjcInit</code> 可以来到 <code>registerObjCNotifiers</code>：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112623.jpg" alt></p><p>接着搜索 <code>registerObjCNotifiers</code>：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112630.jpg" alt></p><p>此时，我们打开 <code>libObjc</code> 的源码可以看到:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112638.jpg" alt></p><p>上面这一连串的跳转，结果很显然：<code>dyld</code> 注册了回调才使得 <code>libobjc</code> 能知道镜像何时加载完毕。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112702.jpg" alt></p><p>在 <code>ImageLoader::recursiveInitialization</code> 方法中还有一个 <code>doInitialization</code> 值得注意，这里是真正做初始化操作的地方。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112714.jpg" alt></p><p><code>doInitialization</code> 主要有两个操作，一个是 <code>doImageInit</code>，一个是 <code>doModInitFunctions</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112723.jpg" alt></p><p><code>doImageInit</code> 内部会通过初始地址 + 偏移量拿到初始化器 <code>func</code>，然后进行签名的验证。验证通过后还要判断初始化器是否在镜像文件中以及 <code>libSystem</code> 库是否已经初始化，最后才执行初始化器。</p><hr><p><strong>通知监听 dyld 的 main</strong></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112731.jpg" alt></p><p>一切工作做完后通知监听 <code>dyld</code> 的 <code>main</code>，然后为主二进制可执行文件找到入口，最后对结果进行签名。</p><h1 id="四、探索-objc-init"><a href="#四、探索-objc-init" class="headerlink" title="四、探索 _objc_init"></a>四、探索 _objc_init</h1><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112747.jpg" alt></p><p>我们直接通过 <code>LLDB</code> 大法来断点调试 <code>libObjc</code> 中的 <code>_objc_init</code>，然后通过 <code>bt</code> 命令打印出当前的调用堆栈，根据上一节我们探索 <code>dyld</code> 的源码，此刻一切的一切都是那么的清晰明了：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112754.jpg" alt></p><p>我们可以看到 <code>dyld</code> 的最后一个流程是 <code>doModInitFunctions</code> 方法的执行。</p><p>我们打开 <code>libSystem</code> 的源码，全局搜索 <code>libSystem_initializer</code> 可以看到：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119112803.jpg" alt></p><p>然后我们打开 <code>libDispatch</code> 的源码，全局搜索 <code>libdispatch_init</code> 可以看到：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113010.jpg" alt></p><p>我们再搜索 <code>_os_object_init</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119113018.jpg" alt></p><p>完美~，<code>_objc_init</code> 在这里就被调用了。所以 <code>_objc_init</code> 的流程是</p><p>dyld -&gt; libSystem -&gt; libDispatch -&gt; libObc -&gt; <code>_objc_init</code></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>本文主要探索了 <code>app</code> 启动之后 <code>dyld</code> 的流程，整个分析过程确实比较复杂，但在探索的过程中，我们不仅对底层源码有了新的认知，同时对于优化我们 <code>app</code> 启动也是有很多好处的。下一章，我们会对 <code>objc_init</code> 内部的 <code>map_images</code> 和 <code>load_images</code> 进行更深入的分析，敬请期待~</p><h1 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h1><p><a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="noopener">Optimizing App Startup Time</a></p><p><a href="https://xiaozhuanlan.com/topic/4690823715" target="_blank" rel="noopener">优化 App 启动</a></p><p><a href="https://github.com/Damonvvong/DevNotes/blob/master/Notes/framework.md" target="_blank" rel="noopener">iOS 开发中的『库』(一)</a></p><p><a href="https://www.awsomejiang.com/2018/01/15/Memory-Management-For-iOS-Apps-No-2/" target="_blank" rel="noopener">iOS应用的内存管理（二）</a></p><p><a href="http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/#%E5%8A%A0%E8%BD%BD-Dylib" target="_blank" rel="noopener">优化 App 的启动时间</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;App&lt;/code&gt; 从被用户在主屏幕上点击之后就开启了它的生命周期，那么在这之中，究竟发生了什么呢?让我们从 &lt;code&gt;App&lt;/code&gt; 启动开始探索。在探索之前，我们需要熟悉一些前导知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - 消息转发</title>
    <link href="http://leejunhui.com/2020/01/08/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>http://leejunhui.com/2020/01/08/iOS-底层探索-消息转发/</id>
    <published>2020-01-08T07:33:00.000Z</published>
    <updated>2020-01-19T02:35:44.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态方法解析流程分析"><a href="#动态方法解析流程分析" class="headerlink" title="动态方法解析流程分析"></a>动态方法解析流程分析</h1><p>我们在上一章《消息查找》分析到了<strong>动态方法解析</strong>，为了更好的掌握具体的流程，我们接下来直接进行源码追踪。</p><a id="more"></a><p>我们先来到 <code>_class_resolveMethod</code> 方法，该方法源码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line"></span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概的流程如下：</p><ul><li>判断进行解析的是否是元类</li><li>如果不是元类，则调用 <code>_class_resolveInstanceMethod</code> 进行对象方法动态解析</li><li>如果是元类，则调用 <code>_class_resolveClassMethod</code> 进行类方法动态解析</li><li>完成类方法动态解析后，再次查询 <code>cls</code> 中的 <code>imp</code>，如果没有找到，则进行一次对象方法动态解析</li></ul><h2 id="1-1-对象方法动态解析"><a href="#1-1-对象方法动态解析" class="headerlink" title="1.1 对象方法动态解析"></a>1.1 对象方法动态解析</h2><p>我们先分析对象方法的动态解析，我们直接来到 <code>_class_resolveInstanceMethod</code> 方法处:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _class_resolveInstanceMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </span><br><span class="line">                         NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的流程如下:</p><ul><li>检查是否实现了 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 类方法，如果没有实现则直接返回(通过 <code>cls-&gt;ISA()</code> 是拿到元类，因为类方法是存储在元类上的对象方法)</li><li>如果当前实现了 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 类方法，则通过 <code>objc_msgSend</code> 手动调用该类方法</li><li>完成调用后，再次查询 <code>cls</code> 中的 <code>imp</code></li><li>如果 <code>imp</code> 找到了，则输出动态解析对象方法成功的日志</li><li>如果 <code>imp</code> 没有找到，则输出虽然实现了 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code>，并且返回了 <code>YES</code>，但并没有查找到 <code>imp</code> 的日志</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119101935.jpg" alt></p><h2 id="类方法动态解析"><a href="#类方法动态解析" class="headerlink" title="类方法动态解析"></a>类方法动态解析</h2><p>接着我们分析类方法动态解析，我们直接来到 <code>_class_resolveClassMethod</code> 方法处:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _class_resolveClassMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    assert(cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(_class_getNonMetaClass(cls, inst), </span><br><span class="line">                        SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveClassMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致的流程如下:</p><ul><li>断言是否是元类，如果不是，直接退出</li><li>检查是否实现了 <code>+(BOOL)resolveClassMethod:(SEL)sel</code> 类方法，如果没有实现则直接返回(通过 <code>cls-</code> 是因为当前 <code>cls</code> 就是元类，因为类方法是存储在元类上的对象方法)</li><li>如果当前实现了 <code>+(BOOL)resolveClassMethod:(SEL)sel</code> 类方法，则通过 <code>objc_msgSend</code> 手动调用该类方法，注意这里和动态解析对象方法不同，这里需要<strong>通过元类和对象来找到类</strong>，也就是 <code>_class_getNonMetaClass</code></li><li>完成调用后，再次查询 <code>cls</code> 中的 <code>imp</code></li><li>如果 <code>imp</code> 找到了，则输出动态解析对象方法成功的日志</li><li>如果 <code>imp</code> 没有找到，则输出虽然实现了 <code>+(BOOL)resolveClassMethod:(SEL)sel</code>，并且返回了 <code>YES</code>，但并没有查找到 <code>imp</code> 的日志</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103157.jpg" alt></p><blockquote><p>这里有一个注意点，如果我们把上面例子中的 <code>objc_getMetaClass(&quot;LGPerson&quot;)</code> 换成 <code>self</code> 试试，会导致 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 方法被调用，其实问题是发生在 <code>class_getMethodImplementation</code> 方法处，其内部会调用到 <code>_class_resolveMethod</code> 方法，而我们的 <code>cls</code> 传的是 <code>self</code>，所以又会走一次 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code><br><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103217.jpg" alt></p></blockquote><h2 id="特殊的-NSObject-对象方法动态解析"><a href="#特殊的-NSObject-对象方法动态解析" class="headerlink" title="特殊的 NSObject 对象方法动态解析"></a>特殊的 <code>NSObject</code> 对象方法动态解析</h2><p>我们再聚焦到 <code>_class_resolveMethod</code> 方法上，如果 <code>cls</code> 是元类，也就是说进行的是类方法动态解析的话，有以下源码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_class_resolveClassMethod(cls, sel, inst); <span class="comment">// 已经处理</span></span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对象方法 决议</span></span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>对于 <code>_class_resolveClassMethod</code> 的执行，肯定是没有问题的，只是为什么在判断如果动态解析失败之后，还要再进行一次对象方法解析呢，这个时候就需要上一张经典的 <code>isa</code> 走位图了:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103234.jpg" alt></p><p>由这个流程图我们可以知道，元类最终继承于<strong>根元类</strong>，而<strong>根元类</strong>又继承于 <code>NSObject</code>，那么也就是说在<strong>根元类</strong>中存储的类方法等价于在 <code>NSObject</code> 中存储的对象方法。而系统在执行 <code>lookUpImpOrNil</code> 时，会递归查找元类的父类的方法列表。但是由于元类和根元类都是系统自动生成的，我们是无法直接编写它们，而对于 <code>NSObject</code>，我们可以借助分类(<code>Category</code>)来实现<strong>统一的类方法动态解析</strong>，不过前提是类本身是没有实现 <code>resolveClassMethod</code> 方法：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103249.jpg" alt></p><p>这也就解释了为什么 <code>_class_resolveClassMethod</code> 为什么会多一步对象方法解析的流程了。</p><h1 id="消息转发快速流程"><a href="#消息转发快速流程" class="headerlink" title="消息转发快速流程"></a>消息转发快速流程</h1><p>如果我们没有进行动态方法解析，消息查找流程接下来会来到的是什么呢?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No implementation found, and method resolver didn't help. </span></span><br><span class="line">    <span class="comment">// Use forwarding.</span></span><br><span class="line"></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br></pre></td></tr></table></figure><p>根据 <code>lookUpImpOrForward</code> 源码我们可以看到当动态解析没有成功后，会直接返回一个 <code>_objc_msgForward_impcache</code>。我们尝试搜索一下它，定位到 <code>objc-msg-arm64.s</code> 汇编源码处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"><span class="comment">// No stret specialization.</span></span><br><span class="line">b__objc_msgForward</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENTRY __objc_msgForward</span><br><span class="line"></span><br><span class="line">adrpx17, __objc_forward_handler@PAGE</span><br><span class="line">ldrp17, [x17, __objc_forward_handler@PAGEOFF]</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward</span><br></pre></td></tr></table></figure><p>可以看到在 <code>__objc_msgForward_impcache</code> 内部会跳转到 <code>__objc_msgForward</code>，而 <code>__objc_msgForward</code> 内部我们并拿不到有用的信息。这个时候是不是线索就断了呢？我们会议一下前面的流程，如果找到了 <code>imp</code>，会进行缓存的填充以及日志的打印，我们不妨找到打印的日志文件看看里面会不会有我们需要的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">log_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_MESSAGE_LOGGING</span></span><br><span class="line">    <span class="keyword">if</span> (objcMsgLogEnabled) &#123;</span><br><span class="line">        <span class="keyword">bool</span> cacheIt = logMessageSend(implementer-&gt;isMetaClass(), </span><br><span class="line">                                      cls-&gt;nameForLogging(),</span><br><span class="line">                                      implementer-&gt;nameForLogging(), </span><br><span class="line">                                      sel);</span><br><span class="line">        <span class="keyword">if</span> (!cacheIt) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    cache_fill (cls, sel, imp, receiver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">logMessageSend</span><span class="params">(<span class="keyword">bool</span> isClassMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">char</span> *objectsClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">char</span> *implementingClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                    SEL selector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>buf[ <span class="number">1024</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create/open the log file</span></span><br><span class="line">    <span class="keyword">if</span> (objcMsgLogFD == (<span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span> (buf, <span class="keyword">sizeof</span>(buf), <span class="string">"/tmp/msgSends-%d"</span>, (<span class="keyword">int</span>) getpid ());</span><br><span class="line">        objcMsgLogFD = secure_open (buf, O_WRONLY | O_CREAT, geteuid());</span><br><span class="line">        <span class="keyword">if</span> (objcMsgLogFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// no log file - disable logging</span></span><br><span class="line">            objcMsgLogEnabled = <span class="literal">false</span>;</span><br><span class="line">            objcMsgLogFD = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make the log entry</span></span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%c %s %s %s\n"</span>,</span><br><span class="line">            isClassMethod ? <span class="string">'+'</span> : <span class="string">'-'</span>,</span><br><span class="line">            objectsClass,</span><br><span class="line">            implementingClass,</span><br><span class="line">            sel_getName(selector));</span><br><span class="line"></span><br><span class="line">    objcMsgLogLock.lock();</span><br><span class="line">    write (objcMsgLogFD, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    objcMsgLogLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell caller to not cache the method</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们很清楚的能看到日志文件的存储位置已经命名方式:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103306.jpg" alt></p><p>这里还有一个注意点:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103315.jpg" alt></p><p>只有当 <code>objcMsgLogEnabled</code> 这个值为 <code>true</code> 的时候才会进行日志的输出，我们直接搜索这个值出现过的地方:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103334.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103342.jpg" alt></p><p>很明显，通过调用 <code>instrumentObjcMessageSends</code> 可以来实现打印的开与关。我们可以简单测试一下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103350.jpg" alt></p><p>我们运行一下，然后来到 <code>/private/tmp</code> 目录下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103358.jpg" alt></p><p>我们打开这个文件:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103410.jpg" alt></p><p>我们看到了熟悉的 <code>resolveInstanceMethod</code>，但是在这之后有 2 个之前我们没探索过的方法: <code>forwardingTargetForSelector</code> 和 <code>methodSignatureForSelector</code>。然后会有 <code>doesNotRecognizeSelector</code> 方法的打印，此时 <code>Xcode</code> 控制台打印如下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103417.jpg" alt></p><p>我们可以看到 <code>___forwarding___</code> 发生在 <code>CoreFoundation</code> 框架里面。我们还是老规矩，<strong>以官方文档为准</strong>，查询一下 <code>forwardingTargetForSelector</code> 和 <code>methodSignatureForSelector</code>。</p><p>先是 <code>forwardingTargetForSelector</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103427.jpg" alt></p><p><code>forwardingTargetForSelector</code> 的官方定义是返回未找到 <code>IMP</code> 的消息首先定向到的对象，说人话就是在这个方法可以实现<strong>狸猫换太子</strong>，不是找不到 <code>IMP</code> 吗，我把这个消息交给其他的对象来处理不就完事了吗？我们直接用代码说话:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s -- %@"</span>,__func__,<span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(saySomething)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [LGTeacher alloc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们直接返回 <code>[LGTeacher alloc]</code>，我们运行试试看:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103436.jpg" alt></p><p>完美~，我们对 <code>LGStudent</code> 实例对象发送 <code>saySomething</code> 消息，结果最后是由 <code>LGTeacher</code> 响应了这个消息。关于 <code>forwardingTargetForSelector</code> ，苹果还给出了几点提示:</p><blockquote><p>If an object implements (or inherits) this method, and returns a non-nil (and non-self) result, that returned object is used as the new receiver object and the message dispatch resumes to that new object. (Obviously if you return self from this method, the code would just fall into an infinite loop.)<br>译: 如果一个对象实现或继承了该方法，然后返回一个非空(非 <code>self</code>)的结果，那么这个返回值会被当做新的消息接受者对象，消息会被转发到该对象身上。(如果你在这个方法里返回 <code>self</code>，那么显然就会发生一个<strong>死循环</strong>)。</p></blockquote><blockquote><p>If you implement this method in a non-root class, if your class has nothing to return for the given selector then you should return the result of invoking super’s implementation.<br>译: 如果你在一个非基类中实现了该方法，并且这个类没有任何可以返回的内容，那么你需要返回父类的实现。也就是 <code>return [super forwardingTargetForSelector:aSelector];</code>。</p></blockquote><blockquote><p>This method gives an object a chance to redirect an unknown message sent to it before the much more expensive forwardInvocation: machinery takes over. This is useful when you simply want to redirect messages to another object and can be an order of magnitude faster than regular forwarding. It is not useful where the goal of the forwarding is to capture the NSInvocation, or manipulate the arguments or return value during the forwarding.<br>译: 这个方法使对象有机会在更昂贵的 <code>forwardInvocation：</code> 机械接管之前重定向发送给它的未知消息。当你只想将消息重定向到另一个对象，并且比常规转发快一个数量级时，这个方法就很有用。在转发的目标是捕获 <code>NSInvocation</code> 或在转发过程中操纵参数或返回值的情况下，此功能就无用了。</p></blockquote><p>通过上面的官方文档定义，我们可以理清下思路：</p><ul><li><code>forwardingTargetForSelector</code> 是一种快速的消息转发流程，它直接让其他对象来响应未知的消息。</li><li><code>forwardingTargetForSelector</code> 不能返回 <code>self</code>，否则会陷入死循环，因为返回 <code>self</code> 又回去当前实例对象身上走一遍消息查找流程，显然又会来到 <code>forwardingTargetForSelector</code>。</li><li><code>forwardingTargetForSelector</code> 适用于消息转发给其他能响应未知消息的对象，什么意思呢，就是最终返回的内容必须和要查找的消息的参数和返回值一致，如果想要不一致，就需要走其他的流程。</li></ul><h1 id="消息转发慢速流程"><a href="#消息转发慢速流程" class="headerlink" title="消息转发慢速流程"></a>消息转发慢速流程</h1><p>上面说到如果想要最终返回的内容必须和要查找的消息的参数和返回值不一致，需要走其他流程，那么到底是什么流程呢，我们接着看一下刚才另外一个方法 <code>methodSignatureForSelector</code> 的官方文档:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103449.jpg" alt></p><p>官方的定义是 <code>methodSignatureForSelector</code> 返回一个 <code>NSMethodSignature</code> 方法签名对象，这个该对象包含由给定选择器标识的方法的描述。</p><blockquote><p>This method is used in the implementation of protocols. This method is also used in situations where an NSInvocation object must be created, such as during message forwarding. If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature.<br>译: 这个方法用于协议的实现。同时在消息转发的时候，在必须创建 <code>NSInvocation</code> 对象的情况下，也会用到这个方法。如果您的对象维护一个委托或能够处理它不直接实现的消息，则应重写此方法以返回适当的方法签名。</p></blockquote><p>我们在文档的最后可以看到有一个叫 <code>forwardInvocation:</code> 的方法</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103456.jpg" alt></p><p>我们来到该方法的文档处：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103511.jpg" alt></p><blockquote><p>To respond to methods that your object does not itself recognize, you must override methodSignatureForSelector: in addition to forwardInvocation:. The mechanism for forwarding messages uses information obtained from methodSignatureForSelector: to create the NSInvocation object to be forwarded. Your overriding method must provide an appropriate method signature for the given selector, either by pre formulating one or by asking another object for one.<br>译：要响应对象本身无法识别的方法，除了 <code>forwardInvocation：</code>外，还必须重写<code>methodSignatureForSelector:</code> 。 转发消息的机制使用从<code>methodSignatureForSelector：</code>获得的信息来创建要转发的 <code>NSInvocation</code> 对象。 你的重写方法必须为给定的选择器提供适当的方法签名，方法是预先制定一个公式，也可以要求另一个对象提供一个方法签名。</p></blockquote><p>显然，<code>methodSignatureForSelector</code> 和 <code>forwardInvocation</code> 不是孤立存在的，需要一起出现。我们直接上代码说话:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s -- %@"</span>,__func__,<span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(saySomething)) &#123; <span class="comment">// v @ :</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"v@:"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s "</span>,__func__);</span><br><span class="line"></span><br><span class="line">   SEL aSelector = [anInvocation selector];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ([[LGTeacher alloc] respondsToSelector:aSelector])</span><br><span class="line">       [anInvocation invokeWithTarget:[LGTeacher alloc]];</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后查看打印结果：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103526.jpg" alt></p><p>可以看到，先是来到了 <code>methodSignatureForSelector</code>，然后来到了 <code>forwardInvocation</code>，最后 <code>saySomething</code> 消息被查找到了。</p><p>关于 <code>forwardInvocation</code>，还有几个注意点：</p><ul><li><code>forwardInvocation</code> 方法有两个任务:<ul><li>查找可以响应 <code>inInvocation</code> 中编码的消息的对象。对于所有消息，此对象不必相同。</li><li>使用 <code>anInvocation</code> 将消息发送到该对象。<code>anInvocation</code> 将保存结果，运行时系统将提取结果并将其传递给原始发送者。</li></ul></li><li><code>forwardInvocation</code> 方法的实现不仅仅可以转发消息。<code>forwardInvocation</code>还可以，例如，可以用于合并响应各种不同消息的代码，从而避免了必须为每个选择器编写单独方法的麻烦。<code>forwardInvocation</code> 方法在对给定消息的响应中还可能涉及其他几个对象，而不是仅将其转发给一个对象。</li><li><code>NSObject</code> 的 <code>forwardInvocation</code> 实现：只会调用 <code>dosNotRecognizeSelector：方法，它不会转发任何消息。因此，如果选择不实现</code>forwardInvocation`，将无法识别的消息发送给对象将引发异常。</li></ul><p>至此，消息转发的慢速流程我们就探索完了。</p><h1 id="四、消息转发流程图"><a href="#四、消息转发流程图" class="headerlink" title="四、消息转发流程图"></a>四、消息转发流程图</h1><p>我们从动态消息解析到快速转发流程再到慢速转发流程可以总结出如下的流程图：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119103534.jpg" alt></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>我们从 <code>objc_msgSend</code> 开始，探索了消息发送之后是怎么样的一个流程，这对于我们理解 <code>iOS</code> 底层有很大的帮助。当然，限于笔者的水平，探索的过程可能会有一定的瑕疵。我们简单总结一下：</p><ul><li>动态方法解析分为<strong>对象方法动态解析</strong>和<strong>类方法动态解析</strong><ul><li><strong>对象方法动态解析</strong>需要消息发送者实现 <code>+(BOOL)resolveInstanceMethod:(SEL)sel</code> 方法</li><li><strong>类方法动态解析</strong>需要消息发送者实现 <code>+(BOOL)resolveClassMethod:(SEL)sel</code> 方法</li></ul></li><li>动态方法解析失败会进入消息转发流程</li></ul><ul><li>消息转发分为两个流程：快速转发和慢速转发</li><li>快速转发的实现是 <code>forwardingTargetForSelector</code>，让其他能响应要查找消息的对象来干活</li><li>慢速转发的实现是 <code>methodSignatureForSelector</code> 和 <code>forwardInvocation</code> 的结合，提供了更细粒度的控制，先返回方法签名给 <code>Runtime</code>，然后让 <code>anInvocation</code> 来把消息发送给提供的对象，最后由 <code>Runtime</code> 提取结果然后传递给原始的消息发送者。</li></ul><p><code>iOS</code> 底层探索已经来到了第七篇，我们接下来将会从 <code>app</code> 加载开始探索，探究 <code>冷启动</code> 和 <code>热启动</code>，以及 <code>dyld</code> 是如何工作的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态方法解析流程分析&quot;&gt;&lt;a href=&quot;#动态方法解析流程分析&quot; class=&quot;headerlink&quot; title=&quot;动态方法解析流程分析&quot;&gt;&lt;/a&gt;动态方法解析流程分析&lt;/h1&gt;&lt;p&gt;我们在上一章《消息查找》分析到了&lt;strong&gt;动态方法解析&lt;/strong&gt;，为了更好的掌握具体的流程，我们接下来直接进行源码追踪。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - 消息查找</title>
    <link href="http://leejunhui.com/2020/01/07/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E6%B6%88%E6%81%AF%E6%9F%A5%E6%89%BE/"/>
    <id>http://leejunhui.com/2020/01/07/iOS-底层探索-消息查找/</id>
    <published>2020-01-07T03:06:03.000Z</published>
    <updated>2020-01-19T02:12:59.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="objc-msgSend-汇编补充"><a href="#objc-msgSend-汇编补充" class="headerlink" title="objc_msgSend 汇编补充"></a><code>objc_msgSend</code> 汇编补充</h1><p>我们知道，之所以使用汇编来实现 <code>objc_msgSend</code> 有两个原因:</p><ul><li>因为 C 无法通过写一个函数来保留未知的参数并且跳转到一个任意的函数指针。</li><li><code>objc_msgSend</code> 必须足够快。</li></ul><a id="more"></a><h2 id="objc-msgSend-流程"><a href="#objc-msgSend-流程" class="headerlink" title="objc_msgSend 流程"></a><code>objc_msgSend</code> 流程</h2><ul><li>ENTRY _objc_msgSend</li><li>对消息接收者进行判断、处理 (id self, sel _cmd)</li><li>taggedPointer 判断处理</li><li><code>GetClassFromIsa_p16</code> isa 指针处理拿到 class</li><li>CacheLookup 查找缓存</li><li><code>cache_t</code> 处理 <code>bucket</code> 以及内存哈希处理<ul><li>找不到递归下一个 <code>bucket</code></li><li>找到了就返回 <code>{imp, sel} = *bucket-&gt;imp</code>\</li><li>遇到意外就重试</li><li>找不到就跳到 <code>junpMiss</code></li></ul></li><li><code>__objc_msgSend_uncached</code> 找不到缓存 <code>imp</code></li><li><code>STATIC ENTRY __objc_msgSend_uncached</code></li><li><code>MethodTableLookup</code> 方法表查找<ul><li><code>save parameters registers</code></li><li><code>self</code> 以及 <code>_cmd</code> 准备</li><li><code>_class_lookupMethodAndLoadCache3</code> 调用</li></ul></li></ul><h1 id="通过汇编找到下一流程"><a href="#通过汇编找到下一流程" class="headerlink" title="通过汇编找到下一流程"></a>通过汇编找到下一流程</h1><p>我们在探索 <code>objc_msgSend</code> 的时候，当找不到缓存的时候，会来到一个地方叫做 <code>objc_msgSend_uncached</code>，然后会来到 <code>MethodTableLookup</code>，然后会有一个核心的查找方法 <code>__class_lookupMethodAndLoadCache3</code>。但是我们知道其实已经要进入 C/C++ 的流程了，所以我们还可以汇编来定位。<br>我们打开 <code>Always Show Disassembly</code>选项</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119100507.jpg" alt></p><p>然后我们进入 <code>objc_msgSend</code> 内部</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119100515.jpg" alt></p><p>然后我们进入 <code>_objc_msgSend_uncached</code> 的内部</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119100525.jpg" alt></p><p>我们会来到 <code>_class_lookupMethodAndLoadCache3</code>，这就是真正的方法查找实现。</p><h1 id="代码分析方法查找流程"><a href="#代码分析方法查找流程" class="headerlink" title="代码分析方法查找流程"></a>代码分析方法查找流程</h1><h2 id="对象方法测试"><a href="#对象方法测试" class="headerlink" title="对象方法测试"></a>对象方法测试</h2><ul><li>对象的实例方法 - 自己有</li><li>对象的实例方法 - 自己没有 - 找父类的</li><li>对象的实例方法 - 自己没有 - 父类也没有 - 找父类的父类 - NSObject</li><li>对象的实例方法 - 自己没有 - 父类也没有 - 找父类的父类 - NSObject也没有 - 崩溃</li></ul><h2 id="3-2-类方法测试"><a href="#3-2-类方法测试" class="headerlink" title="3.2 类方法测试"></a>3.2 类方法测试</h2><ul><li>类方法 - 自己有</li><li>类方法 - 自己没有 - 找父类的</li><li>类方法 - 自己没有 - 父类也没有 - 找父类的父类 - NSObject</li><li>类方法 - 自己没有 - 父类也没有 - 找父类的父类 - NSObject也没有 - 崩溃</li><li>类方法 - 自己没有 - 父类也没有 - 找父类的父类 - NSObject也没有 - 但是有对象方法</li></ul><h1 id="源码分析方法查找流程"><a href="#源码分析方法查找流程" class="headerlink" title="源码分析方法查找流程"></a>源码分析方法查找流程</h1><p>我们直接定位到 <code>_class_lookupMethodAndLoadCache3</code> 源码处:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              YES<span class="comment">/*initialize*/</span>, NO<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们进入 <code>lookUpImpOrForward</code>，这里注意一下， <code>cache</code> 是传的 <code>NO</code>，因为来到这里已经说明缓存不存在，所以需要进行方法查找。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119100821.jpg" alt></p><h2 id="lookUpImpOrForward"><a href="#lookUpImpOrForward" class="headerlink" title="lookUpImpOrForward"></a>lookUpImpOrForward</h2><p>我们接着定位到 <code>lookUpImpOrForward</code> 的源码处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br></pre></td></tr></table></figure><p>由该方法的参数我们可以知道，<code>lookUpImpOrForward</code> 应该是个公共方法，<code>initialize</code> 和 <code>cache</code> 分别代表是否避免 <code>+initialize</code> 和是否从缓存中查找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>如果 <code>cache</code> 为 <code>YES</code>，那么就直接调用 <code>cache_getImp</code> 来从 <code>cls</code> 的缓存中获取 <code>sel</code> 对应的 <code>IMP</code>，如果找到了就返回。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>判断当前要查找的 <code>cls</code> 是否已经完成了准备工作，如果没有，则需要进行一下类的 <code>realize</code>。</li></ul><h2 id="从当前类上查找"><a href="#从当前类上查找" class="headerlink" title="从当前类上查找"></a>从当前类上查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try this class's method lists.</span></span><br><span class="line">    &#123;</span><br><span class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>上面的方法很显然，是从类的方法列表中查找 <code>IMP</code>。这里加两个大括号的目的是形成<strong>局部作用域</strong>，让命名不会不想冲突。通过 <code>getMethodNoSuper_nolock</code> 查找 <code>Method</code>，找到了之后就调用 <code>log_and_fill_cache</code> 进行缓存的填充，然后返回 <code>imp</code>。</li></ul><h3 id="getMethodNoSuper-nolock"><a href="#getMethodNoSuper-nolock" class="headerlink" title="getMethodNoSuper_nolock"></a>getMethodNoSuper_nolock</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">method_t</span> *</span><br><span class="line">getMethodNoSuper_nolock(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line">    <span class="comment">// fixme nil cls? </span></span><br><span class="line">    <span class="comment">// fixme nil sel?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> mlists = cls-&gt;data()-&gt;methods.beginLists(), </span><br><span class="line">              end = cls-&gt;data()-&gt;methods.endLists(); </span><br><span class="line">         mlists != end;</span><br><span class="line">         ++mlists)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">method_t</span> *m = search_method_list(*mlists, sel);</span><br><span class="line">        <span class="keyword">if</span> (m) <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> method_t *<span class="title">search_method_list</span><span class="params">(<span class="keyword">const</span> <span class="keyword">method_list_t</span> *mlist, SEL sel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> methodListIsFixedUp = mlist-&gt;isFixedUp();</span><br><span class="line">    <span class="keyword">int</span> methodListHasExpectedSize = mlist-&gt;entsize() == <span class="keyword">sizeof</span>(<span class="keyword">method_t</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> findMethodInSortedMethodList(sel, mlist);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Linear search of unsorted method list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name == sel) <span class="keyword">return</span> &amp;meth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="comment">// sanity-check negative results</span></span><br><span class="line">    <span class="keyword">if</span> (mlist-&gt;isFixedUp()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (meth.name == sel) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"linear search worked when binary search did not"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getMethodNoSuper_nolock</code> 实现很简单，就是从 <code>cls</code> 的 <code>data()</code> 中进行遍历，然后对遍历到的 <code>method_list_t</code> 结构体指针再次调用 <code>search_method_list</code> 与 <code>sel</code> 进行匹配。这里的 <code>findMethodInSortedMethodList</code> 我们再接着往下探索。</p><h3 id="findMethodInSortedMethodList"><a href="#findMethodInSortedMethodList" class="headerlink" title="findMethodInSortedMethodList"></a>findMethodInSortedMethodList</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> method_t *<span class="title">findMethodInSortedMethodList</span><span class="params">(SEL key, <span class="keyword">const</span> <span class="keyword">method_list_t</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_t</span> * <span class="keyword">const</span> first = &amp;<span class="built_in">list</span>-&gt;first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_t</span> *base = first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_t</span> *probe;</span><br><span class="line">    <span class="keyword">uintptr_t</span> keyValue = (<span class="keyword">uintptr_t</span>)key;</span><br><span class="line">    <span class="keyword">uint32_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (count = <span class="built_in">list</span>-&gt;count; count != <span class="number">0</span>; count &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        probe = base + (count &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">uintptr_t</span> probeValue = (<span class="keyword">uintptr_t</span>)probe-&gt;name;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (keyValue == probeValue) &#123;</span><br><span class="line">            <span class="comment">// `probe` is a match.</span></span><br><span class="line">            <span class="comment">// Rewind looking for the *first* occurrence of this value.</span></span><br><span class="line">            <span class="comment">// This is required for correct category overrides.</span></span><br><span class="line">            <span class="keyword">while</span> (probe &gt; first &amp;&amp; keyValue == (<span class="keyword">uintptr_t</span>)probe[<span class="number">-1</span>].name) &#123;</span><br><span class="line">                probe--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">method_t</span> *)probe;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (keyValue &gt; probeValue) &#123;</span><br><span class="line">            base = probe + <span class="number">1</span>;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>findMethodInSortedMethodList</code> 的核心逻辑是<strong>二分查找</strong>，这种算法的前提是<strong>有序</strong>的集合。</p><h2 id="从父类中查找"><a href="#从父类中查找" class="headerlink" title="从父类中查找"></a>从父类中查找</h2><p>源码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try superclass caches and method lists.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> attempts = unreasonableClassCount();</span><br><span class="line">        <span class="keyword">for</span> (Class curClass = cls-&gt;superclass;</span><br><span class="line">             curClass != nil;</span><br><span class="line">             curClass = curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">            <span class="keyword">if</span> (--attempts == <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Memory corruption in class list."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass cache.</span></span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    <span class="keyword">goto</span> done;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">                    <span class="comment">// Stop searching, but don't cache yet; call method </span></span><br><span class="line">                    <span class="comment">// resolver for this class first.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass method list.</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp = meth-&gt;imp;</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Superclass cache.</span></span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br></pre></td></tr></table></figure><ul><li>在父类中查找的时候，和在当前类查找有一点不同的是需要检查缓存。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    <span class="keyword">goto</span> done;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">                    <span class="comment">// Stop searching, but don't cache yet; call method </span></span><br><span class="line">                    <span class="comment">// resolver for this class first.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><ul><li>如果在父类中找到了 <code>IMP</code>，同时判断是否是消息转发的入口，如果不是消息转发，那么就把找到的 <code>IMP</code> 通过 <code>log_and_fill_cache</code> 缓存到当前类的缓存中；如果是消息转发，就退出循环。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Superclass method list.</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp = meth-&gt;imp;</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>如果父类缓存中没有找到，那么就查找父类的方法列表，这里和上面在当前类中的方法列表中查找是异曲同工之妙，就不再赘述了。</li></ul><h2 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlock();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.lock();</span><br><span class="line">        <span class="comment">// Don't cache the result; we don't hold the lock so it may have </span></span><br><span class="line">        <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">        triedResolver = YES;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果在类和父类中都没有找到，<code>Runtime</code> 给了我们一个机会来进行<strong>动态方法解析</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _class_resolveMethod</span></span><br><span class="line"><span class="comment">* Call +resolveClassMethod or +resolveInstanceMethod.</span></span><br><span class="line"><span class="comment">* Returns nothing; any result would be potentially out-of-date already.</span></span><br><span class="line"><span class="comment">* Does not check if the method already exists.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line"></span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来分析一下 <code>_class_resolveMethod</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line"></span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>判断当前类是否是元类，如果不是的话，调用 <code>_class_resolveInstanceMethod</code>。</li><li>如果是元类的话，说明要查找的是类方法，调用 <code>_class_resolveClassMethod</code>。</li></ul><h3 id="class-resolveInstanceMethod"><a href="#class-resolveInstanceMethod" class="headerlink" title="_class_resolveInstanceMethod"></a>_class_resolveInstanceMethod</h3><p>首先我们分析动态解析对象方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _class_resolveInstanceMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </span><br><span class="line">                         NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">IMP <span class="title">lookUpImpOrNil</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);</span><br><span class="line">    <span class="keyword">if</span> (imp == _objc_msgForward_impcache) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还有一个注意点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br></pre></td></tr></table></figure><p>对当前 <code>cls</code> 发送 <code>SEL_resolveInstanceMethod</code> 消息，如果返回的是 <code>YES</code>，那说明当前类是实现了动态方法解析。</p><p>由上面的代码可知动态方法解析到最后会回到 <code>lookUpImpOrForward</code>。注意这里的传参:<br><code>cache</code> 是 <code>YES</code>，<code>resolver</code> 是 <code>NO</code>，什么意思呢?</p><blockquote><p>Cache the result (good or bad) so the resolver doesn’t fire next time.<br>缓存查找的结果，所以解析器下一次就不会被触发，其实本质上就是<strong>打破递归</strong>。</p></blockquote><h3 id="class-resolveClassMethod"><a href="#class-resolveClassMethod" class="headerlink" title="_class_resolveClassMethod"></a>_class_resolveClassMethod</h3><p>我们接着分析动态解析类方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _class_resolveClassMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    assert(cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(_class_getNonMetaClass(cls, inst), </span><br><span class="line">                        SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn't fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: method %c[%s %s] "</span></span><br><span class="line">                         <span class="string">"dynamically resolved to %p"</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn't add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">"RESOLVE: +[%s resolveClassMethod:%s] returned YES"</span></span><br><span class="line">                         <span class="string">", but no new implementation of %c[%s %s] was found"</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个注意点：传进来的 <code>cls</code> 必须是<strong>元类</strong>，因为类方法存在元类的缓存或方法列表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象方法动态解析</span></span><br><span class="line"><span class="keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法动态解析</span></span><br><span class="line"><span class="keyword">bool</span> resolved = msg(_class_getNonMetaClass(cls, inst), </span><br><span class="line">                        SEL_resolveClassMethod, sel);</span><br></pre></td></tr></table></figure><p>这里 <code>msg</code> 方法的第一个参数就明显不同，解析对象方法的时候传的是当前类，而解析类方法的时候传的是 <code>_class_getNonMetaClass(cls, inst)</code> 的结果。我们进入 <code>_class_getNonMetaClass</code> 内部:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class _class_getNonMetaClass(Class cls, id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock(runtimeLock);</span><br><span class="line">    cls = getNonMetaClass(cls, obj);</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着进入 <code>getNonMetaClass</code>，这个方法的目的就是<strong>通过元类获取类</strong>，我们去除一些干扰信息:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">getNonMetaClass</span><span class="params">(Class metacls, id inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total, named, secondary, sharedcache;</span><br><span class="line">    realizeClass(metacls);</span><br><span class="line"></span><br><span class="line">    total++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经不是元类的，那就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!metacls-&gt;isMetaClass()) <span class="keyword">return</span> metacls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// metacls really is a metaclass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根元类的特殊情况，这里回忆一下，根元类的isa指向的是自己</span></span><br><span class="line">    <span class="comment">// where inst == inst-&gt;ISA() == metacls is possible</span></span><br><span class="line">    <span class="keyword">if</span> (metacls-&gt;ISA() == metacls) &#123;</span><br><span class="line">        Class cls = metacls-&gt;superclass;</span><br><span class="line">        assert(cls-&gt;isRealized());</span><br><span class="line">        assert(!cls-&gt;isMetaClass());</span><br><span class="line">        assert(cls-&gt;ISA() == metacls);</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;ISA() == metacls) <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果实例不为空</span></span><br><span class="line">    <span class="keyword">if</span> (inst) &#123;</span><br><span class="line">        Class cls = (Class)inst;</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        <span class="comment">// cls 可能是一个子类，这里通过实例获取到类对象，</span></span><br><span class="line">        <span class="comment">// 然后通过一个 while 循环来遍历判断类对象的 isa 是否是元类</span></span><br><span class="line">        <span class="comment">// 如果是元类的话，就跳出循环；如果不是接着获取类对象的父类</span></span><br><span class="line">        <span class="comment">// cls may be a subclass - find the real class for metacls</span></span><br><span class="line">        <span class="keyword">while</span> (cls  &amp;&amp;  cls-&gt;ISA() != metacls) &#123;</span><br><span class="line">            cls = cls-&gt;superclass;</span><br><span class="line">            realizeClass(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明已经找到了当前元类所匹配的类</span></span><br><span class="line">        <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">            assert(!cls-&gt;isMetaClass());</span><br><span class="line">            assert(cls-&gt;ISA() == metacls);</span><br><span class="line">            <span class="keyword">return</span> cls;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">        _objc_fatal(<span class="string">"cls is not an instance of metacls"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">// release build: be forgiving and fall through to slow lookups</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试命名查询</span></span><br><span class="line">    &#123;</span><br><span class="line">        Class cls = getClass(metacls-&gt;mangledName());</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;ISA() == metacls) &#123;</span><br><span class="line">            named++;</span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"INITIALIZE: %d/%d (%g%%) "</span></span><br><span class="line">                             <span class="string">"successful by-name metaclass lookups"</span>,</span><br><span class="line">                             named, total, named*<span class="number">100.0</span>/total);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            realizeClass(cls);</span><br><span class="line">            <span class="keyword">return</span> cls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试 NXMapGet</span></span><br><span class="line">    &#123;</span><br><span class="line">        Class cls = (Class)NXMapGet(nonMetaClasses(), metacls);</span><br><span class="line">        <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">            secondary++;</span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"INITIALIZE: %d/%d (%g%%) "</span></span><br><span class="line">                             <span class="string">"successful secondary metaclass lookups"</span>,</span><br><span class="line">                             secondary, total, secondary*<span class="number">100.0</span>/total);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            assert(cls-&gt;ISA() == metacls);            </span><br><span class="line">            realizeClass(cls);</span><br><span class="line">            <span class="keyword">return</span> cls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try any duplicates in the dyld shared cache</span></span><br><span class="line">    <span class="comment">// 尝试从 dyld 动态共享缓存库中查询</span></span><br><span class="line">    &#123;</span><br><span class="line">        Class cls = nil;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        Class *classes = copyPreoptimizedClasses(metacls-&gt;mangledName(),&amp;count);</span><br><span class="line">        <span class="keyword">if</span> (classes) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (classes[i]-&gt;ISA() == metacls) &#123;</span><br><span class="line">                    cls = classes[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(classes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">            sharedcache++;</span><br><span class="line">            <span class="keyword">if</span> (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(<span class="string">"INITIALIZE: %d/%d (%g%%) "</span></span><br><span class="line">                             <span class="string">"successful shared cache metaclass lookups"</span>,</span><br><span class="line">                             sharedcache, total, sharedcache*<span class="number">100.0</span>/total);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            realizeClass(cls);</span><br><span class="line">            <span class="keyword">return</span> cls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _objc_fatal(<span class="string">"no class for metaclass %p"</span>, (<span class="keyword">void</span>*)metacls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No implementation found, and method resolver didn't help. </span></span><br><span class="line">    <span class="comment">// Use forwarding.</span></span><br><span class="line"></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br></pre></td></tr></table></figure><p>如果<strong>动态消息解析</strong>仍然失败，那么就会来到消息查找的最后一步了，<strong>消息转发</strong>。</p><p>此时会返回一个类型为 <code>_objc_msgForward_impcache</code> 的 <code>IMP</code>，然后填充到 <code>cls</code> 中的 <code>cache_t</code> 里面。至此，我们的消息查找流程就此结束了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>方法查找或者说消息查找，起始于 <code>_class_lookupMethodAndLoadCache3</code>。</li><li><code>_class_lookupMethodAndLoadCache3</code> 的核心实现是 <code>lookUpImpOrForward</code>。</li><li>从 <code>_class_lookupMethodAndLoadCache3</code> 进入的话，是忽略缓存直接从方法列表中查找。</li><li>查找之前会确保类已经完成诸如 属性、方法、协议等内容的 <code>attach</code>。</li><li>先从当前类的方法列表中查找，找到了返回，找不到交给父类。</li><li>先从父类的缓存中查找，如果找到返回，如果没有查找方法列表，找到了返回，找不到进行<strong>动态方法解析</strong>。</li><li>根据当前是类还是元类来进行<strong>对象方法动态解析</strong>和<strong>类方法动态解析</strong>。</li><li>如果解析成功，则返回，如果失败，进入消息转发流程。</li></ul><p>我们今天一起探索了消息查找的底层，下一章我们将会沿着今天的方向再往下探索方法转发的流程。敬请期待~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;objc-msgSend-汇编补充&quot;&gt;&lt;a href=&quot;#objc-msgSend-汇编补充&quot; class=&quot;headerlink&quot; title=&quot;objc_msgSend 汇编补充&quot;&gt;&lt;/a&gt;&lt;code&gt;objc_msgSend&lt;/code&gt; 汇编补充&lt;/h1&gt;&lt;p&gt;我们知道，之所以使用汇编来实现 &lt;code&gt;objc_msgSend&lt;/code&gt; 有两个原因:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为 C 无法通过写一个函数来保留未知的参数并且跳转到一个任意的函数指针。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;objc_msgSend&lt;/code&gt; 必须足够快。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - 方法</title>
    <link href="http://leejunhui.com/2020/01/07/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E6%96%B9%E6%B3%95/"/>
    <id>http://leejunhui.com/2020/01/07/iOS-底层探索-方法/</id>
    <published>2020-01-07T02:48:15.000Z</published>
    <updated>2020-01-19T01:59:16.557Z</updated>
    
    <content type="html"><![CDATA[<p>我们在前面探索了对象和类的底层原理，接下来我们要探索一下方法的本质，而在探索之前，我们先简单过一遍 <code>Runtime</code> 的知识点，如果读者对这块内容已经很熟悉了的话可以直接跳过第一章。</p><a id="more"></a><blockquote><p>PS: 由于笔者对汇编暂时还是摸索的阶段，关于汇编源码的部分如有错误，欢迎指正。</p></blockquote><h1 id="Runtime-简介"><a href="#Runtime-简介" class="headerlink" title="Runtime 简介"></a><code>Runtime</code> 简介</h1><p>众所周知，<code>Objective-C</code> 是一门动态语言，而承载整个 <code>OC</code> 动态特性的就是 <code>Runtime</code>。关于 <code>Runtime</code> 更多内容可以直接进入<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">官网文档</a>查看。</p><p><code>Runtime</code> 是以 <code>C</code>/<code>C++</code>和汇编编写而成的，为什么不用 <code>OC</code> 呢，这是因为对我们编译器来说，<code>OC</code> 属于更高级的语言，相比于 <code>C</code> 和 <code>C++</code> 以及汇编，执行效率更慢，而在运行时系统需要尽可能快的执行效率。</p><h2 id="Runtime-的前世今生"><a href="#Runtime-的前世今生" class="headerlink" title="Runtime 的前世今生"></a><code>Runtime</code> 的前世今生</h2><p><code>Runtime</code> 分为两个版本，<code>legacy</code> 和 <code>modern</code>，分别对标 <code>OC 1.0</code> 和 <code>OC 2.0</code>。我们通常只需要专注于 <code>modern</code> 版本即可，在 <code>libObjc</code> 源码中体现在 <code>new</code> 后缀的文件上。</p><h2 id="Runtime-三种交互方式"><a href="#Runtime-三种交互方式" class="headerlink" title="Runtime 三种交互方式"></a><code>Runtime</code> 三种交互方式</h2><p>我们与 <code>Runtime</code> 打交道有三种方式:</p><ul><li>直接在 <code>OC</code> 层进行交互：比如 <code>@selector</code></li><li><code>NSObject</code> 的方法：<code>NSSelectorFromName</code></li><li><code>Runtime</code> 的函数： <code>sel_registerName</code></li></ul><h1 id="方法的本质探索"><a href="#方法的本质探索" class="headerlink" title="方法的本质探索"></a>方法的本质探索</h1><h2 id="方法初探"><a href="#方法初探" class="headerlink" title="方法初探"></a>方法初探</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119095137.jpg" alt></p><p>我们可以看到，通过 <code>clang</code> 重写之后，<code>sayNB</code> 在底层其实是一个消息的发送。</p><p>我们把右侧的发送消息的代码简化一下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LGPerson *person = objc_msgSend((id)objc_getClass(<span class="string">"LGPerson"</span>), sel_registerName(<span class="string">"alloc"</span>));</span><br><span class="line">objc_msgSend((id)person, sel_registerName(<span class="string">"sayNB"</span>));</span><br></pre></td></tr></table></figure><p>由此可见，真正发送消息的地方是 <code>objc_msgSend</code>，这个方法有两个参数，一个是消息的接受者为 <code>id</code> 类型，第二个个是方法编号 <code>sel</code>。</p><p>作为对比，<code>run</code> 方法就直接执行了，并没有通过 <code>objc_msgSend</code> 进行消息发送:</p><h2 id="方法发送的几种情况"><a href="#方法发送的几种情况" class="headerlink" title="方法发送的几种情况"></a>方法发送的几种情况</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LGStudent *s = [LGStudent new];</span><br><span class="line">[s sayCode];        </span><br><span class="line"></span><br><span class="line">objc_msgSend(s, sel_registerName(<span class="string">"sayCode"</span>));</span><br></pre></td></tr></table></figure><p>上述代码表示的是向对象 <code>s</code> 发送 <code>sayCode</code> 消息。</p><hr><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> cls = [LGStudent <span class="keyword">class</span>];</span><br><span class="line"><span class="keyword">void</span> *pointA = &amp;cls;</span><br><span class="line">[(__bridge <span class="keyword">id</span>)pointA sayNB];</span><br><span class="line"></span><br><span class="line">objc_msgSend(objc_getClass(<span class="string">"LGStudent"</span>), sel_registerName(<span class="string">"sayNB"</span>));</span><br></pre></td></tr></table></figure><p>上述代码表示向 <code>LGStudent</code> 这个类发送 <code>sayNB</code> 消息。</p><hr><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向父类发消息(对象方法)</span></span><br><span class="line"><span class="keyword">struct</span> objc_super lgSuper;</span><br><span class="line">lgSuper.receiver = s;</span><br><span class="line">lgSuper.super_class = [LGPerson <span class="keyword">class</span>];</span><br><span class="line">objc_msgSendSuper(&amp;lgSuper, <span class="keyword">@selector</span>(sayHello));</span><br></pre></td></tr></table></figure><p>上述代码表示向父类发送 <code>sayHello</code> 消息。</p><hr><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向父类发消息(类方法)</span></span><br><span class="line"><span class="keyword">struct</span> objc_super myClassSuper;</span><br><span class="line">myClassSuper.receiver = [s <span class="keyword">class</span>];</span><br><span class="line">myClassSuper.super_class = class_getSuperclass(object_getClass([s <span class="keyword">class</span>]));<span class="comment">// 元类</span></span><br><span class="line">objc_msgSendSuper(&amp;myClassSuper, sel_registerName(<span class="string">"sayNB"</span>));</span><br></pre></td></tr></table></figure><p>上述代码表示向父类的类，也就是<strong>元类</strong>发送 <code>sayNB</code> 消息。</p><p>我们在 <code>OC</code> 中使用 <code>objc_msgSend</code> 的时候，要注意需要将 <code>Enbale Strict of Checking of objc_msgSend Calls</code> 设置为 <code>NO</code>。这样才不会报警告。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119095253.jpg" alt></p><h1 id="探索-objc-msgSend"><a href="#探索-objc-msgSend" class="headerlink" title="探索 objc_msgSend"></a>探索 <code>objc_msgSend</code></h1><p><code>objc_msgSend</code> 之所以采用汇编来实现，是因为</p><ul><li>汇编更容易能被机器识别</li><li>参数未知、类型未知对于 <code>C</code> 和 <code>C++</code> 来说不如汇编更得心应手</li></ul><h2 id="消息查找机制"><a href="#消息查找机制" class="headerlink" title="消息查找机制"></a>消息查找机制</h2><ul><li>快速流程</li><li>慢速流程</li></ul><h2 id="定位-objc-msgSend-汇编源码"><a href="#定位-objc-msgSend-汇编源码" class="headerlink" title="定位 objc_msgSend 汇编源码"></a>定位 <code>objc_msgSend</code> 汇编源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENTRY _objc_msgSend</span><br><span class="line">UNWIND _objc_msgSend, NoFrame</span><br><span class="line"></span><br><span class="line">cmpp0, #<span class="number">0</span><span class="comment">// nil check and tagged pointer check</span></span><br></pre></td></tr></table></figure><p>判断 <code>p0</code> ，也就是我们 <code>objc_msgSend</code> 的第一个参数 <code>id</code> 消息的接收者是否为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldrp13, [x0]// p13 = isa</span><br><span class="line">GetClassFromIsa_p16 p13// p16 = class</span><br></pre></td></tr></table></figure><p>读取 <code>x0</code> 然后赋值到 <code>p13</code> ，这里 <code>p13</code> 拿到的是 <code>isa</code>。为什么要拿 <code>isa</code> 呢，因为不论是对象方法还是类方法，我们都需要在类或者元类的缓存或方法列表中去查找，所以 <code>isa</code> 是必需的。</p><h2 id="GetClassFromIsa-p16"><a href="#GetClassFromIsa-p16" class="headerlink" title="GetClassFromIsa_p16"></a>GetClassFromIsa_p16</h2><p>通过 <code>GetClassFromIsa_p16</code>，将获取到的 <code>class</code> 存在 <code>p16</code> 上面。</p><p><code>GetClassFromIsa_p16</code> 源码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.macro GetClassFromIsa_p16 <span class="comment">/* src */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line"><span class="comment">// Indexed isa</span></span><br><span class="line">movp16, $<span class="number">0</span><span class="comment">// optimistically set dst = src</span></span><br><span class="line">tbzp16, #ISA_INDEX_IS_NPI_BIT, <span class="number">1f</span><span class="comment">// done if not non-pointer isa</span></span><br><span class="line"><span class="comment">// isa in p16 is indexed</span></span><br><span class="line">adrpx10, _objc_indexed_classes@PAGE</span><br><span class="line">addx10, x10, _objc_indexed_classes@PAGEOFF</span><br><span class="line">ubfxp16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS  <span class="comment">// extract index</span></span><br><span class="line">ldrp16, [x10, p16, UXTP #PTRSHIFT]<span class="comment">// load class from array</span></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __LP64__</span></span><br><span class="line"><span class="comment">// 64-bit packed isa</span></span><br><span class="line"><span class="keyword">and</span>p16, $<span class="number">0</span>, #ISA_MASK</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// 32-bit raw isa</span></span><br><span class="line">movp16, $<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>这个方法的目的就是通过位移操作获取 <code>isa</code> 的 <code>shiftcls</code> 然后进行位运算与操作得到真正的类信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LGetIsaDone:</span><br><span class="line">CacheLookup NORMAL<span class="comment">// calls imp or objc_msgSend_uncached</span></span><br></pre></td></tr></table></figure><h2 id="CacheLookup"><a href="#CacheLookup" class="headerlink" title="CacheLookup"></a>CacheLookup</h2><p>获取完 <code>isa</code> 之后，接下来就要进行 <code>CacheLookup</code> ，查找方法缓存，我们再来到 <code>CacheLookup</code> 的源码处:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CacheLookup NORMAL|GETIMP|LOOKUP</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Locate the implementation for a selector in a class method cache.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Takes:</span></span><br><span class="line"><span class="comment"> * x1 = selector</span></span><br><span class="line"><span class="comment"> * x16 = class to be searched</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Kills:</span></span><br><span class="line"><span class="comment"> *  x9,x10,x11,x12, x17</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On exit: (found) calls or returns IMP</span></span><br><span class="line"><span class="comment"> *                  with x16 = class, x17 = IMP</span></span><br><span class="line"><span class="comment"> *          (not found) jumps to LCacheMiss</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> ********************************************************************/</span></span><br><span class="line"></span><br><span class="line">.macro CacheLookup</span><br><span class="line"><span class="comment">// p1 = SEL, p16 = isa</span></span><br><span class="line">ldpp10, p11, [x16, #CACHE]<span class="comment">// p10 = buckets, p11 = occupied|mask</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__LP64__</span></span><br><span class="line"><span class="keyword">and</span>w11, w11, <span class="number">0xffff</span><span class="comment">// p11 = mask</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">and</span>w12, w1, w11<span class="comment">// x12 = _cmd &amp; mask</span></span><br><span class="line">addp12, p10, p12, LSL #(<span class="number">1</span>+PTRSHIFT)</span><br><span class="line">             <span class="comment">// p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</span></span><br><span class="line"></span><br><span class="line">ldpp17, p9, [x12]<span class="comment">// &#123;imp, sel&#125; = *bucket</span></span><br><span class="line"><span class="number">1</span>:cmpp9, p1<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">b.ne<span class="number">2f</span><span class="comment">//     scan more</span></span><br><span class="line">CacheHit $<span class="number">0</span><span class="comment">// call or return imp</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>:<span class="comment">// not hit: p12 = not-hit bucket</span></span><br><span class="line">CheckMiss $<span class="number">0</span><span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line">cmpp12, p10<span class="comment">// wrap if bucket == buckets</span></span><br><span class="line">b.eq<span class="number">3f</span></span><br><span class="line">ldpp17, p9, [x12, #-BUCKET_SIZE]!<span class="comment">// &#123;imp, sel&#125; = *--bucket</span></span><br><span class="line">b<span class="number">1b</span><span class="comment">// loop</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:<span class="comment">// wrap: p12 = first bucket, w11 = mask</span></span><br><span class="line">addp12, p12, w11, UXTW #(<span class="number">1</span>+PTRSHIFT)</span><br><span class="line">                        <span class="comment">// p12 = buckets + (mask &lt;&lt; 1+PTRSHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Clone scanning loop to miss instead of hang when cache is corrupt.</span></span><br><span class="line"><span class="comment">// The slow path may detect any corruption and halt later.</span></span><br><span class="line"></span><br><span class="line">ldpp17, p9, [x12]<span class="comment">// &#123;imp, sel&#125; = *bucket</span></span><br><span class="line"><span class="number">1</span>:cmpp9, p1<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">b.ne<span class="number">2f</span><span class="comment">//     scan more</span></span><br><span class="line">CacheHit $<span class="number">0</span><span class="comment">// call or return imp</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>:<span class="comment">// not hit: p12 = not-hit bucket</span></span><br><span class="line">CheckMiss $<span class="number">0</span><span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line">cmpp12, p10<span class="comment">// wrap if bucket == buckets</span></span><br><span class="line">b.eq<span class="number">3f</span></span><br><span class="line">ldpp17, p9, [x12, #-BUCKET_SIZE]!<span class="comment">// &#123;imp, sel&#125; = *--bucket</span></span><br><span class="line">b<span class="number">1b</span><span class="comment">// loop</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:<span class="comment">// double wrap</span></span><br><span class="line">JumpMiss $<span class="number">0</span></span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>通过上述代码可知 <code>CacheLookup</code> 有三种模式：<code>NORMAL</code>，<code>GETIMP</code>， <code>LOOKUP</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldpp10, p11, [x16, #CACHE]</span><br></pre></td></tr></table></figure><ul><li><code>CacheLookup</code> 需要读取上一步拿到的类的 <code>cache</code> 缓存，而根据我们前面对类结构的学习，这里显然进行 16 字节地址平移操作，然后把拿到的 <code>cache_t</code> 中的 <code>buckets</code> 和 <code>occupied</code>、<code>mask</code> 赋值给 <code>p10</code>, <code>p11</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span>w12, w1, w11<span class="comment">// x12 = _cmd &amp; mask</span></span><br><span class="line">addp12, p10, p12, LSL #(<span class="number">1</span>+PTRSHIFT)</span><br><span class="line">             <span class="comment">// p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (1+PTRSHIFT))</span></span><br><span class="line"></span><br><span class="line">ldpp17, p9, [x12]<span class="comment">// &#123;imp, sel&#125; = *bucket</span></span><br></pre></td></tr></table></figure><ul><li>这里是将 <code>w1</code> 和 <code>w11</code> 进行与操作，其实本质就是 <code>_cmd</code> &amp; <code>mask</code>。这一步和我们探索 <code>cache_t</code> 时遇到的<br><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119095327.jpg" alt><br>是一模模一样样的道理。目的就是拿到下标。然后经过哈希运算之后，得到了 <code>bucket</code> 结构体指针，然后将这个结构体指针中的 <code>imp</code>，<code>sel</code> 分别存在 <code>p17</code>，<code>p9</code> 中。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:cmpp9, p1<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">b.ne<span class="number">2f</span><span class="comment">//     scan more</span></span><br><span class="line">CacheHit $<span class="number">0</span><span class="comment">// call or return imp</span></span><br></pre></td></tr></table></figure><ul><li>接着我们将上一步获取到的 <code>sel</code> 和我们要查找的 <code>sel</code>（在这里也就是所谓的 <code>_cmd</code>）进行比较，如果匹配了，就通过 <code>CacheHit</code> 将 <code>imp</code> 返回；如果没有匹配，就走下一步流程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>:<span class="comment">// not hit: p12 = not-hit bucket</span></span><br><span class="line">CheckMiss $<span class="number">0</span><span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line">cmpp12, p10<span class="comment">// wrap if bucket == buckets</span></span><br><span class="line">b.eq<span class="number">3f</span></span><br><span class="line">ldpp17, p9, [x12, #-BUCKET_SIZE]!<span class="comment">// &#123;imp, sel&#125; = *--bucket</span></span><br><span class="line">b<span class="number">1b</span><span class="comment">// loop</span></span><br></pre></td></tr></table></figure><ul><li>由于上一步的 <code>sel</code> 没有匹配上，我们需要接着进行搜索。</li></ul><h2 id="CheckMiss"><a href="#CheckMiss" class="headerlink" title="CheckMiss"></a>CheckMiss</h2><p>我们来到 <code>CheckMiss</code> 的源码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.macro CheckMiss</span><br><span class="line"><span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line">.<span class="keyword">if</span> $<span class="number">0</span> == GETIMP</span><br><span class="line">cbzp9, LGetImpMiss</span><br><span class="line">.elseif $<span class="number">0</span> == NORMAL</span><br><span class="line">cbzp9, __objc_msgSend_uncached</span><br><span class="line">.elseif $<span class="number">0</span> == LOOKUP</span><br><span class="line">cbzp9, __objc_msgLookup_uncached</span><br><span class="line">.<span class="keyword">else</span></span><br><span class="line">.<span class="built_in">abort</span> oops</span><br><span class="line">.endif</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>这里由于我们是 <code>NORMAL</code> 模式，所以会来到 <code>__objc_msgSend_uncached</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line"></span><br><span class="line"><span class="comment">// THIS IS NOT A CALLABLE C FUNCTION</span></span><br><span class="line"><span class="comment">// Out-of-band p16 is the class to search</span></span><br><span class="line"></span><br><span class="line">MethodTableLookup</span><br><span class="line">TailCallFunctionPointer x17</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure><p><code>__objc_msgSend_uncached</code> 中最核心的逻辑就是 <code>MethodTableLookup</code>，意为查找方法列表。</p><p><a name="ab4985f9"></a></p><h2 id="3-6-MethodTableLookup"><a href="#3-6-MethodTableLookup" class="headerlink" title="3.6 MethodTableLookup"></a>3.6 MethodTableLookup</h2><p>我们再来到 <code>MethodTableLookup</code> 的定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.macro MethodTableLookup</span><br><span class="line"></span><br><span class="line"><span class="comment">// push frame</span></span><br><span class="line">SignLR</span><br><span class="line">stpfp, lr, [sp, #<span class="number">-16</span>]!</span><br><span class="line">movfp, sp</span><br><span class="line"></span><br><span class="line"><span class="comment">// save parameter registers: x0..x8, q0..q7</span></span><br><span class="line">subsp, sp, #(<span class="number">10</span>*<span class="number">8</span> + <span class="number">8</span>*<span class="number">16</span>)</span><br><span class="line">stpq0, q1, [sp, #(<span class="number">0</span>*<span class="number">16</span>)]</span><br><span class="line">stpq2, q3, [sp, #(<span class="number">2</span>*<span class="number">16</span>)]</span><br><span class="line">stpq4, q5, [sp, #(<span class="number">4</span>*<span class="number">16</span>)]</span><br><span class="line">stpq6, q7, [sp, #(<span class="number">6</span>*<span class="number">16</span>)]</span><br><span class="line">stpx0, x1, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">0</span>*<span class="number">8</span>)]</span><br><span class="line">stpx2, x3, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">2</span>*<span class="number">8</span>)]</span><br><span class="line">stpx4, x5, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">4</span>*<span class="number">8</span>)]</span><br><span class="line">stpx6, x7, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">6</span>*<span class="number">8</span>)]</span><br><span class="line">strx8,     [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">8</span>*<span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// receiver and selector already in x0 and x1</span></span><br><span class="line">movx2, x16</span><br><span class="line">bl__class_lookupMethodAndLoadCache3</span><br><span class="line"></span><br><span class="line"><span class="comment">// IMP in x0</span></span><br><span class="line">movx17, x0</span><br><span class="line"></span><br><span class="line"><span class="comment">// restore registers and return</span></span><br><span class="line">ldpq0, q1, [sp, #(<span class="number">0</span>*<span class="number">16</span>)]</span><br><span class="line">ldpq2, q3, [sp, #(<span class="number">2</span>*<span class="number">16</span>)]</span><br><span class="line">ldpq4, q5, [sp, #(<span class="number">4</span>*<span class="number">16</span>)]</span><br><span class="line">ldpq6, q7, [sp, #(<span class="number">6</span>*<span class="number">16</span>)]</span><br><span class="line">ldpx0, x1, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">0</span>*<span class="number">8</span>)]</span><br><span class="line">ldpx2, x3, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">2</span>*<span class="number">8</span>)]</span><br><span class="line">ldpx4, x5, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">4</span>*<span class="number">8</span>)]</span><br><span class="line">ldpx6, x7, [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">6</span>*<span class="number">8</span>)]</span><br><span class="line">ldrx8,     [sp, #(<span class="number">8</span>*<span class="number">16</span>+<span class="number">8</span>*<span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">movsp, fp</span><br><span class="line">ldpfp, lr, [sp], #<span class="number">16</span></span><br><span class="line">AuthenticateLR</span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>我们观察 <code>MethodTableLookup</code> 内容之后会定位到 <code>__class_lookupMethodAndLoadCache3</code>。在 <code>__class_lookupMethodAndLoadCache3</code> 之前会做一些准备工作，真正的方法查找流程核心逻辑是位于 <code>__class_lookupMethodAndLoadCache3</code> 里面的。 但是我们全局搜索 <code>__class_lookupMethodAndLoadCache3</code> 会发现找不到，这是因为此时我们会从汇编跳入到 <code>C/C++</code>。所以去掉一个下划线就能找到:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              YES<span class="comment">/*initialize*/</span>, NO<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="c57341de"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>方法的本质就是消息发送，消息发送是通过 <code>objc_msgSend</code> 以及其派生函数来实现的。</li><li><code>objc_msgSend</code> 为了执行效率以及 C/C++ 不能支持参数未知，类型未知的代码，所以采用汇编来实现 <code>objc_msgSend</code>。</li><li>消息查找或者说方法查找，会优先去从类中查找缓存，找到了就返回，找不到就需要去类的方法列表中查找。</li><li>由汇编过渡到 C/C++，在类的方法列表中查找失败之后，会进行转发。核心逻辑位于 <code>lookUpImpOrForward</code>。</li></ul><p>我们下一章将会从 <code>lookUpImpOrForward</code> 开始探索，探索底层的方法查找的具体流程到底是怎么样的，敬请期待~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在前面探索了对象和类的底层原理，接下来我们要探索一下方法的本质，而在探索之前，我们先简单过一遍 &lt;code&gt;Runtime&lt;/code&gt; 的知识点，如果读者对这块内容已经很熟悉了的话可以直接跳过第一章。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - cache_t</title>
    <link href="http://leejunhui.com/2020/01/06/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-cache-t/"/>
    <id>http://leejunhui.com/2020/01/06/iOS-底层探索-cache-t/</id>
    <published>2020-01-06T06:32:21.000Z</published>
    <updated>2020-01-18T18:38:59.201Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇我们一起探索了 <code>iOS</code> 类的底层原理，其中比较重要的四个属性我们都简单的过了一遍，我们接下来要重点探索第三个属性 <code>cache_t</code>，对于这个属性，我们可以学习到苹果对于缓存的设计与理解，同时也会接触到消息发送相关的知识。</p><a id="more"></a><h1 id="探索-cache-t"><a href="#探索-cache-t" class="headerlink" title="探索 cache_t"></a>探索 <code>cache_t</code></h1><h2 id="cache-t-基本结构"><a href="#cache-t-基本结构" class="headerlink" title="cache_t 基本结构"></a><code>cache_t</code> 基本结构</h2><p>我们还是先过一遍 <code>OC</code> 中类的结构:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...省略代码...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们查看源码中 <code>cache_t</code> 的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;</span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;</span><br><span class="line">    </span><br><span class="line">    ...省略代码... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们发现 <code>cache_t</code> 结构体的第一个成员 <code>_buckets</code> 也是一个结构体类型 <code>bucket_t</code>，我们再查看一下 <code>bucket_t</code> 的定义:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// IMP-first is better for arm64e ptrauth and no worse for arm64.</span></span><br><span class="line">    <span class="comment">// SEL-first is better for armv7* and i386 and x86_64.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line">    <span class="keyword">cache_key_t</span> _key;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">cache_key_t</span> _key;</span><br><span class="line">    MethodCacheIMP _imp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> cache_key_t <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> IMP <span class="title">imp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (IMP)_imp; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(<span class="keyword">cache_key_t</span> newKey)</span> </span>&#123; _key = newKey; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setImp</span><span class="params">(IMP newImp)</span> </span>&#123; _imp = newImp; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">cache_key_t</span> newKey, IMP newImp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从源码定义中不难看出，<code>bucket_t</code> 其实缓存的是方法实现 <code>IMP</code>。这里有一个注意点，就是 <code>IMP-first</code> 和 <code>SEL-first</code>。</p><blockquote><p>IMP-first is better for arm64e ptrauth and no worse for arm64.</p></blockquote><ul><li>IMP-first 对 arm64e 的效果更好，对 arm64 不会有坏的影响。</li></ul><blockquote><p>SEL-first is better for armv7* and i386 and x86_64.</p></blockquote><ul><li>SEL-first 适用于 armv7 * 和 i386 和 x86_64。</li></ul><p>如果对 <code>SEL</code> 和 <code>IMP</code> 不是很熟悉的同学可以去 <code>objc4-756</code> 源码中查看方法 <code>method_t</code> 的定义:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;   <span class="comment">// 方法选择器</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types; <span class="comment">// 方法类型字符串</span></span><br><span class="line">    MethodListIMP imp;  <span class="comment">// 方法实现</span></span><br><span class="line"></span><br><span class="line">    ...省略代码... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上面的源码，我们大致了解了 bucket_t 类型的结构，那么现在问题来了，类中的 cache 是在什么时候以什么样的方式来进行缓存的呢？ </p><h2 id="LLDB-大法"><a href="#LLDB-大法" class="headerlink" title="LLDB 大法"></a><code>LLDB</code> 大法</h2><p>了解到 <code>cache_t</code> 和 <code>bucket_t</code> 的基本结构后，我们可以通过 <code>LLDB</code> 来打印验证一下：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023640.jpg" alt></p><p><code>cache_t</code> 内部的这三个属性，我们从其名称不难看出 <code>_occupied</code> 应该是表示当前已经占用了多少缓存，<code>_mask</code> 暂时不知道，<code>_buckets</code> 应该是存放具体缓存的地方。那么为了验证我们的猜想，我们调用代码来测试:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023653.jpg" alt></p><p>我们发现，断点断到 45 行的时候，<code>_ocuupied</code> 的值为 1，我们打印一下 <code>_buckets</code> 里面的内容看看:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023700.jpg" alt></p><p>我们可以看到，打印到 <code>_buckets</code> 的第三个元素的时候，我们的 <code>init</code> 方法被缓存了，也就是说 <code>_ocuupied</code> 确实是表示当前被缓存方法的个数。这里可能读者会说为什么 <code>alloc</code> 和 <code>class</code> 为什么没有被缓存呢？其实这是因为 <code>alloc</code> 和 <code>class</code> 是类方法，而根据我们前面探索类底层原理的时候，类方法是存储在元类里面的，所以这里类的缓存里面只会存储对象方法。<br>我们接着把断点过到 46 行:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023709.jpg" alt></p><p><code>_ocuupied</code> 的值果然发生了变化，我们刚才的猜想进一步得到了验证，我们再往下面走一行:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023718.jpg" alt></p><p>此时 <code>_ocuupied</code> 值已经为 3 了，我们回顾一下当前缓存里面缓存的方法:</p><table><thead><tr><th>_ocuupied 的值</th><th>缓存的方法</th></tr></thead><tbody><tr><td>1</td><td>NSObject下的<code>init</code></td></tr><tr><td>2</td><td>NSObject下的<code>init</code>，person下的 <code>sayHello</code></td></tr><tr><td>3</td><td>NSObject下的<code>init</code>，person下的 <code>sayHello</code>, person下的 <code>sayCode</code></td></tr></tbody></table><p>那么，当我们的断点断到下一行的时候，是不是 <code>_ocuupied</code> 就会变为 4 呢? 我们接着往下走：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023729.jpg" alt></p><p>令人惊奇的事情发生了，<code>_ocuupied</code> 的值变成了 1，而 <code>_mask</code> 变成了 7。这是为什么呢？</p><p>如果读者了解并掌握散列表这种数据结构的话，相信已经看出端倪了。是的，这里其实就是用到了 <strong>开放寻址法</strong> 来解决散列冲突（哈希冲突）。</p><blockquote><p>关于哈希冲突，可以借助鸽笼理论，即把 11 只鸽子放进 10 个抽屉里面，肯定会有一个抽屉里面有 2 只鸽子。是不是理解起来很简单? :)</p></blockquote><p>通过上面的测试，我们明确了方法缓存使用的是哈希表存储，并且为了解决无法避免的哈希冲突使用的是开放寻址法，而开放寻址法必然要在合适的时机进行扩容，这个时机肯定不是会在数据已经装满的时候，我们可以进源码探索一下，我们快速定位到 <code>cache_t</code> 的源码处:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">cache_t</span>::expand()</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> oldCapacity = capacity();</span><br><span class="line">    <span class="keyword">uint32_t</span> newCapacity = oldCapacity ? oldCapacity*<span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)(<span class="keyword">mask_t</span>)newCapacity != newCapacity) &#123;</span><br><span class="line">        <span class="comment">// mask overflow - can't grow further</span></span><br><span class="line">        <span class="comment">// fixme this wastes one bit of mask</span></span><br><span class="line">        newCapacity = oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reallocate(oldCapacity, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码不难看出 <code>expand</code> 方法就是扩容的核心算法，我们梳理一下里面的逻辑:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cacheUpdateLock.assertLocked();</span><br></pre></td></tr></table></figure><ul><li>缓存锁断言一下判断当前执行上下文是否已经上锁</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> oldCapacity = capacity();</span><br></pre></td></tr></table></figure><ul><li>通过 <code>capacity()</code> 方法获取当前的容量大小</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> newCapacity = oldCapacity ? oldCapacity*<span class="number">2</span> : INIT_CACHE_SIZE;</span><br></pre></td></tr></table></figure><ul><li>判断当前的容量大小，如果为0，则赋值为 <code>INIT_CACHE_SIZE</code>，而根据</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">2</span>,</span><br><span class="line">    INIT_CACHE_SIZE      = (<span class="number">1</span> &lt;&lt; INIT_CACHE_SIZE_LOG2)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可知 <code>INIT_CACHE_SIZE</code> 初始值为 4；如果当前容量大小不为 0，则直接翻倍。</p><p>到了这里相信聪明的读者根据我们上面的测试应该猜到了，我们的 <code>_mask</code> 其实就是容量大小减 1 后的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reallocate(oldCapacity, newCapacity);</span><br></pre></td></tr></table></figure><ul><li>最后调用 <code>reallocate</code> 方法进行缓存大小的重置</li></ul><p>我们接着进入 <code>reallocate</code> 内部一探究竟:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">cache_t</span>::reallocate(<span class="keyword">mask_t</span> oldCapacity, <span class="keyword">mask_t</span> newCapacity)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> freeOld = canBeFreed();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bucket_t</span> *oldBuckets = buckets();</span><br><span class="line">    <span class="keyword">bucket_t</span> *newBuckets = allocateBuckets(newCapacity);</span><br><span class="line"></span><br><span class="line">    assert(newCapacity &gt; <span class="number">0</span>);</span><br><span class="line">    assert((<span class="keyword">uintptr_t</span>)(<span class="keyword">mask_t</span>)(newCapacity<span class="number">-1</span>) == newCapacity<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    setBucketsAndMask(newBuckets, newCapacity - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (freeOld) &#123;</span><br><span class="line">        cache_collect_free(oldBuckets, oldCapacity);</span><br><span class="line">        cache_collect(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">cache_t</span>::setBucketsAndMask(struct <span class="keyword">bucket_t</span> *newBuckets, <span class="keyword">mask_t</span> newMask)</span><br><span class="line">&#123;</span><br><span class="line">    mega_barrier();</span><br><span class="line"></span><br><span class="line">    _buckets = newBuckets;</span><br><span class="line">    </span><br><span class="line">    mega_barrier();</span><br><span class="line">    </span><br><span class="line">    _mask = newMask;</span><br><span class="line">    _occupied = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，<code>_mask</code> 是这一步 <code>setBucketsAndMask(newBuckets, newCapacity - 1);</code> 被赋值为容量减 1 的。</p><p>同样的，我们还可以通过 <code>capacity</code> 方法来验证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mask_t</span> <span class="keyword">cache_t</span>::capacity() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mask() ? mask()+<span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="深入-cache-t"><a href="#深入-cache-t" class="headerlink" title="深入 cache_t"></a>深入 <code>cache_t</code></h1><p>其实我们在探索 <code>iOS</code> 底层的时候，尽量不要站在上帝视角去审视相应的技术点，我们可以尽量给自己多抛出几个问题，然后尝试去解决每个问题，通过这样的探索，对提高我们阅读源码的能力十分重要。</p><p>通过前面的探索，我们知道了 <code>cache_t</code> 实质上是缓存了我们类的实例方法，那么对于类方法来说，自然就是缓存在了元类上了。这一点我相信读者应该都能理解。</p><h2 id="方法缓存策略"><a href="#方法缓存策略" class="headerlink" title="方法缓存策略"></a>方法缓存策略</h2><p>按照最常规的思维，缓存内容最省时省力的办法肯定是来一个缓存一个，那么我们的 <code>cache_t</code> 是不是这么做的呢，实践出真知，我们一试便知。</p><p>我们在源码中搜索 <code>capacity()</code> 方法，我们找到了 <code>cache_fill_nolock</code> 方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cache_fill_nolock</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Never cache before +initialize is done</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isInitialized()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the entry wasn't added to the cache by some other thread </span></span><br><span class="line">    <span class="comment">// before we grabbed the cacheUpdateLock.</span></span><br><span class="line">    <span class="keyword">if</span> (cache_getImp(cls, sel)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">cache_t</span> *cache = getCache(cls);</span><br><span class="line">    <span class="keyword">cache_key_t</span> key = getKey(sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the cache as-is if it is less than 3/4 full</span></span><br><span class="line">    <span class="keyword">mask_t</span> newOccupied = cache-&gt;occupied() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">mask_t</span> capacity = cache-&gt;capacity();</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newOccupied &lt;= capacity / <span class="number">4</span> * <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Cache is too full. Expand it.</span></span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for the first unused slot and insert there.</span></span><br><span class="line">    <span class="comment">// There is guaranteed to be an empty slot because the </span></span><br><span class="line">    <span class="comment">// minimum size is 4 and we resized at 3/4 full.</span></span><br><span class="line">    <span class="keyword">bucket_t</span> *bucket = cache-&gt;find(key, receiver);</span><br><span class="line">    <span class="keyword">if</span> (bucket-&gt;key() == <span class="number">0</span>) cache-&gt;incrementOccupied();</span><br><span class="line">    bucket-&gt;<span class="built_in">set</span>(key, imp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cache_fill_nolock</code> 方法乍一看有些复杂，我们不妨将它分解一下:</p><p>第一行代码还是加锁的判断，我们直接略过，来到第二行:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cache_getImp(cls, sel)) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>cache_getImp</code> 来判断当前 <code>cls</code> 下的 <code>sel</code> 是否已经被缓存了，如果是，直接返回。而 <code>cache_getImp</code> 底层实现是 <code>_cache_getImp</code>，并且是在汇编层实现的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cache_t</span> *cache = getCache(cls);</span><br><span class="line"><span class="keyword">cache_key_t</span> key = getKey(sel);</span><br></pre></td></tr></table></figure><ul><li>调用 <code>getCache</code> 来获取 <code>cls</code> 的方法缓存，然后通过 <code>getKey</code> 来获取到缓存的 <code>key</code>，这里的 <code>getKey</code> 其实是将 <code>SEL</code> 类型强转成 <code>cache_key_t</code> 类型。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mask_t</span> newOccupied = cache-&gt;occupied() + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>在 <code>cache</code> 已经占用的基础上进行加 1，得到的是新的缓存占用大小 <code>newOccupied</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mask_t</span> capacity = cache-&gt;capacity();</span><br></pre></td></tr></table></figure><ul><li>然后读取现在缓存的容量 <code>capacity</code>。</li></ul><p>然后接下来是一系列的判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">    <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">    cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果缓存为空了，那么就重新申请一下内存并覆盖之前的缓存，之所以这样做是因为缓存是只读的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newOccupied &lt;= capacity / <span class="number">4</span> * <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 full. Use it as-is.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果新的缓存占用大小 <code>小于等于</code> 缓存容量的四分之三，则可以进行缓存流程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Cache is too full. Expand it.</span></span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果缓存不为空，且缓存占用大小已经超过了容量的四分之三，则需要进行扩容。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> *bucket = cache-&gt;find(key, receiver);</span><br></pre></td></tr></table></figure><ul><li>通过前面生成的 <code>key</code> 在缓存中查找对应的 <code>bucket_t</code>，也就是对应的方法实现。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bucket-&gt;key() == <span class="number">0</span>) cache-&gt;incrementOccupied();</span><br><span class="line">bucket-&gt;<span class="built_in">set</span>(key, imp);</span><br></pre></td></tr></table></figure><ul><li>判断获取到的<strong>桶</strong> <code>bucket</code> 是否是新的桶，如果是的话，就在缓存里面增加一个占用大小。然后把 <code>key</code> 和 <code>imp</code> 放到桶里面。</li></ul><p><code>cache_fill_nolock</code> 的基本流程我们分析完了，这个方法主要针对的是没有缓存的情况。<br>但是这个方法里面的 <code>cache-&gt;find</code> 我们并不知道是怎么实现的，我们接着探索这个方法:</p><h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bucket_t</span> * <span class="keyword">cache_t</span>::find(<span class="keyword">cache_key_t</span> k, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    assert(k != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bucket_t</span> *b = buckets();</span><br><span class="line">    <span class="keyword">mask_t</span> m = mask();</span><br><span class="line">    <span class="keyword">mask_t</span> begin = cache_hash(k, m);</span><br><span class="line">    <span class="keyword">mask_t</span> i = begin;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i].key() == <span class="number">0</span>  ||  b[i].key() == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((i = cache_next(i, m)) != begin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hack</span></span><br><span class="line">    Class cls = (Class)((<span class="keyword">uintptr_t</span>)<span class="keyword">this</span> - offsetof(objc_class, cache));</span><br><span class="line">    <span class="keyword">cache_t</span>::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>find</code> 方法我们乍一看会发现有一个 <code>do-while</code> 循环，因为这个方法的作用是根据 <code>key</code> 查找 <code>IMP</code>，但需要注意的是，这里返回的并不是一个 <code>IMP</code>，而是 <code>bucket_t</code> 结构体指针。</p><ul><li>通过 <code>buckets()</code> 方法获取当前 <code>cache_t</code> 下所有的缓存<code>桶</code>。</li><li>通过 <code>mask()</code> 方法获取当前 <code>cache_t</code> 的缓存大小减一的值 <code>mask_t</code>。</li><li>然后把 <code>mask_t</code> 的值作为循环的索引。</li><li>在 <code>do-while</code> 循环里遍历整个 <code>bucket_t</code>，如果 <code>key</code> 为 0，说明当前索引位置上还没有缓存过方法，则需要停止循环，返回当前位置上的 <code>bucket_t</code>；如果 <code>key</code> 为要查询的 <code>k</code>，说明缓存命中了，则直接返回结果。</li><li>这里的循环遍历是通过 <code>cache_next</code> 方法实现的，这个方法内部就是当前下标 <code>i</code> 与 <code>mask_t</code> 的值进行与操作，来实现索引更新的。</li></ul><h1 id="cache-t-探索后的疑问点"><a href="#cache-t-探索后的疑问点" class="headerlink" title="cache_t 探索后的疑问点"></a><code>cache_t</code> 探索后的疑问点</h1><p>整个 <code>cache_t</code> 的工作流程，简略描述如下：</p><ul><li>当前查找的 <code>IMP</code> 没有被缓存，调用 <code>cache_fill_nolock</code> 方法进行填充缓存。</li><li>当前查找的 <code>IMP</code> 已经被缓存了，然后判断缓存容量是否已经达到 <code>3/4</code> 的临界点<ul><li>如果已经到了临界点，则需要进行扩容，扩容大小为原来缓存大小的 2 倍。扩容后处于效率的考虑，会清空之前的内容，然后把当前要查找的 <code>IMP</code> 通过 <code>cache_fill_nolock</code> 方法缓存起来。</li><li>如果没有到临界点，那么直接返回找到的 <code>IMP</code>。</li></ul></li></ul><p>我们梳理完 <code>cache_t</code> 的大致流程之后，我们还有一些遗留问题没有解决，接下来一一来解决一下。</p><h2 id="3-1-mask-的作用"><a href="#3-1-mask-的作用" class="headerlink" title="3.1 mask 的作用"></a>3.1 <code>mask</code> 的作用</h2><p>我们先回顾一下 <code>mask</code> 出现在了哪些地方:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setBucketsAndMask(newBuckets, newCapacity - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">cache_t</span>::setBucketsAndMask(struct <span class="keyword">bucket_t</span> *newBuckets, <span class="keyword">mask_t</span> newMask)</span><br><span class="line">&#123;</span><br><span class="line">    mega_barrier();</span><br><span class="line"></span><br><span class="line">    _buckets = newBuckets;</span><br><span class="line">    </span><br><span class="line">    mega_barrier();</span><br><span class="line">    </span><br><span class="line">    _mask = newMask;</span><br><span class="line">    _occupied = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mask_t</span> <span class="keyword">cache_t</span>::capacity() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mask() ? mask()+<span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，<code>mask</code> 是作为 <code>cache_t</code> 的属性存在的，它代表的是<strong>缓存容量的大小减一</strong>的值。这一点在 <code>setBucketsAndMask</code> 与 <code>capacity</code> 方法中可以得到证实。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cache_fill_nolock &#123;</span><br><span class="line">    <span class="keyword">cache_key_t</span> key = getKey(sel);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bucket_t</span> *bucket = cache-&gt;find(key, receiver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Class points to cache. SEL is key. Cache buckets store SEL+IMP.</span></span><br><span class="line">    <span class="comment">// Caches are never built in the dyld shared cache.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> mask_t <span class="title">cache_hash</span><span class="params">(<span class="keyword">cache_key_t</span> key, <span class="keyword">mask_t</span> mask)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">mask_t</span>)(key &amp; mask);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> mask_t <span class="title">cache_next</span><span class="params">(<span class="keyword">mask_t</span> i, <span class="keyword">mask_t</span> mask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i+<span class="number">1</span>) &amp; mask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的伪代码，<code>cache_fill_nolock</code> 方法里面，会先根据要查找的 <code>sel</code> 强转成 <code>cache_key_t</code> 结构，这是因为 <code>sel</code> 其实为方法名:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023814.jpg" alt></p><p>而经过强转之后为:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023825.jpg" alt></p><p>也就是说最后缓存的 <code>key</code> 其实是一个无符号长整型值，这样相对于直接拿字符串来作为键值，明显效率更高。</p><p>经过强转之后，把 <code>key</code> 传给 <code>find</code> 方法。然后会有一个 <code>cache_hash</code> 方法，其注释如下：</p><blockquote><p>类指向缓存，<code>SEL</code> 是键，<code>buckets</code>缓存存储的是 <code>SEL</code> + <code>IMP</code>。<br>方法缓存永远不会存储在 <code>dyld</code> 共享缓存里面。</p></blockquote><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023837.jpg" alt></p><p>实际测试如上图所示，<code>cache_hash</code> 方法其实就是哈希算法，得到的是一个哈希值。拿到这个哈希值后就可以在哈希表中进行查询。在 <code>find</code> 方法中就是获得索引的起始值。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119023851.jpg" alt></p><p>通过上图的测试我们可以得出这里是使用的 <code>LRU</code> 缓存算法。</p><blockquote><p><code>LRU</code> 算法的全称是 <code>Least Recently Used</code> ，也就是最近最少使用策略。这个策略的核心思想就是先淘汰最近最少使用的内容。</p></blockquote><h2 id="capacity-的变化"><a href="#capacity-的变化" class="headerlink" title="capacity 的变化"></a><code>capacity</code> 的变化</h2><p><code>capacity</code> 的变化主要发生在扩容的时候，当缓存已经占满了四分之三的时候，会进行两倍原来缓存空间大小的扩容，这一步是为了避免哈希冲突。</p><h2 id="为什么是在-3-4-时进行扩容"><a href="#为什么是在-3-4-时进行扩容" class="headerlink" title="为什么是在 3/4 时进行扩容"></a>为什么是在 <code>3/4</code> 时进行扩容</h2><p>在哈希这种数据结构里面，有一个概念叫<strong>装载因子</strong>，装载因子是用来表示空位的多少。其公式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">散列表的装载因子=填入表中的元素个数/散列表的长度</span><br></pre></td></tr></table></figure><p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。<br>苹果这里设计的装载因子显然为 1 - 3/4 = 1/4 =&gt; <strong>0.25</strong> 。<br>因为本质上方法缓存就是为了更快的执行效率，所以为了避免发生哈希冲突，在采用<code>开放寻址法</code>的前提下，尽可能小的装载因子可以提高散列表的性能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initial cache bucket count. INIT_CACHE_SIZE must be a power of two. */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">2</span>,</span><br><span class="line">    INIT_CACHE_SIZE      = (<span class="number">1</span> &lt;&lt; INIT_CACHE_SIZE_LOG2)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br></pre></td></tr></table></figure><p>初始化的缓存大小是 1 左移 2，结果为 4。然后在 <code>reallocate</code> 方法进行一下缓存的重新开辟。这也就意味着初始的缓存空间大小为 4。</p><h2 id="方法缓存是否有序"><a href="#方法缓存是否有序" class="headerlink" title="方法缓存是否有序"></a>方法缓存是否有序</h2><p>方法缓存是无序的，这是因为计算缓存下标是一个哈希算法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> mask_t <span class="title">cache_hash</span><span class="params">(<span class="keyword">cache_key_t</span> key, <span class="keyword">mask_t</span> mask)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mask_t</span>)(key &amp; mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>cache_hash</code> 之后计算出来的下标并不是有序的，下标值取决于 <code>key</code> 和 <code>mask</code> 的值。</p><h2 id="bucket-与-mask-capacity-sel-imp-的关系"><a href="#bucket-与-mask-capacity-sel-imp-的关系" class="headerlink" title="bucket 与 mask, capacity, sel, imp 的关系"></a>bucket 与 mask, capacity, sel, imp 的关系</h2><p>一个类有一个属性 <code>cache_t</code>，而一个 <code>cache_t</code> 的 <code>buckets</code> 会有多个 <code>bucket</code>。一个 <code>bucket</code> 存储的是 <code>imp</code> 和 <code>cache_key_t</code> 。</p><p><code>mask</code> 的值对于 <code>bucket</code> 来说，主要是用来在缓存查找时的哈希算法。<br>而 <code>capacity</code> 则可以获取到 <code>cache_t</code> 中 <code>bucket</code> 的数量。</p><p><code>sel</code> 在缓存的时候是被强转成了 <code>cache_key_t</code> 的形式，更方便查询使用。<br><code>imp</code> 则是函数指针，也就是方法的具体实现，缓存的主要目的就是通过一系列策略让编译器更快的执行消息发送的逻辑。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>OC</code> 中实例方法缓存在类上面，类方法缓存在元类上面。</li><li><code>cache_t</code> 缓存会提前进行扩容防止溢出。</li><li>方法缓存是为了最大化的提高程序的执行效率。</li><li>苹果在方法缓存这里用的是<code>开放寻址法</code>来解决哈希冲突。</li><li>通过 <code>cache_t</code> 我们可以进一步延伸去探究 <code>objc_msgSend</code>，因为查找方法缓存是属于 <code>objc_msgSend</code> 查找方法实现的快速流程。</li></ul><p>我们下一篇将开始探索 <code>iOS</code> 中方法的底层原理，敬请期待~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇我们一起探索了 &lt;code&gt;iOS&lt;/code&gt; 类的底层原理，其中比较重要的四个属性我们都简单的过了一遍，我们接下来要重点探索第三个属性 &lt;code&gt;cache_t&lt;/code&gt;，对于这个属性，我们可以学习到苹果对于缓存的设计与理解，同时也会接触到消息发送相关的知识。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - 类</title>
    <link href="http://leejunhui.com/2020/01/06/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-%E7%B1%BB/"/>
    <id>http://leejunhui.com/2020/01/06/iOS-底层探索-类/</id>
    <published>2020-01-05T18:34:29.000Z</published>
    <updated>2020-01-18T18:30:41.823Z</updated>
    
    <content type="html"><![CDATA[<p>我们在前面探索了 <code>iOS</code> 中的对象原理，面向对象编程中有一句名言:</p><blockquote><p>万物皆对象</p></blockquote><p>那么对象又是从哪来的呢？有过面向对象编程基础的同学肯定都知道是类派生出对象的，那么今天我们就一起来探索一下类的底层原理吧。</p><a id="more"></a><h1 id="iOS-中的类到底是什么？"><a href="#iOS-中的类到底是什么？" class="headerlink" title="iOS 中的类到底是什么？"></a><code>iOS</code> 中的类到底是什么？</h1><p>我们在日常开发中大多数情况都是从 <code>NSObject</code> 这个基类来派生出我们需要的类。那么在 <code>OC</code> 底层，我们的类 <code>Class</code> 到底被编译成什么样子了呢？</p><p>我们新建一个 <code>macOS</code> 控制台项目，然后新建一个 <code>Animal</code> 类出来。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animal.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Animal.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Animal.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Animal *animal = [[Animal alloc] init];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, animal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在终端执行 <code>clang</code> 命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure><p>这个命令是将我们的 <code>main.m</code> 重写成 <code>main.cpp</code>，我们打开这个文件搜索 <code>Animal</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022446.jpg" alt></p><p>我们发现有多个地方都出现了 <code>Animal</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> <span class="title">Animal</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal_IMPL</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> <span class="title">NSObject_IVARS</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">objc_getClass(<span class="string">"Animal"</span>)</span><br></pre></td></tr></table></figure><p>我们先全局搜索第一个 <code>typedef struct objc_object</code>，发现有 843 个结果</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022507.jpg" alt></p><p>我们通过 <code>Command + G</code> 快捷键快速翻阅一下，最终在 7626 行找到了 <code>Class</code> 的定义:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></table></figure><p>由这行代码我们可以得出一个结论，<code>Class</code> 类型在底层是一个结构体类型的指针，这个结构体类型为 <code>objc_class</code>。<br>再搜索 <code>typedef struct objc_class</code> 发现搜不出来了，这个时候我们需要在 <code>objc4-756</code> 源码中进行探索了。</p><p>我们在 <code>objc4-756</code> 源码中直接搜索 <code>struct objc_class</code> ，然后定位到 <code>objc-runtime-new.h</code> 文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，细心的读者可能会发现，我们在前面探索对象原理中遇到的 <code>objc_object</code> 再次出现了，并且这次是作为 <code>objc_class</code> 的父类。这里再次引用那句经典名言 <strong>万物皆对象</strong>，也就是说类其实也是一种<strong>对象</strong>。</p><p>由此，我们可以简单总结一下类和对象在 <code>C</code> 和 <code>OC</code> 中分别的定义</p><table><thead><tr><th>C</th><th>OC</th></tr></thead><tbody><tr><td>objc_object</td><td>NSObject</td></tr><tr><td>objc_class</td><td>NSObject(Class)</td></tr></tbody></table><h1 id="类的结构是什么样的呢？"><a href="#类的结构是什么样的呢？" class="headerlink" title="类的结构是什么样的呢？"></a>类的结构是什么样的呢？</h1><p>通过上面的探索，我们已经知道了类本质上也是对象，而日常开发中常见的成员变量、属性、方法、协议等都是在类里面存在的，那么我们是不是可以猜想在 <code>iOS</code> 底层，类其实就存储了这些内容呢？</p><p>我们可以通过分析源码来验证我们的猜想。</p><p>从上一节中 <code>objc_class</code> 的定义处，我们可以梳理出 <code>Class</code> 中的 4 个属性</p><ul><li><code>isa</code> 指针</li><li><code>superclass</code> 指针</li><li><code>cache</code></li><li><code>bits</code></li></ul><blockquote><p>需要值得注意的是，这里的 <code>isa</code> 指针在这里是隐藏属性.</p></blockquote><h2 id="isa-指针"><a href="#isa-指针" class="headerlink" title="isa 指针"></a><code>isa</code> 指针</h2><p>首先是 <code>isa</code> 指针，我们之前已经探索过了，在对象初始化的时候，通过 <code>isa</code> 可以让对象和类关联，这一点很好理解，可是为什么在类结构里面还会有 <code>isa</code> 呢？看过上一篇文章的同学肯定知道这个问题的答案了。没错，就是<strong>元类</strong>。我们的对象和类关联起来需要 <code>isa</code>，同样的，类和元类之间关联也需要 <code>isa</code>。</p><h2 id="superclass-指针"><a href="#superclass-指针" class="headerlink" title="superclass 指针"></a><code>superclass</code> 指针</h2><p>顾名思义，<code>superclass</code> 指针表明当前类指向的是哪个父类。一般来说，类的根父类基本上都是 <code>NSObject</code> 类。根元类的父类也是 <code>NSObject</code> 类。</p><h2 id="cache-缓存"><a href="#cache-缓存" class="headerlink" title="cache 缓存"></a><code>cache</code> 缓存</h2><p><code>cache</code> 的数据结构为 <code>cache_t</code>，其定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;</span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;</span><br><span class="line">    </span><br><span class="line">    ...省略代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的缓存里面存放的是什么呢？是属性？是实例变量？还是方法？我们可以通过阅读 <code>objc-cache.mm</code> 源文件来解答这个问题。</p><blockquote><ul><li>objc-cache.m</li><li>Method cache management</li><li>Cache flushing</li><li>Cache garbage collection</li><li>Cache instrumentation</li><li>Dedicated allocator for large caches</li></ul></blockquote><p>上面是 <code>objc-cache.mm</code> 源文件的注释信息，我们可以看到 <code>Method cache management</code> 的出现，翻译过来就是方法缓存管理。那么是不是就是说 <code>cache</code> 属性就是缓存的方法呢？而 <code>OC</code> 中的方法我们现在还没有进行探索，先假设我们已经掌握了相关的底层原理，这里先简单提一下。</p><blockquote><p>我们在类里面编写的方法，在底层其实是以 <code>SEL</code> + <code>IMP</code> 的形式存在。<code>SEL</code> 就是方法的选择器，而 <code>IMP</code> 则是具体的方法实现。这里可以以书籍的目录以及内容来类比，我们查找一篇文章的时候，需要先知道其标题(<code>SEL</code>)，然后在目录中看有没有对应的标题，如果有那么就翻到对应的页，最后我们就找到了我们想要的内容。当然，<code>iOS</code> 中方法要比书籍的例子复杂一些，不过暂时可以这么简单的理解，后面我们会深入方法的底层进行探索。</p></blockquote><h2 id="bits-属性"><a href="#bits-属性" class="headerlink" title="bits 属性"></a><code>bits</code> 属性</h2><p><code>bits</code> 的数据结构类型是 <code>class_data_bits_t</code>，同时也是一个结构体类型。而我们阅读 <code>objc_class</code> 源码的时候，会发现很多地方都有 <code>bits</code> 的身影，比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">    <span class="keyword">return</span> bits.data();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCustomRR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ! bits.hasDefaultRR();</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canAllocFast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(!isFuture());</span><br><span class="line">    <span class="keyword">return</span> bits.canAllocFast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里值得我们注意的是，<code>objc_class</code> 的 <code>data()</code> 方法其实是返回的 <code>bits</code> 的 <code>data()</code> 方法，而通过这个 <code>data()</code> 方法，我们发现诸如类的字节对齐、<code>ARC</code>、元类等特性都有 <code>data()</code> 的出现，这间接说明 <code>bits</code> 属性其实是个大容器，有关于内存管理、C++ 析构等内容在其中有定义。</p><p>这里我们会遇到一个十分重要的知识点: <code>class_rw_t</code>，<code>data()</code> 方法的返回值就是 <code>class_rw_t</code> 类型的指针对象。我们在本文后面会重点介绍。</p><h1 id="类的属性存在哪？"><a href="#类的属性存在哪？" class="headerlink" title="类的属性存在哪？"></a>类的属性存在哪？</h1><p>上一节我们对 <code>OC</code> 中类结构有了基本的了解，但是我们平时最常打交道的内容-<strong>属性</strong>，我们还不知道它究竟是存在哪个地方。接下来我们要做一件事情，就是在 <code>objc4-756</code> 的源码中新建一个 <code>Target</code>，为什么不直接用上面的 <code>macOS</code> 命令行项目呢？因为我们要开始结合 <code>LLDB</code> 打印一些类的内部信息，所以只能是新建一个依靠于 <code>objc4-756</code> 源码 <code>project</code> 的 <code>target</code> 出来。同样的，我们还是选择 <code>macOS</code> 的命令行作为我们的 <code>target</code>。</p><p>接着我们新建一个类 <code>Person</code>，然后添加一些实例变量和属性出来。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *hobby;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *nickName;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        Class pClass = object_getClass(p);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们打一个断点到 <code>main.m</code> 文件中的 <code>NSLog</code> 语句处，然后运行刚才新建的 <code>target</code>。</p><p><code>target</code> 跑起来之后，我们在控制台先打印输出一下 <code>pClass</code> 的内容:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022526.jpg" alt></p><h2 id="类的内存结构"><a href="#类的内存结构" class="headerlink" title="类的内存结构"></a>类的内存结构</h2><p>我们这个时候需要借助指针平移来探索，而对于类的内存结构我们先看下面这张表格:</p><table><thead><tr><th>类的内存结构</th><th>大小(字节)</th></tr></thead><tbody><tr><td>isa</td><td>8</td></tr><tr><td>superclass</td><td>8</td></tr><tr><td>cache</td><td>16</td></tr></tbody></table><p>前两个大小很好理解，因为 <code>isa</code> 和 <code>superclass</code> 都是结构体指针，而在 <code>arm64</code> 环境下，一个结构体指针的内存占用大小为 8 字节。而第三个属性 <code>cache</code> 则需要我们进行抽丝剥茧了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cache_t</span> cache;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span> <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;  <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">mask_t</span> _occupied; <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">mask_t</span>;</span><br></pre></td></tr></table></figure><p>从上面的代码我们可以看出，<code>cache</code> 属性其实是 <code>cache_t</code> 类型的结构体，其内部有一个 8 字节的结构体指针，有 2 个各为 4 字节的 <code>mask_t</code>。所以加起来就是 16 个字节。也就是说前三个属性总共的内存偏移量为 8 + 8 + 16 = 32 个字节，32 是 10 进制的表示，在 16 进制下就是 20。</p><h2 id="探索-bits-属性"><a href="#探索-bits-属性" class="headerlink" title="探索 bits 属性"></a>探索 <code>bits</code> 属性</h2><p>我们刚才在控制台打印输出了 <code>pClass</code> 类对象的内容，我们简单画个图如下所示:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022603.jpg" alt></p><p>那么，类的 <code>bits</code> 属性的内存地址顺理成章的就是在 <code>isa</code> 的初始偏移量地址处进行 16 进制下的 20 递增。也就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1000021c8 + 0x20 = 0x1000021e8</span><br></pre></td></tr></table></figure><p>我们尝试打印这个地址，注意这里需要强转一下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022621.jpg" alt></p><p>这里报错了，问题其实是出在我们的 <code>target</code> 没有关联上 <code>libobjc.A.dylib</code> 这个动态库，我们关联上重新运行项目</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022633.jpg" alt></p><p>我们重复一遍上面的流程:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022639.jpg" alt></p><p>这一次成功了。在 <code>objc_class</code> 源码中有:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class_rw_t</span> *data() &#123; </span><br><span class="line">    <span class="keyword">return</span> bits.data();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不妨打印一下里面的内容：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022649.jpg" alt></p><p>返回了一个 <code>class_rw_t</code> 指针对象。我们在 <code>objc4-756</code> 源码中搜索 <code>class_rw_t</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;</span><br><span class="line">    <span class="keyword">property_array_t</span> properties;</span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    </span><br><span class="line">    ...省略代码...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然的，<code>class_rw_t</code> 也是一个结构体类型，其内部有 <code>methods</code>、<code>properties</code>、<code>protocols</code> 等我们十分熟悉的内容。我们先猜想一下，我们的属性应该存放在 <code>class_rw_t</code> 的 <code>properties</code> 里面。为了验证我们的猜想，我们接着进行 <code>LLDB</code> 打印:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022702.jpg" alt></p><p>我们再接着打印 <code>properties</code>:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022708.jpg" alt></p><p><code>properties</code> 居然是空的，难道是 bug?其实不然，这里我们还漏掉了一个非常重要的属性 <code>ro</code>。我们来到它的定义:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line"></span><br><span class="line">    ...隐藏代码...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ro</code> 的类型是 <code>class_ro_t</code> 结构体，它包含了 <code>baseMethodList</code>、<code>baseProtocols</code>、<code>ivars</code>、<code>baseProperties</code> 等属性。我们刚才在 <code>class_rw_t</code> 中没有找到我们声明在 <code>Person</code> 类中的实例变量 <code>hobby</code> 和属性 <code>nickName</code>，那么希望就在 <code>class_ro_t</code> 身上了，我们打印看看它的内容:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022719.jpg" alt></p><p>根据名称我们猜测属性应该在 <code>baseProperties</code> 里面，我们打印看看:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022728.jpg" alt></p><p>Bingo! 我们的属性 <code>nickName</code> 被找到了，那么我们的实例变量 <code>hobby</code> 呢？我们从 $8 的 count 为 1 可以得知肯定不在 <code>baseProperites</code> 里面。根据名称我们猜测应该是在 <code>ivars</code> 里面。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022739.jpg" alt></p><p>哈哈，<code>hobby</code> 实例变量也被我们找到了，不过这里的 <code>count</code> 为什么是 2 呢？我们打印第二个元素看看:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022750.jpg" alt></p><p>结果为 <code>_nickName</code>。这一结果证实了编译器会帮助我们给属性 <code>nickName</code> 生成一个带下划线前缀的实例变量 <code>_nickName</code>。</p><p>至此，我们可以得出以下结论:</p><blockquote><p><code>class_ro_t</code> 是在编译时就已经确定了的，存储的是类的成员变量、属性、方法和协议等内容。<br><code>class_rw_t</code> 是可以在运行时来拓展类的一些属性、方法和协议等内容。</p></blockquote><h1 id="类的方法存在哪？"><a href="#类的方法存在哪？" class="headerlink" title="类的方法存在哪？"></a>类的方法存在哪？</h1><p>研究完了类的属性是怎么存储的，我们再来看看类的方法。</p><p>我们先给我们的 <code>Person</code> 类增加一个 <code>sayHello</code> 的实例方法和一个 <code>sayHappy</code> 的类方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.h</span></span><br><span class="line">- (<span class="keyword">void</span>)sayHello;</span><br><span class="line">+ (<span class="keyword">void</span>)sayHappy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person.m</span></span><br><span class="line">- (<span class="keyword">void</span>)sayHello</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sayHappy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上面的思路，我们直接读取 <code>class_ro_t</code> 中的 <code>baseMethodList</code> 的内容:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022801.jpg" alt></p><p><code>sayHello</code> 被打印出来了，说明 <code>baseMethodList</code> 就是存储实例方法的地方。我们接着打印剩下的内容:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022806.jpg" alt></p><p>可以看到 <code>baseMethodList</code> 中除了我们的实例方法 <code>sayHello</code> 外，还有属性 <code>nickName</code> 的 <code>getter</code> 和 <code>setter</code> 方法以及一个 <code>C++</code> 析构方法。但是我们的类方法 <code>sayHappy</code> 并没有被打印出来。</p><h1 id="类的类方法存在哪？"><a href="#类的类方法存在哪？" class="headerlink" title="类的类方法存在哪？"></a>类的类方法存在哪？</h1><p>我们上面已经得到了属性，实例方法的是怎么样存储，还留下了一个疑问点，就是类方法是怎么存储的，接下来我们用 <code>Runtime</code> 的 API 来实际测试一下。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="keyword">void</span> testInstanceMethod_classToMetaclass(Class pClass)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *className = class_getName(pClass);</span><br><span class="line">    Class metaClass = objc_getMetaClass(className);</span><br><span class="line">    </span><br><span class="line">    Method method1 = class_getInstanceMethod(pClass, <span class="keyword">@selector</span>(sayHello));</span><br><span class="line">    Method method2 = class_getInstanceMethod(metaClass, <span class="keyword">@selector</span>(sayHello));</span><br><span class="line"></span><br><span class="line">    Method method3 = class_getInstanceMethod(pClass, <span class="keyword">@selector</span>(sayHappy));</span><br><span class="line">    Method method4 = class_getInstanceMethod(metaClass, <span class="keyword">@selector</span>(sayHappy));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p-%p-%p-%p"</span>,method1,method2,method3,method4);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        Class pClass = object_getClass(p);</span><br><span class="line">        </span><br><span class="line">        testInstanceMethod_classToMetaclass(pClass);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后打印结果如下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022824.jpg" alt></p><p>首先 <code>testInstanceMethod_classToMetaclass</code> 方法测试的是分别从类和元类去获取实例方法、类方法的结果。由打印结果我们可以知道：</p><ul><li>对于类对象来说，<code>sayHello</code> 是实例方法，存储于类对象的内存中，不存在于元类对象中。而 <code>sayHappy</code> 是类方法，存储于元类对象的内存中，不存在于类对象中。</li><li>对于元类对象来说，<code>sayHello</code> 是类对象的实例方法，跟元类没关系；<code>sayHappy</code> 是元类对象的实例方法，所以存在元类中。</li></ul><p>我们再接着测试:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="keyword">void</span> testClassMethod_classToMetaclass(Class pClass)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *className = class_getName(pClass);</span><br><span class="line">    Class metaClass = objc_getMetaClass(className);</span><br><span class="line">    </span><br><span class="line">    Method method1 = class_getClassMethod(pClass, <span class="keyword">@selector</span>(sayHello));</span><br><span class="line">    Method method2 = class_getClassMethod(metaClass, <span class="keyword">@selector</span>(sayHello));</span><br><span class="line"></span><br><span class="line">    Method method3 = class_getClassMethod(pClass, <span class="keyword">@selector</span>(sayHappy));</span><br><span class="line">    Method method4 = class_getClassMethod(metaClass, <span class="keyword">@selector</span>(sayHappy));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p-%p-%p-%p"</span>,method1,method2,method3,method4);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        Class pClass = object_getClass(p);</span><br><span class="line">        </span><br><span class="line">        testClassMethod_classToMetaclass(pClass);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后打印结果如下:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022834.jpg" alt></p><p>从结果我们可以看出，对于类对象来说，通过 <code>class_getClassMethod</code> 获取 <code>sayHappy</code> 是有值的，而获取 <code>sayHello</code> 是没有值的；对于元类对象来说，通过 <code>class_getClassMethod</code> 获取 <code>sayHappy</code> 也是有值的，而获取 <code>sayHello</code> 是没有值的。这里第一点很好理解，但是第二点会有点让人糊涂，不是说类方法在元类中是体现为对象方法的吗？怎么通过 <code>class_getClassMethod</code> 从元类中也能拿到 <code>sayHappy</code>，我们进入到 <code>class_getClassMethod</code> 方法内部可以解开这个疑惑:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Method <span class="title">class_getClassMethod</span><span class="params">(Class cls, SEL sel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls  ||  !sel) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> class_getInstanceMethod(cls-&gt;getMeta(), sel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Class <span class="title">getMeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isMetaClass()) <span class="keyword">return</span> (Class)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>-&gt;ISA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很清楚的看到，<code>class_getClassMethod</code> 方法底层其实调用的是 <code>class_getInstanceMethod</code>，而 <code>cls-&gt;getMeta()</code> 方法底层的判断逻辑是如果已经是元类就返回，如果不是就返回类的 <code>isa</code>。这也就解释了上面的 <code>sayHappy</code> 为什么会出现在最后的打印中了。</p><p>除了上面的 <code>LLDB</code> 打印，我们还可以通过 <code>isa</code> 的方式来验证类方法存放在元类中。</p><ul><li>通过 isa 在类对象中找到元类</li><li>打印元类的 baseMethodsList</li></ul><p>具体的过程笔者不再赘述。</p><h1 id="类和元类的创建时机"><a href="#类和元类的创建时机" class="headerlink" title="类和元类的创建时机"></a>类和元类的创建时机</h1><p>我们在探索类和元类的时候，对于其创建时机还不是很清楚，这里我们先抛出结论：</p><ul><li>类和元类是在编译期创建的，即在进行 alloc 操作之前，类和元类就已经被编译器创建出来了。</li></ul><p>那么如何来证明呢，我们有两种方式可以来证明:</p><ul><li><code>LLDB</code> 打印类和元类的指针</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022845.jpg" alt></p><ul><li>编译项目后，使用 <code>MachoView</code> 打开程序二进制可执行文件查看:</li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022852.jpg" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>类和元类创建于编译时，可以通过 <code>LLDB</code> 来打印类和元类的指针，或者 <code>MachOView</code> 查看二进制可执行文件</li><li>万物皆对象：类的本质就是对象</li><li>类在 <code>class_ro_t</code> 结构中存储了编译时确定的属性、成员变量、方法和协议等内容。</li><li>实例方法存放在类中</li><li>类方法存放在元类中</li></ul><p>我们完成了对 <code>iOS</code> 中类的底层探索，下一章我们将对类的缓存进行深一步探索，敬请期待~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在前面探索了 &lt;code&gt;iOS&lt;/code&gt; 中的对象原理，面向对象编程中有一句名言:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;万物皆对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么对象又是从哪来的呢？有过面向对象编程基础的同学肯定都知道是类派生出对象的，那么今天我们就一起来探索一下类的底层原理吧。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - calloc&amp;isa</title>
    <link href="http://leejunhui.com/2020/01/05/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-calloc-isa/"/>
    <id>http://leejunhui.com/2020/01/05/iOS-底层探索-calloc-isa/</id>
    <published>2020-01-05T03:37:49.000Z</published>
    <updated>2020-01-18T18:22:01.589Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章主要我们探索了 <code>iOS</code>  对象的 <code>alloc</code> 和 <code>init</code> 以及对象是怎么开辟内存以及初始化的，如果在对象身上增加一些属性，是否会影响内存开辟呢？还有一个遗留问题就是通过 <code>calloc</code> ，我们的对象有了内存地址，但是对象结构里面的 <code>isa</code> 是怎么关联到我们的对象的内存地址的呢。</p><a id="more"></a><h1 id="calloc-底层探索"><a href="#calloc-底层探索" class="headerlink" title="calloc 底层探索"></a><code>calloc</code> 底层探索</h1><p>在探索 <code>calloc</code> 底层前，我们先补充一下内存对齐相关的知识点。</p><h2 id="内存对齐三原则"><a href="#内存对齐三原则" class="headerlink" title="内存对齐三原则"></a>内存对齐三原则</h2><p>在 <code>iOS</code> 中，对象的属性需要进行内存对齐，而对象本身也需要进行内存对齐。<br>内存对齐有三原则</p><ul><li>数据成员对齐原则: 结构( <code>struct</code> )(或联合( <code>union</code> ))的数据成员，第<br><br>一个数据成员放在 offset 为 0 的地方，以后每个数据成员存储的起始位置要<br><br>从该成员大小或者成员的子成员大小</li><li>结构体作为成员: 如果一个结构里有某些结构体成员,则结构体成员要从<br><br>其内部最大元素大小的整数倍地址开始存储</li><li>收尾工作: 结构体的总大小,也就是 <code>sizeof</code> 的结果,.必须是其内部最大<br><br>成员的整数倍.不足的要补⻬。<br><br>翻译一下就是：</li><li><strong>前面的地址必须是后面的地址正数倍,不是就补齐</strong></li><li>结构体里面的嵌套结构体大小要以该<strong>嵌套结构体最大元素大小的整数倍</strong></li><li><strong>整个 **`</strong>Struct<strong>` **的地址必须是最大字节的整数倍</strong></li></ul><h2 id="对象申请内存和系统开辟内存"><a href="#对象申请内存和系统开辟内存" class="headerlink" title="对象申请内存和系统开辟内存"></a>对象申请内存和系统开辟内存</h2><p>我们通过打印下面的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%lu - %lu"</span>,class_getInstanceSize([p <span class="keyword">class</span>]),malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(p)));</span><br></pre></td></tr></table></figure><p>可以发现对象自己申请的内存大小与系统实际给我们开辟的大小时不一样的，这里对象申请的内存大小是 <strong>40</strong> 个字节，而系统开辟的是 <strong>48</strong> 个字节。</p><p>40 个字节不难理解，是因为当前对象有 4 个属性，有三个属性为 8 个字节，有一个属性为 4个字节，再加上 isa 的 8 个字节，就是 32 + 4 = 36 个字节，然后根据内存对齐原则，36 不能被 8 整除，36 往后移动刚好到了 40 就是 8 的倍数，所以内存大小为 40。</p><p>48 个字节的话需要我们探索 <code>calloc</code> 的底层原理。</p><p>这里还有一个注意点，就是 <code>class_getInstanceSize</code> 和 <code>malloc_size</code> 对同一个对象返回的结果不一样的，原因是 <code>malloc_size</code> 是直接返回的 <code>calloc</code> 之后的指针的大小，回忆上一节课，这里有一步在调用 <code>calloc</code> 之前的操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">    size_t size = alignedInstanceSize() + extraBytes;</span><br><span class="line">    // CF requires all objects be at least 16 bytes.</span><br><span class="line">    if (size &lt; 16) size = 16;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>class_getInstanceSize</code> 内部实现是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t class_getInstanceSize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return 0;</span><br><span class="line">    return cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 <code>class_getInstanceSize</code> 会输出 8 个字节，<code>malloc_size</code> 会输出 16 个字节，当然前提是该对象没有任何属性。</p><h2 id="探索-calloc-底层"><a href="#探索-calloc-底层" class="headerlink" title="探索 calloc 底层"></a>探索 calloc 底层</h2><p>我们从 <code>calloc</code> 函数出发，但是我们直接在 <code>libObjc</code> 的源码中是找不到其对应实现的，通过观察 Xcode 我们知道其实应该找 <code>libMalloc</code> 源码才对:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021547.jpg" alt></p><p>这里有个小技巧，其实我们研究的是 <code>calloc</code> 的底层原理，而 <code>libObjc</code> 和 <code>libMalloc</code> 是相互独立的，所以在 <code>libMalloc</code> 源码里面，我们没必要去走 <code>calloc</code> 前面的流程了。我们通过断点调试 <code>libObjc</code> 源码可以知道第二个参数是 40: (这是因为当前发送 <code>alloc</code> 消息的对象有 4 个属性，每个属性 8 个字节，再加上 isa 的 8 个字节，所以就是 40 个字节)</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021606.jpg" alt></p><p>接下来我们打开 <code>libMalloc</code> 的源码，在新建的 target 中直接手动声明如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *p = calloc(1, 40);</span><br><span class="line">NSLog(@&quot;%lu&quot;,malloc_size(p));</span><br></pre></td></tr></table></figure><p>但 <code>Command + Run</code> 之后我们会看到报错信息:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021741.jpg" alt></p><p>这个时候我们会使用搜索大法，直接 <code>Command + Shift + F</code> 进行全局搜索对应的符号，但是会发现找不到，我们再仔细观察，这些符号都是位于 <code>.o</code> 文件里面的，所以我们可以去掉符号前面的下划线再进行搜索，这个时候就可以把对应的代码注释然后重新运行了。</p><p>运行之后我们一直沿着源码断点下去，会来到这么一段代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = zone-&gt;calloc(zone, num_items, size);</span><br></pre></td></tr></table></figure><p>我们如果直接去找 <code>calloc</code>，就会递归了，所以我们需要点进去，然后我们会发现一个很复杂的东西出现了:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021755.jpg" alt></p><p>这里我们可以直接在断点处使用 <code>LLDB</code> 命令打印这行代码来看具体实现是位于哪个文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p zone-&gt;calloc</span><br><span class="line">输出: (void *(*)(_malloc_zone_t *, size_t, size_t)) $1 = 0x00000001003839c7 (.dylib`default_zone_calloc at malloc.c:249)</span><br></pre></td></tr></table></figure><p>也就是说 <code>zone-&gt;alloc</code> 的真正实现是在 <code>malloc.c</code> 源文件的249行处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">default_zone_calloc(<span class="keyword">malloc_zone_t</span> *zone, <span class="keyword">size_t</span> num_items, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">zone = runtime_default_zone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> zone-&gt;<span class="built_in">calloc</span>(zone, num_items, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们发现这里又是一次 <code>zone-&gt;calloc</code>，我们接着再次使用 <code>LLDB</code> 打印内存地址:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p zone-&gt;calloc</span><br><span class="line">输出: (void *(*)(_malloc_zone_t *, size_t, size_t)) $0 = 0x0000000100384faa (.dylib`nano_calloc at nano_malloc.c:884)</span><br></pre></td></tr></table></figure><p>我们再次来到 <code>nano_calloc</code> 方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">nano_calloc(nanozone_t *nanozone, size_t num_items, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">size_t total_bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (calloc_get_size(num_items, size, <span class="number">0</span>, &amp;total_bytes)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (total_bytes &lt;= NANO_MAX_SIZE) &#123;</span><br><span class="line"><span class="keyword">void</span> *p = _nano_malloc_check_clear(nanozone, total_bytes, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* FALLTHROUGH to helper zone */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">malloc_zone_t *zone = (malloc_zone_t *)(nanozone-&gt;helper_zone);</span><br><span class="line"><span class="keyword">return</span> zone-&gt;calloc(zone, <span class="number">1</span>, total_bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们简单分析一下，应该往 <code>_nano_malloc_check_clear</code> 里面继续走，然后我们发现 <code>_nano_malloc_check_clear</code> 里面内容非常多，这个时候我们要明确一点，我们的目的是找出 48 是怎么算出来的，经过分析之后，我们来到 <code>segregated_size_to_fit</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MALLOC_INLINE <span class="keyword">size_t</span></span><br><span class="line">segregated_size_to_fit(<span class="keyword">nanozone_t</span> *nanozone, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> *pKey)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// size = 40</span></span><br><span class="line"><span class="keyword">size_t</span> k, slot_bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == size) &#123;</span><br><span class="line">size = NANO_REGIME_QUANTA_SIZE; <span class="comment">// Historical behavior</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 40 + 16-1 &gt;&gt; 4 &lt;&lt; 4</span></span><br><span class="line"><span class="comment">// 40 - 16*3 = 48</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 16</span></span><br><span class="line">k = (size + NANO_REGIME_QUANTA_SIZE - <span class="number">1</span>) &gt;&gt; SHIFT_NANO_QUANTUM; <span class="comment">// round up and shift for number of quanta</span></span><br><span class="line">slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM;<span class="comment">// multiply by power of two quanta size</span></span><br><span class="line">*pKey = k - <span class="number">1</span>;<span class="comment">// Zero-based!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slot_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出进行的是 16 字节对齐，那么也就是说我们传入的 <code>size</code> 是 40，在经过 (40 + 16 - 1) &gt;&gt; 4 &lt;&lt; 4 操作后，结果为48，也就是16的整数倍。</p><p>总结:</p><ul><li>对象的属性是进行的 8 字节对齐</li><li>对象自己进行的是 16 字节对齐<ul><li>因为内存是连续的，通过 16 字节对齐规避风险和容错，防止访问溢出</li><li>同时，也提高了寻址访问效率，也就是<strong>空间换时间</strong></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021811.jpg" alt></p><h1 id="isa-底层探索"><a href="#isa-底层探索" class="headerlink" title="isa 底层探索"></a><code>isa</code> 底层探索</h1><h2 id="联合体位域"><a href="#联合体位域" class="headerlink" title="联合体位域"></a>联合体位域</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"><span class="meta">#if defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们探索 <code>isa</code> 的时候，会发现 <code>isa</code> 其实是一个联合体，而这其实是从内存管理层面来设计的，因为联合体是所有成员共享一个内存，联合体内存的大小取决于内部成员内存大小最大的那个元素，对于 <code>isa</code> 指针来说，就不用额外声明很多的属性，直接在内部的 <code>ISA_BITFIELD</code> 保存信息。同时由于联合体属性间是互斥的，所以 <code>cls</code> 和 <code>bits</code> 在 <code>isa</code> 初始化流程时是在两个分支中被赋值的。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021845.jpg" alt></p><h2 id="isa-结构"><a href="#isa-结构" class="headerlink" title="isa 结构"></a>isa 结构</h2><p><code>isa</code> 作为一个联合体，有一个结构体属性为 <code>ISA_BITFIELD</code>，其大小为 8 个字节，也就是 64 位。<br>下面的代码是基于 <code>arm64</code> 架构的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                      \</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span><br><span class="line">      <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                       \</span><br><span class="line">      <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span></span><br></pre></td></tr></table></figure><ul><li><code>nonpointer</code>: 表示是否对 <code>isa</code> 指针开启指针优化<ul><li>0: 纯 <code>isa</code> 指针</li><li>1: 不止是类对象地址, <code>isa</code> 中包含了类信息、对象的引用计数等</li></ul></li><li>has_assoc: 关联对象标志位，0 没有，1 存在</li><li>has_cxx_dtor: 该对象是否有 C++ 或者 Objc 的析构器,如果有析构函数,则需要做析构逻辑, 如果没有,则可以更快的释放对象</li><li>shiftcls: 存储类指针的值。开启指针优化的情况下，在 arm64 架构中有 33 位用来存储类指针。</li><li>magic: 用于调试器判断当前对象是真的对象还是没有初始化的空间</li><li>weakly_referenced: 标志对象是否被指向或者曾经指向一个 ARC 的弱变量，<br><br>没有弱引用的对象可以更快释放。</li><li>deallocating: 标志对象是否正在释放内存</li><li>has_sidetable_rc: 当对象引用技术大于 10 时，则需要借用该变量存储进位</li><li>extra_rc: 当表示该对象的引用计数值，实际上是引用计数值减 1， 例如，如果对象的引用计数为 10，那么 extra_rc 为 9。如果引用计数大于 10， 则需要使用到下面的 has_sidetable_rc。</li></ul><h2 id="isa-关联对象和类"><a href="#isa-关联对象和类" class="headerlink" title="isa 关联对象和类"></a>isa 关联对象和类</h2><p><code>isa</code> 是对象中的第一个属性，因为这一步是在继承的时候发生的，要早于对象的成员变量，属性列表，方法列表以及所遵循的协议列表。</p><p>我们在探索 <code>alloc</code> 底层原理的时候，有一个方法叫做 <code>initIsa</code>。</p><p>这个方法的作用就是初始化 <code>isa</code> 联合体位域。其中有这么一行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newisa.shiftcls = (<span class="keyword">uintptr_t</span>)cls &gt;&gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>通过这行代码，我们知道 <code>shiftcls</code> 这个位域其实存储的是类的信息。这个类就是实例化对象所指向的那个类。</p><p>通过 <code>LLDB</code> 进行调试打印，我们可以知道一个对象的 <code>isa</code> 会关联到这个对象所属的类。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021910.jpg" alt></p><p>这里的左移右移操作其实很好理解，首先我们先观察 <code>isa</code> 的 <code>ISA_BITFIELD</code> 位域的结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注：这里是x64架构</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_BITFIELD                                                        \</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/</span> \</span><br><span class="line">      <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                         \</span><br><span class="line">      <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span></span><br></pre></td></tr></table></figure><p>我们可以看到，<code>ISA_BITFIELD</code> 的前 3 位是 <code>nonpointer</code>，<code>has_assoc</code>，<code>has_cxx_dtor</code>，中间 44 位是 <code>shiftcls</code> ，后面 17 位是剩余的内容，同时因为 iOS 是小端模式，那么我们就需要去掉右边的 3 位和左边的 17位，所以就会采用 &gt;&gt;3&lt;&lt;3 然后 &lt;&lt;17&gt;&gt;17 的操作了。</p><p>通过这个测试，我们就知道了 <code>isa</code> 实现了对象与类之间的关联。</p><p>我们还可以探索 <code>object_getClass</code> 底层，可以发现有这样一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return (Class)(isa.bits &amp; ISA_MASK);</span><br></pre></td></tr></table></figure><p>这行代码就是将 <code>isa</code> 中的联合体位域与上一个蒙版，这个蒙版定义是怎么样的呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br></pre></td></tr></table></figure><p><code>0x00007ffffffffff8ULL</code> 这个值我们转成二进制表示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> </span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>结果一目了然，这个蒙版就是帮我们去过滤掉除 <code>shiftcls</code> 之外的内容。</p><p>我们直接将对象的 <code>isa</code> 地址与上这个mask之后，就会得到 <code>object.class</code> 一样的内存地址。</p><h2 id="isa-走位分析"><a href="#isa-走位分析" class="headerlink" title="isa 走位分析"></a>isa 走位分析</h2><h3 id="类与元类"><a href="#类与元类" class="headerlink" title="类与元类"></a>类与元类</h3><p>我们都知道对象可以创建多个，但是类是否可以创建多个呢?<br>答案很简单，一个。那么如果来验证呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//MARK: - 分析类对象内存存在个数</span><br><span class="line">void lgTestClassNum()&#123;</span><br><span class="line">    Class class1 = [LGPerson class];</span><br><span class="line">    Class class2 = [LGPerson alloc].class;</span><br><span class="line">    Class class3 = object_getClass([LGPerson alloc]);</span><br><span class="line">    Class class4 = [LGPerson alloc].class;</span><br><span class="line">    NSLog(@&quot;\n%p-\n%p-\n%p-\n%p&quot;,class1,class2,class3,class4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印输出如下:</span><br><span class="line"></span><br><span class="line">0x100002108-</span><br><span class="line">0x100002108-</span><br><span class="line">0x100002108-</span><br><span class="line">0x100002108</span><br></pre></td></tr></table></figure><p>所以我们就知道了类在内存中只会存在一份。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/4gx LGTeacher.class</span><br><span class="line">0x100001420: 0x001d8001000013f9 0x0000000100b38140</span><br><span class="line">0x100001430: 0x00000001003db270 0x0000000000000000</span><br><span class="line">(lldb) po 0x001d8001000013f9</span><br><span class="line">17082823967917874</span><br><span class="line"></span><br><span class="line">(lldb) p 0x001d8001000013f9</span><br><span class="line">(long) $2 = 8303516107936761</span><br><span class="line">(lldb) po 0x100001420</span><br><span class="line">LGTeacher</span><br></pre></td></tr></table></figure><p>我们通过上面的打印，就发现 类的内存结构里面的第一个结构打印出来还是 <code>LGTeacher</code>，那么是不是就意味着 对象-&gt;类-&gt;类 这样的死循环呢？这里的第二个类其实是 <code>元类</code>。是由系统帮我们创建的。这个元类也无法被我们实例化。</p><p>也就是下面的这种关系:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021925.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x 0x001d8001000013f9 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $4 = 0x00000001000013f8</span><br><span class="line">(lldb) po 0x00000001000013f8</span><br><span class="line">LGTeacher</span><br><span class="line"></span><br><span class="line">(lldb) x/4gx 0x00000001000013f8</span><br><span class="line">0x1000013f8: 0x001d800100b380f1 0x0000000100b380f0</span><br><span class="line">0x100001408: 0x0000000101c30230 0x0000000100000007</span><br><span class="line">(lldb) p/x 0x001d800100b380f1 &amp; 0x00007ffffffffff8</span><br><span class="line">(long) $6 = 0x0000000100b380f0</span><br><span class="line">(lldb) po 0x0000000100b380f0</span><br><span class="line">NSObject</span><br></pre></td></tr></table></figure><h3 id="isa-走位"><a href="#isa-走位" class="headerlink" title="isa 走位"></a>isa 走位</h3><p>我们在 Xcode 中测试有以下结果：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119021938.jpg" alt></p><p>由此可以给出官方的经典 <code>isa</code> 走位图</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022003.jpg" alt></p><h2 id="isa-初始化流程图"><a href="#isa-初始化流程图" class="headerlink" title="isa 初始化流程图"></a>isa 初始化流程图</h2><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022016.jpg" alt></p><h1 id="对象的本质"><a href="#对象的本质" class="headerlink" title="对象的本质"></a>对象的本质</h1><p>在我们认知里面，<code>OC</code> 对象的本质就是一个结构体，这个结论在 <code>libObjc</code> 源码的 <code>objc-private.h</code> 源文件中可以得到证实。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">ISA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    <span class="function">Class <span class="title">getIsa</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    ...省略其他的内容...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于对象所属的类来说，我们也可以在 <code>objc-runtime-new.h</code> 源文件中找到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">    </span><br><span class="line">    ...省略其他的内容...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 <code>objc_class</code> 内存中第一个位置是 <code>isa</code>，第二个位置是 <code>superclass</code>。</p><p>不过我们本着求真的态度可以用 <code>clang</code> 来重写我们的 <code>OC</code> 源文件来查看是不是这么回事。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure><p>这行命令会把我们的 <code>main.m</code> 文件编译成 <code>C++</code> 格式，输出为 <code>main.cpp</code>。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022040.jpg" alt></p><p>我们可以看到 <code>LGPerson</code> 对象在底层其实是一个结构体 <code>objc_object</code> 。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119022051.jpg" alt></p><p>而我们的 <code>Class</code> 在底层也是一个结构体 <code>objc_class</code> 。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此， <code>iOS</code> 底层探索之对象篇更新完毕，现在来回顾一下我们所探索的内容。</p><ul><li>alloc &amp; init 流程剖析</li><li>内存开辟</li><li>字节对齐算法</li><li>isa 初始化和走位</li><li>对象的本质</li></ul><p>下一篇章我们要探索篇章的是类，敬请期待~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章主要我们探索了 &lt;code&gt;iOS&lt;/code&gt;  对象的 &lt;code&gt;alloc&lt;/code&gt; 和 &lt;code&gt;init&lt;/code&gt; 以及对象是怎么开辟内存以及初始化的，如果在对象身上增加一些属性，是否会影响内存开辟呢？还有一个遗留问题就是通过 &lt;code&gt;calloc&lt;/code&gt; ，我们的对象有了内存地址，但是对象结构里面的 &lt;code&gt;isa&lt;/code&gt; 是怎么关联到我们的对象的内存地址的呢。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层探索 - alloc&amp;init</title>
    <link href="http://leejunhui.com/2020/01/05/iOS-%E5%BA%95%E5%B1%82%E6%8E%A2%E7%B4%A2-alloc-init/"/>
    <id>http://leejunhui.com/2020/01/05/iOS-底层探索-alloc-init/</id>
    <published>2020-01-05T03:17:38.000Z</published>
    <updated>2020-01-18T18:09:31.744Z</updated>
    
    <content type="html"><![CDATA[<p>作为 <code>iOS</code> 开发者，我们每天打交道最多的应该就是对象了，从面向对象设计的角度来说，对象的创建以及初始化是最基础的内容。那么，今天我们就一起来探索一下 <code>iOS</code> 中最常用的 <code>alloc</code> 和 <code>init</code>  的底层是怎么实现的吧。</p><a id="more"></a><h1 id="如何进行底层探索"><a href="#如何进行底层探索" class="headerlink" title="如何进行底层探索"></a>如何进行底层探索</h1><p>对于第三方开源框架来说，我们去剖析内部原理和细节是有一定的方法和套路可以掌握的。而对于 <code>iOS</code>  底层，特别是 <code>OC</code> 底层，我们可能就需要用到一些开发中不是很常用的方法。</p><p>我们这个系列主要的目的是为了进行底层探索，那么我们作为 <code>iOS</code> 开发者，需要关注应该就是从应用启动到应用被 <code>kill</code> 掉这一整个生命周期的内容。我们不妨从我们最熟悉的 <code>main</code> 函数开始，一般来说，我们在 <code>main.m</code> 文件中打一个断点，左侧的调用堆栈视图应该如下图所示:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200118231019.jpg" alt></p><blockquote><p>要得到这样的调用堆栈有两个注意点:</p><ul><li>需要关闭 <code>Xcode</code> 左侧 <code>Debug</code> 区域最下面的 <code>show only stack frames with debug symbols and between libraries</code></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200118231041.jpg" alt></p><blockquote><ul><li>需要增加一个 <code>_objc_init</code> 的符号端点</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200118234802.jpg" alt></p><p>我们通过上面的调用堆栈信息不难得出一个简单粗略的加载流程结构</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200118231138.jpg" alt></p><p>我们现在心中建立这么一个简单的流程结构，在后期分析底层的时候我们会回过头来梳理整个启动的流程。</p><p>接下来，让我们开始实际的探索过程。</p><p>我们直接打开 <code>Xcode</code> 新建一个 <code>Single View App</code> 工程，然后我们在 <code>ViewController.m</code> 文件中调用 <code>alloc</code> 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *p = [<span class="built_in">NSObject</span> alloc];</span><br></pre></td></tr></table></figure><p>我们按照常规探索源码的方式，直接按住 <code>Command</code> + <code>Control</code> 来进入到 <code>alloc</code> 内部实现，但结果并非如我们所愿，我们来到的是一个头文件，只有 <code>alloc</code> 方法的声明，并没有对应的实现。这个时候，我们会陷入深深的怀疑中，其实这个时候我们只要记住下面三种常用探索方式就能迎刃而解：</p><h2 id="直接下代码断点"><a href="#直接下代码断点" class="headerlink" title="直接下代码断点"></a>直接下代码断点</h2><p>具体操作方式为 <code>Control</code> + <code>in</code> </p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119014943.jpg" alt><br> 这里的 <code>in</code> 指的是左侧图片中红色部分的按钮，其实这里的操作叫做 <code>Step into instruction</code> 。我们可以来到下图这里</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119014959.jpg" alt></p><p>我们观察不难得出我们想要找的就是 <code>libobjc.A.dylib</code> 这个动态链接库了。</p><h2 id="打开反汇编显示"><a href="#打开反汇编显示" class="headerlink" title="打开反汇编显示"></a>打开反汇编显示</h2><p>具体操作方式为打开 <code>Debug</code> 菜单下的 <code>Debug Workflow</code> 下的 <code>Always Show Disassembly</code> </p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119015038.jpg" alt></p><p>接着我们还是下代码断点，然后一步一步调试也会来到下图这里:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119015127.jpg" alt></p><h2 id="下符号断点"><a href="#下符号断点" class="headerlink" title="下符号断点"></a>下符号断点</h2><p>我们先选择 <code>Symbolic Breakpoint</code>，然后输入 <code>objc_alloc</code> ，如下图所示：</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119015148.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119015201.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119015214.jpg" alt></p><p>至此，我们得到了 <code>alloc</code> 实现位于 <code>libObjc</code> 这个动态库，而刚好苹果已经开源了这部分的代码，所以我们可以在 <a href="https://opensource.apple.com/release/macos-10145.html" target="_blank" rel="noopener">苹果开源官网 最新版本 10.14.5</a> 上下载即可。最新的 <code>libObc</code> 为 756。</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119015229.jpg" alt></p><h1 id="探索-libObjc-源码"><a href="#探索-libObjc-源码" class="headerlink" title="探索 libObjc 源码"></a>探索 <code>libObjc</code> 源码</h1><p>我们下载了 <code>libObjc</code> 的源码到我们的电脑上后是不能直接运行的，我们需要进行一定的配置才能实现源码追踪流程。这一块内容不在本文范围内，读者可参考 <a href="https://juejin.im/post/5d9c829df265da5ba46f49c9" target="_blank" rel="noopener">iOS_objc4-756.2 最新源码编译调试</a>。</p><p>配置好 <code>libObjc</code> 之后，我们新建一个命令行的项目，然后运行如下代码:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *myObj = [<span class="built_in">NSObject</span> alloc];</span><br></pre></td></tr></table></figure><h2 id="objc-alloc"><a href="#objc-alloc" class="headerlink" title="objc_alloc"></a>objc_alloc</h2><p>然后我们直接下符号断点 <code>objc_alloc</code> ，然后一步步调试，先来到的是 <code>objc_alloc</code> </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calls [cls alloc].</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_alloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> callAlloc(cls, <span class="literal">true</span><span class="comment">/*checkNil*/</span>, <span class="literal">false</span><span class="comment">/*allocWithZone*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第一次-callAlloc"><a href="#第一次-callAlloc" class="headerlink" title="第一次 callAlloc"></a>第一次 callAlloc</h2><p>然后会来到 <code>callAlloc</code> 方法，注意这里第三个参数传的是 <code>false</code> </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span></span><br><span class="line">callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断传入的 checkNil 是否进行判空操作</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前编译环境为 OC 2.0</span></span><br><span class="line"><span class="meta">#if __OBJC2__</span></span><br><span class="line">    <span class="comment">// 当前类没有自定义的 allocWithZone</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        <span class="comment">// No alloc/allocWithZone implementation. Go straight to the allocator.</span></span><br><span class="line">        <span class="comment">// 既没有实现 alloc，也没有实现 allocWithZone 就会来到这里，下面直接进行内存开辟操作。</span></span><br><span class="line">        <span class="comment">// fixme store hasCustomAWZ in the non-meta class and </span></span><br><span class="line">        <span class="comment">// add it to canAllocFast's summary</span></span><br><span class="line">        <span class="comment">// 修复没有元类的类，用人话说就是没有继承于 NSObject</span></span><br><span class="line">        <span class="comment">// 判断当前类是否可以快速开辟内存，注意，这里永远不会被调用，因为 canAllocFast 内部</span></span><br><span class="line">        <span class="comment">// 返回的是false</span></span><br><span class="line">        <span class="keyword">if</span> (fastpath(cls-&gt;canAllocFast())) &#123;</span><br><span class="line">            <span class="comment">// No ctors, raw isa, etc. Go straight to the metal.</span></span><br><span class="line">            <span class="keyword">bool</span> dtor = cls-&gt;hasCxxDtor();</span><br><span class="line">            <span class="keyword">id</span> obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, cls-&gt;bits.fastInstanceSize());</span><br><span class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</span><br><span class="line">            obj-&gt;initInstanceIsa(cls, dtor);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Has ctor or raw isa or something. Use the slower path.</span></span><br><span class="line">            <span class="keyword">id</span> obj = class_createInstance(cls, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) <span class="keyword">return</span> [cls allocWithZone:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> [cls alloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="objc-rootAlloc"><a href="#objc-rootAlloc" class="headerlink" title="_objc_rootAlloc"></a>_objc_rootAlloc</h2><p>因为我们在 <code>objc_init</code>  中传入的第三个参数 <code>allocWithZone</code> 是 <code>true</code> ，并且我们的 <code>cls</code> 为 <code>NSObject</code> ，那么也就是说会这里直接来到 <code>return [cls alloc]</code> 。我们接着往下走会来到 <code>alloc</code> 方法：<br> </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)alloc &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAlloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们接着进入 <code>_objc_rootAlloc</code> 方法内部:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base class implementation of +alloc. cls is not nil.</span></span><br><span class="line"><span class="comment">// Calls [cls allocWithZone:nil].</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> callAlloc(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二次-callAlloc"><a href="#第二次-callAlloc" class="headerlink" title="第二次 callAlloc"></a>第二次 callAlloc</h2><p>是不是有点似曾相似，没错，我们第一步进入的 <code>objc_init</code> 也是调用的 <code>callAlloc</code> 方法，但是这里有两个参数是不一样的，第二个参数 <code>checkNil</code> 是否需要判空直接传的是 <code>false</code> ，站在系统角度，前面已经在第一次调用 <code>callAlloc</code>  的时候进行了判空了，所以这里没必要再次进行判空的了。第三个参数 <code>allocWithZone</code> 传的是 <code>true</code> ，关于这个方法，我查阅了苹果开发者文档，文档解释如下:</p><blockquote><p>Do not override <code>allocWithZone:</code> to include any initialization code. Instead, class-specific versions of <code>init...</code> methods.<br>This method exists for historical reasons; memory zones are no longer used by Objective-C.<br>译：不要去重载 <code>allocWithZone</code> 并在其内部填充任何初始化代码，相反的，应该在 <code>init...</code> 里面进行类的初始化操作。<br>这个方法的存在是有历史原因的，内存 <code>zone</code> 已经不再被 <code>Objective-C</code> 所使用的。</p></blockquote><p>按照苹果开发者文档的说法，其实 <code>allocWithZone</code> 本质上和 <code>alloc</code> 是没有区别的，只是在 <code>Objective-C</code> 远古时代，程序员需要使用诸如 <code>allocWithZone</code> 来优化对象的内存结构，而在当下，其实你写 <code>alloc</code> 和 <code>allocWithZone</code> 在底层是一模模一样样的。</p><p>好的，话题扯远了，我们接着再次进入到 <code>callAlloc</code> 方法内部，第二次来到 <code>callAlloc</code> 的话，在 <code>!cls-&gt;ISA()-&gt;hasCustomAWZ()</code> 这里判断 <code>cls</code> 没有自定义的 <code>allocWithZone</code> 实现，这里的判断实质上是对 <code>cls</code> 也就是 <code>object_class</code> 这一结构体内部的 <code>class_rw_t</code> 的 <code>flags</code> 与上一个宏 <code>RW_HAS_DEFAULT_AWZ</code> 。经过笔者测试，在第一次进入 <code>callAlloc</code> 方法内部的时候， <code>flags</code> 值为 1 ，然后  <code>flags</code> 与上 <code>1&lt;&lt;16</code> 结果就是 0 ，返回过去也就是 <code>false</code> ，然后在 <code>hasCustomAWZ</code> 这里取反之后，返回的就是 <code>true</code> ，然后再一取反，自然就会跳过 <code>if</code> 里面的逻辑；而第二次进入 <code>callAlloc</code> 方法内部的时候， <code>flags</code> 值是一个很大的整数，与上 <code>1&lt;&lt;16</code> 后结果并不为0 ，所以 <code>hasDefaultAWZ</code> 会返回 <code>true</code> ，那么 <code>hasCustomAWZ</code> 这里就会返回 <code>false</code> ，那么返回到 <code>callAlloc</code> 的时候自然就会进入 <code>if</code> 里面的逻辑了。</p><blockquote><p>这里插一句，在我们 OC 的类的结构中，有一个结构叫 <code>class_rw_t</code> ，有一个结构叫 <code>class_ro_t</code> 。其中 <code>class_rw_t</code> 是可以在运行时去拓展类的，包括属性，方法、协议等等，而 <code>class_ro_t</code> 则存储了成员变量，属性和方法等，不过这些是在编译时就确定了的，不能在运行时去修改。</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> hasCustomAWZ() &#123;</span><br><span class="line">   <span class="keyword">return</span> ! bits.hasDefaultAWZ();</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> hasDefaultAWZ() &#123;</span><br><span class="line"><span class="keyword">return</span> data()-&gt;flags &amp; RW_HAS_DEFAULT_AWZ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们会来到 <code>canAllocFast</code> 的判断，我们继续进入该方法内部</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fastpath(cls-&gt;canAllocFast()))</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> canAllocFast() &#123;</span><br><span class="line">    assert(!isFuture());</span><br><span class="line">    <span class="keyword">return</span> bits.canAllocFast();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> canAllocFast() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果很显然，这里 <code>canAllocFast</code> 是一直返回 <code>false</code> 的，也就是说会直接来到下面的逻辑</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = class_createInstance(cls, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</span><br><span class="line"><span class="keyword">return</span> obj;</span><br></pre></td></tr></table></figure><p>我们再次进入 <code>class_createInstance</code> 方法内部</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> </span><br><span class="line">class_createInstance(Class cls, size_t extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __attribute__((always_inline)) </span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="keyword">void</span> *zone, </span><br><span class="line">                              <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>, </span><br><span class="line">                              size_t *outAllocatedSize = <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对 cls 进行判空操作</span></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">// 断言 cls 是否实现了</span></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read class's info bits all at once for performance</span></span><br><span class="line">    <span class="comment">// cls 是否有 C++ 的初始化构造器</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxCtor = cls-&gt;hasCxxCtor();</span><br><span class="line">    <span class="comment">// cls 是否有 C++ 的析构器</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class="line">    <span class="comment">// cls 是否可以分配 Nonpointer，如果是，即代表开启了内存优化 </span></span><br><span class="line">    <span class="keyword">bool</span> fast = cls-&gt;canAllocNonpointer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里传入的 extraBytes 为0，然后获取 cls 的实例内存大小</span></span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="comment">// 这里 outAllocatedSize 是默认值 nil，跳过</span></span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> obj;</span><br><span class="line">    <span class="comment">// 这里 zone 传入的也是nil，而 fast 拿到的是 true，所以会进入这里的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">        <span class="comment">// 根据 size 开辟内存</span></span><br><span class="line">        obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, size);</span><br><span class="line">        <span class="comment">// 如果开辟失败，返回 nil</span></span><br><span class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">// 将 cls 和是否有 C++ 析构器传入给 initInstanceIsa，实例化 isa</span></span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 zone 不为空，经过笔者测试，一般来说调用 alloc 不会来到这里，只有 allocWithZone</span></span><br><span class="line">        <span class="comment">// 或 copyWithZone 会来到下面的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">            <span class="comment">// 根据给定的 zone 和 size 开辟内存</span></span><br><span class="line">            obj = (<span class="keyword">id</span>)malloc_zone_calloc ((malloc_zone_t *)zone, <span class="number">1</span>, size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根据 size 开辟内存</span></span><br><span class="line">            obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果开辟失败，返回 nil</span></span><br><span class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be </span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">        <span class="comment">// 初始化 isa</span></span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有 C++ 初始化构造器和析构器，进行优化加速整个流程</span></span><br><span class="line">    <span class="keyword">if</span> (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span><br><span class="line">        obj = _objc_constructOrFree(obj, cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最终的结果</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们的 <code>alloc</code> 流程就探索完毕，但在这其中我们还是有一些疑问点，比如，对象的内存大小时怎么确定出来的， <code>isa</code> 是怎么初始化出来的呢，没关系，我们下一篇接着探索。这里，先给出笔者自己画的一个 <code>alloc</code> 流程图:</p><p><img src="https://raw.githubusercontent.com/LeeJunhui/blog_images/master/20200119015244.jpg" alt></p><h2 id="init-简略分析"><a href="#init-简略分析" class="headerlink" title="init 简略分析"></a>init 简略分析</h2><p>分析完了 <code>alloc</code> 的流程，我们接着分析 <code>init</code> 的流程。相比于 <code>alloc</code> 来说， <code>init</code> 内部实现十分简单，先来到的是 <code>_objc_rootInit</code> ，然后就直接返回 <code>obj</code> 了。其实这里是一种抽象工厂设计模式的体现，对于 <code>NSObject</code> 自带的 <code>init</code> 方法来说，其实啥也没干，但是如果你继承于 <code>NSObject</code> 的话，然后就可以去重写 <code>initWithXXX</code> 之类的初始化方法来做一些初始化操作。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootInit(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">_objc_rootInit(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// In practice, it will be hard to rely on this function.</span></span><br><span class="line">    <span class="comment">// Many classes do not properly chain -init calls.</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>先秦荀子的劝学中有言:</p><blockquote><p>不积跬步，无以至千里；不积小流，无以成江海。</p></blockquote><p>我们在探索 <code>iOS</code> 底层原理的时候，应该也是抱着这样的学习态度，注意点滴的积累，从小做起，积少成多。下一篇笔者将对本文留下的两个疑问进行解答:</p><ul><li>对象初始化内存是如何分配的？</li><li>isa 是如何初始化的?</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为 &lt;code&gt;iOS&lt;/code&gt; 开发者，我们每天打交道最多的应该就是对象了，从面向对象设计的角度来说，对象的创建以及初始化是最基础的内容。那么，今天我们就一起来探索一下 &lt;code&gt;iOS&lt;/code&gt; 中最常用的 &lt;code&gt;alloc&lt;/code&gt; 和 &lt;code&gt;init&lt;/code&gt;  的底层是怎么实现的吧。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 底层原理" scheme="http://leejunhui.com/categories/iOS-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://leejunhui.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>WWDC2012 iOS App Performance:Responsiveness 笔记</title>
    <link href="http://leejunhui.com/2019/12/10/WWDC2012-iOS-App-Performance-Responsiveness/"/>
    <id>http://leejunhui.com/2019/12/10/WWDC2012-iOS-App-Performance-Responsiveness/</id>
    <published>2019-12-10T03:55:32.000Z</published>
    <updated>2020-01-05T03:41:03.412Z</updated>
    
    <content type="html"><![CDATA[<p>如果观看过 <a href="https://developer.apple.com/videos/play/wwdc2012/235/" target="_blank" rel="noopener">WWDC 2012 Session 305 - iOS App Performance: Responsiveness</a> 可以略过本文。</p><p>首先，该篇 WWDC Session 有两个主题</p><ul><li>响应式：app 如何更快的响应用户操作</li><li>性能优化：让 app 高效的运行<a id="more"></a><h2 id="一、应用启动"><a href="#一、应用启动" class="headerlink" title="一、应用启动"></a>一、应用启动</h2></li><li>app 启动时间是第一指标</li><li>app 启动时会有一段过渡动画<ul><li>iPhone 上有 400 毫秒</li><li>iPad 上有 500 毫秒</li></ul></li><li>力争更快的启动 app</li></ul><p>iOS 系统会有一个 watchdog 来监测 app 的启动时间是否过长，根据 app 的生命周期，对应的时间阈值如下表所示：</p><table><thead><tr><th>场景</th><th>Watchdog 时间阈值</th></tr></thead><tbody><tr><td>启动 Launch</td><td>20 秒</td></tr><tr><td>重载 Resume</td><td>10 秒</td></tr><tr><td>挂起 Suspend</td><td>10 秒</td></tr><tr><td>退出 Quit</td><td>6 秒</td></tr><tr><td>后台任务 Background Task</td><td>10 分钟</td></tr></tbody></table><p>值得注意的是，如果是在 Xcode 中以 Debug 模式运行你的 app，这个 watchdog 机制是默认禁用的。也就是说在 Release 模式下才会激活这个机制。</p><h3 id="1-计算-app-的启动时间"><a href="#1-计算-app-的启动时间" class="headerlink" title="1.计算 app 的启动时间"></a>1.计算 app 的启动时间</h3><p><strong>选择一个合适的节点</strong></p><ul><li>Watchdog 会监听第一次 <code>CATranscation</code> 事务的结束<ul><li>第一次布局与渲染</li><li><code>CoreAnimation</code> 的内部方法 <code>-[UIApplication _reportAppLaunchFinshed]</code> </li></ul></li><li>用户可能关心的其它指标<ul><li>相机类 app 应该计算好快门开启的时间</li></ul></li></ul><h3 id="2-记录第一次渲染的开始和结束时间"><a href="#2-记录第一次渲染的开始和结束时间" class="headerlink" title="2.记录第一次渲染的开始和结束时间"></a>2.记录第一次渲染的开始和结束时间</h3><ul><li>在 main() 中获取渲染开始时间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    StartTime = CFAbsoluteTimeGetCurrent();</span><br></pre></td></tr></table></figure><ul><li>在 applicationDidFinishLaunching 中获得渲染结束时间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidFinishLaunching:(UIApplication *)app &#123;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;Launched in %f sec&quot;, CFAbsoluteTimeGetCurrent() - StartTime);    </span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里使用 GCD 的原因是在 <code>applicationDidFinishLaunching</code> 回调方法返回前，并不能确保 app 渲染完成了，所以需要使用异步的方式来在主线程上获取时间差。</p></blockquote><h3 id="3-使用-Time-Profiler-来计算第一次渲染所耗费的时间"><a href="#3-使用-Time-Profiler-来计算第一次渲染所耗费的时间" class="headerlink" title="3.使用 Time Profiler 来计算第一次渲染所耗费的时间"></a>3.使用 Time Profiler 来计算第一次渲染所耗费的时间</h3><h3 id="4-App-启动的流程"><a href="#4-App-启动的流程" class="headerlink" title="4.App 启动的流程"></a>4.App 启动的流程</h3><ul><li>链接和装载 Linking and loading</li><li>UIKit 初始化 </li><li>Application 回调</li><li>第一次 Core Animation 事务完成</li></ul><h3 id="5-App-启动总结"><a href="#5-App-启动总结" class="headerlink" title="5.App 启动总结"></a>5.App 启动总结</h3><blockquote><p>Launch is the first user interaction - it should be responsive<br>App 启动是用户的第一层交互，这个过程应该是顺滑的</p></blockquote><hr><blockquote><p>Measure launch time<br>计算启动耗费的时间</p></blockquote><hr><blockquote><p>Profile with Time Profiler<br>使用 Time Profiler 工具来调试</p></blockquote><hr><blockquote><p>Observe best practices<br>遵守最佳实践</p></blockquote><h2 id="二、性能优化策略"><a href="#二、性能优化策略" class="headerlink" title="二、性能优化策略"></a>二、性能优化策略</h2><h3 id="2-1-避免不必要的工作"><a href="#2-1-避免不必要的工作" class="headerlink" title="2.1 避免不必要的工作"></a>2.1 避免不必要的工作</h3><ul><li>对 App 进行 Profile 后，通常会揭露出 App 中一些不必要的模块</li><li>例子<ul><li>不必要的阴影和遮罩</li><li>对同一数据的多次请求</li><li>启动时过多的日志打印会耗费很多时间</li></ul></li></ul><h3 id="2-2-重用而不是重新创建"><a href="#2-2-重用而不是重新创建" class="headerlink" title="2.2 重用而不是重新创建"></a>2.2 重用而不是重新创建</h3><ul><li>特定的一些类的初始化是代价很高的<ul><li>TableView 的 cell</li><li>日期/数字 格式化器</li><li>正则表达式</li><li>SQLite 语句</li></ul></li><li>重用这些对象而不是重新创建</li></ul><h4 id="2-2-1-日期格式化-Date-Formatter"><a href="#2-2-1-日期格式化-Date-Formatter" class="headerlink" title="2.2.1 日期格式化 Date Formatter"></a>2.2.1 日期格式化 Date Formatter</h4><ul><li>使用日期格式化的大多数场景<ul><li>对于一种日期格式缓存对应的一个日期格式化器 (Date Formatter)</li><li>当收到 <code>NSLocaleDidChangeNotification</code> 通知时，让缓存失效</li></ul></li><li>设置格式和重新创建都是性能高昂的操作 </li></ul><h4 id="2-2-2-日历-Calendars"><a href="#2-2-2-日历-Calendars" class="headerlink" title="2.2.2 日历 Calendars"></a>2.2.2 日历 Calendars</h4><ul><li>每一句 <code>NSLog</code> 的调用都会创建一个新的 <code>calendar</code> 实例<ul><li>避免 <code>NSLog</code> 的过度使用</li></ul></li><li>通过调用 <code>+[NSCalendar currentCalendar]</code> 对于每个 cell 都返回一个新的实例出来<ul><li>如果重复使用的话应该保存这个实例</li></ul></li></ul><h4 id="2-2-3-SQLite-语句"><a href="#2-2-3-SQLite-语句" class="headerlink" title="2.2.3 SQLite 语句"></a>2.2.3 SQLite 语句</h4><ul><li>每一条 SQLite 语句都是一个可编译程序<ul><li>使用 <code>sqlite3_prepare</code> 将 SQL 查询语句转换为字节码</li></ul></li><li>使用绑定参数并重用语句</li></ul><h3 id="2-3-高效的开发"><a href="#2-3-高效的开发" class="headerlink" title="2.3 高效的开发"></a>2.3 高效的开发</h3><ul><li>选择合适的数据结构和算法</li><li>选择更快的算法</li></ul><h3 id="2-4-提前计算结果"><a href="#2-4-提前计算结果" class="headerlink" title="2.4 提前计算结果"></a>2.4 提前计算结果</h3><h3 id="2-5-异步加载"><a href="#2-5-异步加载" class="headerlink" title="2.5 异步加载"></a>2.5 异步加载</h3><h3 id="2-6-大量数据测试"><a href="#2-6-大量数据测试" class="headerlink" title="2.6 大量数据测试"></a>2.6 大量数据测试</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果观看过 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2012/235/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WWDC 2012 Session 305 - iOS App Performance: Responsiveness&lt;/a&gt; 可以略过本文。&lt;/p&gt;
&lt;p&gt;首先，该篇 WWDC Session 有两个主题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应式：app 如何更快的响应用户操作&lt;/li&gt;
&lt;li&gt;性能优化：让 app 高效的运行
    
    </summary>
    
      <category term="WWDC 笔记" scheme="http://leejunhui.com/categories/WWDC-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="WWDC" scheme="http://leejunhui.com/tags/WWDC/"/>
    
      <category term="翻译" scheme="http://leejunhui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS 最佳实践[译]（一）起步</title>
    <link href="http://leejunhui.com/2019/08/10/iOS-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E8%AF%91/"/>
    <id>http://leejunhui.com/2019/08/10/iOS-最佳实践-译/</id>
    <published>2019-08-10T03:07:46.000Z</published>
    <updated>2020-01-05T03:41:19.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-最佳实践（一）起步"><a href="#iOS-最佳实践（一）起步" class="headerlink" title="iOS 最佳实践（一）起步"></a>iOS 最佳实践（一）起步</h1><h2 id="为什么整理这篇文档"><a href="#为什么整理这篇文档" class="headerlink" title="为什么整理这篇文档?"></a>为什么整理这篇文档?</h2><p>刚开始从事 iOS 开发会有一点让人心生畏惧。<code>Swift</code>和<code>Objective-C</code>并不是被广泛使用的语言，这个平台几乎所有内容都有自己特有的名称，将你所编写的代码运行到一台设备上的过程可能是很坎坷的。这份文档就是来帮助你的，不论你是开始迈出你在<code>Cocoa王国</code>中的第一步还是对于<code>以正确的方式</code>编程。下面所有的内容都仅仅是建议，所以如果你有一个很好地理由用不同的方式来实现，那就去做吧!</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>如果您正在寻找特定的内容，您可以从这里直接跳到相关部分。</p><ol><li><a href="#1">起步</a></li><li><a href>常用库</a></li><li><a href>架构</a></li><li><a href>存储</a></li><li><a href>资源</a></li><li><a href>编码风格</a></li><li><a href>安全</a></li><li><a href>诊断</a></li><li><a href>分析</a></li><li><a href>编译</a></li><li><a href>分发</a></li><li><a href>内购(IAP)</a></li><li><a href>证书</a></li></ol><h2 id="1">起步</h2><h3>人机交互指南</h3><p>如果你来自其它平台，请花一些时间来熟悉苹果的<a href="https://developer.apple.com/ios/human-interface-guidelines/" target="_blank" rel="noopener">人机交互指南</a>。iOS 的世界非常强调要有一个良好的设计，你的app也不应例外。该指南还为设计人员提供了一个关于原生UI元素、以及如 3D Touch 或 Wallet 等 app 以及图标大小的实用概述。</p><h3 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h3><p><a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener">Xcode</a>是大多数iOS开发者所选择的IDE，同时也是苹果官方指定的唯一平台。除了<code>Xcode</code>外，还有一些替换方案，其中<a href="https://www.jetbrains.com/objc/" target="_blank" rel="noopener">AppCode</a>可以说是最出名的了，但除非你是经验丰富的iOS开发者，否则还是请使用<code>Xcode</code>吧。虽然它有一些缺点，但它现在确实很实用！</p><p>如需安装<code>Xcode</code>，直接在Mac的<a href="https://itunes.apple.com/us/app/xcode/id497799835" target="_blank" rel="noopener">App Store</a>上下载即可。它提供了最新的SDK和模拟器，您可以在首选项&gt;下载中安装更多的东西。</p><!-- more --><h3 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h3><p>当开始开发一个iOS项目的时候，一个常见的问题就是纯代码还是通过<code>Storyboards</code>或<code>XIB</code>文件来使用<code>Interface Builder</code>。众所周知两种方法都能完成工作。然而，这里有几点需要考虑的：</p><h4 id="为什么使用纯代码"><a href="#为什么使用纯代码" class="headerlink" title="为什么使用纯代码?"></a>为什么使用纯代码?</h4><ul><li><code>Storyboards</code>由于其复杂的XML结构，更容易发生版本冲突。这使得比纯代码更难完成合并。</li><li>纯代码更容易构造和重用视图，从而保持代码库的<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">DRY</a>。</li><li>所有的信息都在一个地方。在<code>Interface Builder</code>中，你必须单击所有检查器才能找到您要查找的内容。</li><li><code>Storyboards</code>引入了代码和UI之间的耦合，这可能导致崩溃，例如当<code>outlet</code>或<code>Action</code>没有正确被设置时。编译器不会检测到这些问题。</li></ul><h4 id="为什么使用Storyboards"><a href="#为什么使用Storyboards" class="headerlink" title="为什么使用Storyboards?"></a>为什么使用<code>Storyboards</code>?</h4><ul><li>对于不太倾向于技术的人来说，<code>Storyboards</code>是直接为项目做出贡献的好方法。例如，调整颜色和布局约束。然而，这是需要一个可行的项目设置并且花时间学习基础知识的过程。</li><li>由于可以在不构建项目的情况下预览更改，对于迭代开发来说更有优势。</li><li>自定义字体和UI元素都是以图形化的方式展现在<code>Storyboards</code>中，当在设计时对最终的外观有一个更好的了解。</li><li>对于<a href="http://futurice.com/blog/adaptive-views-in-ios-8" target="_blank" rel="noopener">size classes</a>, Interface Builder 能将你所选择的设备提供实时布局预览，包括iPad分屏多任务处理。</li></ul><h4 id="为什么不两者兼用呢"><a href="#为什么不两者兼用呢" class="headerlink" title="为什么不两者兼用呢?"></a>为什么不两者兼用呢?</h4><p>为了两全其美，你可以采取混用的方案：首先用<code>Storyboards</code>勾勒出最初的设计，对修补和快速更改非常有用。你甚至可以邀请设计师加入到这个流程中。随着UI的成熟和可靠性变得更加重要，你将过渡到更容易维护和协作的基于代码的方式开发。</p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>将版本控制引入项目的第一步就是要有一个正确的<code>.gitignore</code>文件。这样，不需要的文件（用户设置文件，临时文件等）将永远不会被纳入版本库。幸运的是，GitHub 已经提供了 <a href="https://github.com/github/gitignore/blob/master/Objective-C.gitignore" target="_blank" rel="noopener">OC</a> 和 <a href="https://github.com/github/gitignore/blob/master/Swift.gitignore" target="_blank" rel="noopener">Swift</a> 的<code>.gitignore</code>文件。</p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><h4 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h4><p>如果你打算在项目中引入第三方库的话，<a href="https://cocoapods.org/" target="_blank" rel="noopener">CocoaPods</a> 提供了简单快速的集成。安装它很简单，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p>初始化时，跳转到项目路径下，执行如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod init</span><br></pre></td></tr></table></figure><p>这会自动生成一个<code>Podfile</code>文件，这个文件用来管理项目的所有依赖。在<code>Podfile</code>中添加好依赖后，执行如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure><p>执行后会安装所依赖的第三方库，并且作为工程的一部分，这个工程当然也包含了你自己的项目。由于<a href="https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control" target="_blank" rel="noopener">这里</a>和<a href="https://www.dzombak.com/blog/2014/03/including-pods-in-source-control.html" target="_blank" rel="noopener">这里</a>的原因，我们推荐将<code>Pods</code>里面的内容也提交到版本库里面，而不是在每次新的代码签出后依赖于开发人员执行<code>pod install</code>。</p><blockquote><p>这里的原因大概可以这么来解释，通过将<code>Pods</code>文件夹加入版本库。当有新的开发人员克隆版本库的时候，只需要编译运行项目，不需要运行<code>pod install</code>这种需要长时间命令</p></blockquote><p>注意从现在开始，你需要打开<code>.xcworkspace</code>文件，而不是<code>.xcproject</code>文件，否则代码将无法编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update</span><br></pre></td></tr></table></figure><p>上面的命令将会更新所有的pods到<code>Podfile</code>文件上所允许的最新的版本。你可以使用<a href="http://guides.cocoapods.org/syntax/podfile.html#pod" target="_blank" rel="noopener">运算符</a>来指明你想要的版本。</p><h4 id="Carthage"><a href="#Carthage" class="headerlink" title="Carthage"></a>Carthage</h4><p><a href="https://github.com/Carthage/Carthage" target="_blank" rel="noopener">Carthage</a> 采用<a href="http://www.infoq.com/presentations/Simple-Made-Easy" target="_blank" rel="noopener">简约而不简单</a>的方式将你所依赖的代码打包成二进制库文件，而不是以神奇地将它们以各种方式集成到你的项目中。这会大大的减少编译时间，因为你的依赖在项目开始构建的时候就已经被编译好了。<br>由于没有集中式的项目仓库，这意味任何可以编译成框架的代码库都支持开箱即用的<code>Carthage</code>。<br>要开始引入<code>Carthage</code>到你的项目中的话，请遵循<code>Carthage</code>文档中的<a href="https://github.com/Carthage/Carthage#installing-carthage" target="_blank" rel="noopener">说明</a>。</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>为了避免将数以百计的源文件放置在同一个目录下，最好根据项目自身的架构设置一些文件夹结构层级。例如，你可以使用如下的划分方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├─ Models</span><br><span class="line">├─ Views</span><br><span class="line">├─ Controllers (或者是ViewModels, 如果你的项目是MVVM架构)</span><br><span class="line">├─ Stores</span><br><span class="line">├─ Helpers</span><br></pre></td></tr></table></figure><p>首先，在 Xcode 的项目导航器中的项目名称目录下创建组(黄色的小文件夹)，然后，对于每个组，通过点击 Xcode 的文件检查器下的灰色文件夹小图标，来到分组对应的真实物理路径，并创建对应名称的文件夹，并与 Xcode 中的组相关联。</p><h4 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h4><p>项目伊始将所有的字符串都存储到本地化文件，不仅为翻译提供了便利，同时为快速查找字符串提供了便利。你可以在<code>build scheme</code>中加入启动参数来指定app的语言：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-AppleLanguages (Finnish)</span><br></pre></td></tr></table></figure><p>而对于更加复杂的翻译场景，如取决于数量的复数形式(例如: “1 person” vs “3 people”)，你应该使用<a href="https://developer.apple.com/library/prerelease/ios/documentation/MacOSX/Conceptual/BPInternational/StringsdictFileFormat/StringsdictFileFormat.html" target="_blank" rel="noopener">.stringsdict</a>格式文件而不是常规的格式化字符串文件。一旦你将视线转移到这个疯狂的语法上，你就拥有了一个知道如何为 <code>one</code>，<code>some</code>，<code>few</code> 和 <code>many</code> 应用复数化的强大工具，<a href="http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html" target="_blank" rel="noopener">例如在俄语和阿拉伯语中</a>。</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>保持常量的作用域尽可能的小，例如，当你只需要在一个类中使用常量的时候，那么这个常量作用域应仅限于这个类。需要在全局作用域保存的常量应当统一存放在一个地方。在<code>Swift</code>中，你可以使用枚举来定义常量然后生成<code>Constants.swift</code>文件来组织、存储和获取全局作用域的常量，这是一种非常干净的方式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> baseURL = <span class="type">NSURL</span>(string: <span class="string">"http://www.example.org/"</span>)!</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> splineReticulatorName = <span class="string">"foobar"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> primaryColor = <span class="type">UIColor</span>(red: <span class="number">0.22</span>, green: <span class="number">0.58</span>, blue: <span class="number">0.29</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> secondaryColor = <span class="type">UIColor</span>.lightGray</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A visual way to define colours within code files is to use #colorLiteral</span></span><br><span class="line">    <span class="comment">// This syntax will present you with colour picker component right on the code line</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> tertiaryColor = #colorLiteral(red: <span class="number">0.22</span>, green: <span class="number">0.58</span>, blue: <span class="number">0.29</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你使用<code>Objective-C</code>时，将全局作用域常量存储在<code>Constant.h</code>文件中，该文件是被<code>Prefix Header</code>头文件所引用了的。<br>通过静态常量来代替预处理宏定义常量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">CGFloat</span> const <span class="type">XYZBrandingFontSizeSmall</span> = <span class="number">12</span>.0f;</span><br><span class="line"><span class="keyword">static</span> <span class="type">NSString</span> * const <span class="type">XYZAwesomenessDeliveredNotificationName</span> = @<span class="string">"foo"</span>;</span><br></pre></td></tr></table></figure><p>静态常量是类型安全的，有着更加显式的作用域(在未定义之前，它们不能在所有导入/包含的文件中使用)，在后续开发中不能被重定义或者未定义，并且是在调试器中可用的。</p><h3 id="分支模型"><a href="#分支模型" class="headerlink" title="分支模型"></a>分支模型</h3><p>特别是在向公众发布应用程序时（例如通过 App Store），使用适当的标签将发布版本与其他分支隔离是一个好主意。此外，涉及大量提交的新特性开发工作应该在它自己的分支上完成。<a href="https://github.com/nvie/gitflow" target="_blank" rel="noopener"><code>git-flow</code></a>是一个可以帮助你遵循这些约定的工具。它只是<code>Git</code>分支和标签命令的一个便捷的封装，但能帮助团队或个人维护一个适当的分支结构。<br>所有的开发都是基于<code>feature</code>分支(或针对较小的工作基于<code>Dev</code>分支)、基于app版本的标签的发布以及提交都要通过下列代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release finish &lt;version&gt;</span><br></pre></td></tr></table></figure><h3 id="最小的iOS兼容版本"><a href="#最小的iOS兼容版本" class="headerlink" title="最小的iOS兼容版本"></a>最小的iOS兼容版本</h3><p>尽早的决定你的项目所支持的最小iOS版本是十分有用的：明确需要基于哪个系统版本进行开发，测试以及哪些系统API可以使用可以帮助你评估工作量，并让你知道哪些是可用的，哪些是不安全的。</p><p>利用这些资源所收集的资料做出选择：</p><ul><li><p>官方第一手资源</p><ul><li><a href="https://developer.apple.com/support/app-store/" target="_blank" rel="noopener">苹果iOS设备占有率</a><br>版本渗透数据的主要统计渠道，如果可能的话，更倾向于本地化和特定领域的统计信息。</li></ul></li><li><p>第三方资源</p><ul><li><a href="http://iossupportmatrix.com/" target="_blank" rel="noopener">iOS Support Matrix</a> </li><li><a href="https://david-smith.org/iosversionstats/" target="_blank" rel="noopener">DavidSmith: iOS Version Stats</a></li><li><a href="https://mixpanel.com/trends/#report/ios_frag" target="_blank" rel="noopener">Mixpanel Trends: iOS versions</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS-最佳实践（一）起步&quot;&gt;&lt;a href=&quot;#iOS-最佳实践（一）起步&quot; class=&quot;headerlink&quot; title=&quot;iOS 最佳实践（一）起步&quot;&gt;&lt;/a&gt;iOS 最佳实践（一）起步&lt;/h1&gt;&lt;h2 id=&quot;为什么整理这篇文档&quot;&gt;&lt;a href=&quot;#为什么整理这篇文档&quot; class=&quot;headerlink&quot; title=&quot;为什么整理这篇文档?&quot;&gt;&lt;/a&gt;为什么整理这篇文档?&lt;/h2&gt;&lt;p&gt;刚开始从事 iOS 开发会有一点让人心生畏惧。&lt;code&gt;Swift&lt;/code&gt;和&lt;code&gt;Objective-C&lt;/code&gt;并不是被广泛使用的语言，这个平台几乎所有内容都有自己特有的名称，将你所编写的代码运行到一台设备上的过程可能是很坎坷的。这份文档就是来帮助你的，不论你是开始迈出你在&lt;code&gt;Cocoa王国&lt;/code&gt;中的第一步还是对于&lt;code&gt;以正确的方式&lt;/code&gt;编程。下面所有的内容都仅仅是建议，所以如果你有一个很好地理由用不同的方式来实现，那就去做吧!&lt;/p&gt;
    
    </summary>
    
      <category term="iOS最佳实践" scheme="http://leejunhui.com/categories/iOS%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="iOS" scheme="http://leejunhui.com/tags/iOS/"/>
    
      <category term="翻译" scheme="http://leejunhui.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="最佳实践" scheme="http://leejunhui.com/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>拥抱变化</title>
    <link href="http://leejunhui.com/2019/08/05/%E6%8B%A5%E6%8A%B1%E5%8F%98%E5%8C%96/"/>
    <id>http://leejunhui.com/2019/08/05/拥抱变化/</id>
    <published>2019-08-05T05:30:33.000Z</published>
    <updated>2019-08-14T13:08:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的厚度决定明天的高度，拥抱当下的变化，做时间的朋友。</p><p>近期书单:</p><ul><li>《态度》</li><li>《见识》</li><li>《浪潮之巅》</li><li>《数学之美》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天的厚度决定明天的高度，拥抱当下的变化，做时间的朋友。&lt;/p&gt;
&lt;p&gt;近期书单:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《态度》&lt;/li&gt;
&lt;li&gt;《见识》&lt;/li&gt;
&lt;li&gt;《浪潮之巅》&lt;/li&gt;
&lt;li&gt;《数学之美》&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="感悟" scheme="http://leejunhui.com/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="拥抱变化" scheme="http://leejunhui.com/tags/%E6%8B%A5%E6%8A%B1%E5%8F%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
